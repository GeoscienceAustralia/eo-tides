{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#eo-tides-tide-modelling-tools-for-large-scale-satellite-earth-observation-analysis","title":"<code>eo-tides</code>: Tide modelling tools for large-scale satellite Earth observation analysis","text":"<p><code>eo-tides</code> provides provides powerful parallelized tools for integrating satellite Earth observation data with tide modelling. \ud83d\udee0\ufe0f\ud83c\udf0a\ud83d\udef0\ufe0f</p> <p><code>eo-tides</code> combines advanced tide modelling functionality from the <code>pyTMD</code> package with <code>pandas</code>, <code>xarray</code> and <code>odc-geo</code>, providing a suite of flexible tools for efficient analysis of coastal and ocean Earth observation data \u2013 from regional, continental, to global scale.</p> <p>These tools can be applied to petabytes of freely available satellite data (e.g. from Digital Earth Australia or Microsoft Planetary Computer) loaded via Open Data Cube's <code>odc-stac</code> or <code>datacube</code> packages, supporting coastal and ocean earth observation analysis for any time period or location globally.</p> <p></p>"},{"location":"#highlights","title":"Highlights","text":"<ul> <li>\ud83c\udf0a Model tide heights and phases (e.g. high, low, ebb, flow) from multiple global ocean tide models in parallel, and return a <code>pandas.DataFrame</code> for further analysis</li> <li>\ud83d\udef0\ufe0f \"Tag\" satellite data with tide heights based on the exact moment of image acquisition</li> <li>\ud83c\udf10 Model tides for every individual satellite pixel through time, producing three-dimensional \"tide height\" <code>xarray</code>-format datacubes that can be integrated with satellite data</li> <li>\ud83d\udcc8 Calculate statistics describing local tide dynamics, as well as biases caused by interactions between tidal processes and satellite orbits</li> <li>\ud83d\udee0\ufe0f Validate modelled tides using measured sea levels from coastal tide gauges (e.g. GESLA Global Extreme Sea Level Analysis)</li> </ul>"},{"location":"#supported-tide-models","title":"Supported tide models","text":"<p><code>eo-tides</code> supports all ocean tide models supported by <code>pyTMD</code>. These include:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> <li>Technical University of Denmark tide models (DTU23)</li> </ul> <p>For instructions on how to set up these models for use in <code>eo-tides</code>, refer to Setting up tide models.</p>"},{"location":"#citing-eo-tides","title":"Citing <code>eo-tides</code>","text":"<p>To cite <code>eo-tides</code> in your work, please use the following Journal of Open Source Software citation:</p> Plain textBibTeX <pre><code>Bishop-Taylor, R., Phillips, C., Sagar, S., Newey, V., &amp; Sutterley, T., (2025). eo-tides: Tide modelling tools for large-scale satellite Earth observation analysis. Journal of Open Source Software, 10(109), 7786, https://doi.org/10.21105/joss.07786\n</code></pre> <pre><code>@article{Bishop-Taylor2025,\ndoi       = {10.21105/joss.07786},\nurl       = {https://doi.org/10.21105/joss.07786},\nyear      = {2025},\npublisher = {The Open Journal},\nvolume    = {10},\nnumber    = {109},\npages     = {7786},\nauthor    = {Robbi Bishop-Taylor and Claire Phillips and Stephen Sagar and Vanessa Newey and Tyler Sutterley},\ntitle     = {eo-tides: Tide modelling tools for large-scale satellite Earth observation analysis},\njournal   = {Journal of Open Source Software}\n}\n</code></pre> <p>In addition, please consider also citing the underlying <code>pyTMD</code> Python package which powers the tide modelling functionality behind <code>eo-tides</code>:</p> <pre><code>Sutterley, T. C., Alley, K., Brunt, K., Howard, S., Padman, L., Siegfried, M. (2017) pyTMD: Python-based tidal prediction software. 10.5281/zenodo.5555395\n</code></pre>"},{"location":"#contributing","title":"Contributing","text":"<p>We welcome contributions to <code>eo-tides</code>, both through posting issues (e.g. bug reports or feature suggestions), or directly via pull requests (e.g. bug fixes and new features). Read the Contributing guide for details about how you can get involved.</p>"},{"location":"#next-steps","title":"Next steps","text":"<p>To get started, first follow the guide to installing <code>eo-tides</code>, and then set up one or multiple global ocean tide models. </p>"},{"location":"api/","title":"API reference","text":""},{"location":"api/#eo_tides.model","title":"eo_tides.model","text":"<p>Core tide modelling functionality.</p> <p>This module provides tools for modelling ocean tide heights and phases for any location or time period using one or more global tide models.</p> <p>Functions:</p> Name Description <code>ensemble_tides</code> <p>Combine multiple tide models into a single locally optimised ensemble tide model.</p> <code>model_phases</code> <p>Model tide phases at multiple coordinates or timesteps using multiple ocean tide models.</p> <code>model_tides</code> <p>Model tide heights at multiple coordinates or timesteps using using multiple ocean tide models.</p>"},{"location":"api/#eo_tides.model.ensemble_tides","title":"ensemble_tides","text":"<pre><code>ensemble_tides(\n    tide_df,\n    crs,\n    ensemble_models,\n    ensemble_func=None,\n    ensemble_top_n=3,\n    ranking_points=\"https://dea-public-data-dev.s3-ap-southeast-2.amazonaws.com/derivative/dea_intertidal/supplementary/rankings_ensemble_2017-2019.fgb\",\n    ranking_valid_perc=0.02,\n    **idw_kwargs\n)\n</code></pre> <p>Combine multiple tide models into a single locally optimised ensemble tide model.</p> <p>Uses external model ranking data (e.g. satellite altimetry or NDWI-tide correlations along the coastline) to inform the selection of the best local models.</p> <p>This function performs the following steps:</p> <ol> <li>Takes a dataframe of tide heights from multiple tide models, as    produced by <code>eo_tides.model.model_tides</code></li> <li>Loads model ranking points from an external file, filters them    based on the valid data percentage, and retains relevant columns</li> <li>Interpolates the model rankings into the coordinates of the    original dataframe using Inverse Weighted Interpolation (IDW)</li> <li>Uses rankings to combine multiple tide models into a single    optimised ensemble model (by default, by taking the mean of the    top 3 ranked models)</li> <li>Returns a new dataframe with the combined ensemble model predictions</li> </ol> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>DataFrame produced by <code>eo_tides.model.model_tides</code>, containing tide model predictions in long format with columns: <code>[\"time\", \"x\", \"y\", \"tide_height\", \"tide_model\"]</code>.</p> required <code>string</code> <p>Coordinate reference system for the \"x\" and \"y\" coordinates in <code>tide_df</code>. Used to ensure that interpolations are performed in the correct CRS.</p> required <code>list</code> <p>A list of models to include in the ensemble modelling process. All values must exist as columns with the prefix \"rank_\" in <code>ranking_points</code>.</p> required <code>dict</code> <p>By default, a simple ensemble model will be calculated by taking the mean of the <code>ensemble_top_n</code> tide models at each location. However, a dictionary containing more complex ensemble calculations can also be provided. Dictionary keys are used to name output ensemble models; functions should take a column named \"rank\" and convert it to a weighting, e.g.: <code>ensemble_func = {\"ensemble-custom\": lambda x: x[\"rank\"] &lt;= 3}</code></p> <code>None</code> <code>int</code> <p>If <code>ensemble_func</code> is None, this sets the number of top models to include in the mean ensemble calculation. Defaults to 3.</p> <code>3</code> <code>str</code> <p>Path to the file containing model ranking points. This dataset should include columns containing rankings for each tide model, named with the prefix \"rank_\". e.g. \"rank_EOT20\". Low values should represent high rankings (e.g. 1 = top ranked). The default value points to an example file covering Australia.</p> <code>'https://dea-public-data-dev.s3-ap-southeast-2.amazonaws.com/derivative/dea_intertidal/supplementary/rankings_ensemble_2017-2019.fgb'</code> <code>float</code> <p>Minimum percentage of valid data required to include a model rank point in the analysis, as defined in a column named \"valid_perc\". Defaults to 0.02.</p> <code>0.02</code> <p>Optional keyword arguments to pass to the <code>idw</code> function used for interpolation. Useful values include <code>k</code> (number of nearest neighbours to use in interpolation), <code>max_dist</code> (maximum distance to nearest neighbours), and <code>k_min</code> (minimum number of neighbours required after <code>max_dist</code> is applied).</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>DataFrame containing the ensemble model predictions, matching the format of the input <code>tide_df</code> (e.g. columns <code>[\"time\", \"x\", \"y\", \"tide_height\", \"tide_model\"]</code>. By default the 'tide_model' column will be labeled \"ensemble\" for the combined model predictions (but if a custom dictionary of ensemble functions is provided via <code>ensemble_func</code>, each ensemble will be named using the provided dictionary keys).</p> Source code in <code>eo_tides/model.py</code> <pre><code>def ensemble_tides(\n    tide_df,\n    crs,\n    ensemble_models,\n    ensemble_func=None,\n    ensemble_top_n=3,\n    ranking_points=\"https://dea-public-data-dev.s3-ap-southeast-2.amazonaws.com/derivative/dea_intertidal/supplementary/rankings_ensemble_2017-2019.fgb\",\n    ranking_valid_perc=0.02,\n    **idw_kwargs,\n):\n    \"\"\"Combine multiple tide models into a single locally optimised ensemble tide model.\n\n    Uses external model ranking data (e.g. satellite altimetry or\n    NDWI-tide correlations along the coastline) to inform the\n    selection of the best local models.\n\n    This function performs the following steps:\n\n    1. Takes a dataframe of tide heights from multiple tide models, as\n       produced by `eo_tides.model.model_tides`\n    2. Loads model ranking points from an external file, filters them\n       based on the valid data percentage, and retains relevant columns\n    3. Interpolates the model rankings into the coordinates of the\n       original dataframe using Inverse Weighted Interpolation (IDW)\n    4. Uses rankings to combine multiple tide models into a single\n       optimised ensemble model (by default, by taking the mean of the\n       top 3 ranked models)\n    5. Returns a new dataframe with the combined ensemble model predictions\n\n    Parameters\n    ----------\n    tide_df : pandas.DataFrame\n        DataFrame produced by `eo_tides.model.model_tides`, containing\n        tide model predictions in long format with columns:\n        `[\"time\", \"x\", \"y\", \"tide_height\", \"tide_model\"]`.\n    crs : string\n        Coordinate reference system for the \"x\" and \"y\" coordinates in\n        `tide_df`. Used to ensure that interpolations are performed\n        in the correct CRS.\n    ensemble_models : list\n        A list of models to include in the ensemble modelling process.\n        All values must exist as columns with the prefix \"rank_\" in\n        `ranking_points`.\n    ensemble_func : dict, optional\n        By default, a simple ensemble model will be calculated by taking\n        the mean of the `ensemble_top_n` tide models at each location.\n        However, a dictionary containing more complex ensemble\n        calculations can also be provided. Dictionary keys are used\n        to name output ensemble models; functions should take a column\n        named \"rank\" and convert it to a weighting, e.g.:\n        `ensemble_func = {\"ensemble-custom\": lambda x: x[\"rank\"] &lt;= 3}`\n    ensemble_top_n : int, optional\n        If `ensemble_func` is None, this sets the number of top models\n        to include in the mean ensemble calculation. Defaults to 3.\n    ranking_points : str, optional\n        Path to the file containing model ranking points. This dataset\n        should include columns containing rankings for each tide\n        model, named with the prefix \"rank_\". e.g. \"rank_EOT20\".\n        Low values should represent high rankings (e.g. 1 = top ranked).\n        The default value points to an example file covering Australia.\n    ranking_valid_perc : float, optional\n        Minimum percentage of valid data required to include a model\n        rank point in the analysis, as defined in a column named\n        \"valid_perc\". Defaults to 0.02.\n    **idw_kwargs\n        Optional keyword arguments to pass to the `idw` function used\n        for interpolation. Useful values include `k` (number of nearest\n        neighbours to use in interpolation), `max_dist` (maximum\n        distance to nearest neighbours), and `k_min` (minimum number of\n        neighbours required after `max_dist` is applied).\n\n    Returns\n    -------\n    pandas.DataFrame\n        DataFrame containing the ensemble model predictions, matching\n        the format of the input `tide_df` (e.g. columns `[\"time\", \"x\",\n        \"y\", \"tide_height\", \"tide_model\"]`. By default the 'tide_model'\n        column will be labeled \"ensemble\" for the combined model\n        predictions (but if a custom dictionary of ensemble functions is\n        provided via `ensemble_func`, each ensemble will be named using\n        the provided dictionary keys).\n\n    \"\"\"\n    # Raise data if `tide_df` provided in wide format\n    if \"tide_model\" not in tide_df:\n        err_msg = (\n            \"`tide_df` does not contain the expected 'tide_model' and \"\n            \"'tide_height' columns. Ensure that tides were modelled in \"\n            \"long format (i.e. `output_format='long'` in `model_tides`).\",\n        )\n        raise Exception(err_msg)\n\n    # Extract x and y coords from dataframe\n    x = tide_df.index.get_level_values(level=\"x\")\n    y = tide_df.index.get_level_values(level=\"y\")\n\n    # Identify input datatype\n    input_dtype = tide_df.tide_height.dtype\n\n    # Load model ranks points and reproject to same CRS as x and y\n    model_ranking_cols = [f\"rank_{m}\" for m in ensemble_models]\n    try:\n        model_ranks_gdf = (\n            gpd.read_file(ranking_points, engine=\"pyogrio\")\n            .to_crs(crs)\n            .query(f\"valid_perc &gt; {ranking_valid_perc}\")\n            .dropna(how=\"all\")\n            .filter(model_ranking_cols + [\"geometry\"])  # noqa: RUF005\n        )\n    except KeyError:\n        error_msg = f\"\"\"\n        Not all of the expected \"rank_\" columns {model_ranking_cols} were\n        found in the columns of the ranking points file ({ranking_points}).\n        Consider passing a custom list of models using `ensemble_models`.\n        \"\"\"\n        raise Exception(textwrap.dedent(error_msg).strip()) from None\n\n    # Use points to interpolate model rankings into requested x and y\n    id_kwargs_str = \"\" if idw_kwargs == {} else idw_kwargs\n    print(f\"Interpolating model rankings using IDW interpolation {id_kwargs_str}\")\n    ensemble_ranks_df = (\n        # Run IDW interpolation on subset of ranking columns\n        pd.DataFrame(\n            idw(\n                input_z=model_ranks_gdf[model_ranking_cols],\n                input_x=model_ranks_gdf.geometry.x,\n                input_y=model_ranks_gdf.geometry.y,\n                output_x=x,\n                output_y=y,\n                **idw_kwargs,\n            ),\n            columns=model_ranking_cols,\n        )\n        .assign(x=x, y=y)\n        # Drop any duplicates then melt columns into long format\n        .drop_duplicates()\n        .melt(id_vars=[\"x\", \"y\"], var_name=\"tide_model\", value_name=\"rank\")\n        # Remove \"rank_\" prefix to get plain model names\n        .replace({\"^rank_\": \"\"}, regex=True)\n        # Set index columns and rank across groups\n        .set_index([\"tide_model\", \"x\", \"y\"])\n        .groupby([\"x\", \"y\"])\n        .rank()\n        .astype(\"float32\")  # use smaller dtype for rankings to save memory\n    )\n\n    # If no custom ensemble funcs are provided, use a default ensemble\n    # calculation that takes the mean of the top N tide models\n    if ensemble_func is None:\n        ensemble_func = {\"ensemble\": lambda x: x[\"rank\"] &lt;= ensemble_top_n}\n\n    # Create output list to hold computed ensemble model outputs\n    ensemble_list = []\n\n    # Loop through all provided ensemble generation functions\n    for ensemble_n, ensemble_f in ensemble_func.items():\n        print(f\"Combining models into single {ensemble_n} model\")\n\n        # Join ranks to input tide data, compute weightings and group\n        grouped = (\n            # Add tide model as an index so we can join with model ranks\n            tide_df.set_index(\"tide_model\", append=True)\n            .join(ensemble_ranks_df)\n            # Add temp columns containing weightings and weighted values\n            .assign(\n                weights=ensemble_f,  # use custom func to compute weights\n                weighted=lambda i: i.tide_height * i.weights,\n            )\n            # Groupby is specified in a weird order here as this seems\n            # to be the easiest way to preserve correct index sorting\n            .groupby([\"x\", \"y\", \"time\"])\n        )\n\n        # Use weightings to combine multiple models into single ensemble\n        ensemble_df = (\n            # Calculate weighted mean\n            grouped.weighted.sum()\n            .div(grouped.weights.sum())\n            # Make sure datatype is the same as the input\n            .astype(input_dtype)\n            # Convert to dataframe\n            .to_frame(\"tide_height\")\n            # Label ensemble model and ensure indexes are in expected order\n            .assign(tide_model=ensemble_n)\n            .reorder_levels([\"time\", \"x\", \"y\"], axis=0)\n        )\n\n        ensemble_list.append(ensemble_df)\n\n    # Combine all ensemble models and return as a single dataframe\n    return pd.concat(ensemble_list)\n</code></pre>"},{"location":"api/#eo_tides.model.ensemble_tides(tide_df)","title":"<code>tide_df</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(crs)","title":"<code>crs</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ensemble_models)","title":"<code>ensemble_models</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ensemble_func)","title":"<code>ensemble_func</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ensemble_top_n)","title":"<code>ensemble_top_n</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ranking_points)","title":"<code>ranking_points</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(ranking_valid_perc)","title":"<code>ranking_valid_perc</code>","text":""},{"location":"api/#eo_tides.model.ensemble_tides(**idw_kwargs)","title":"<code>**idw_kwargs</code>","text":""},{"location":"api/#eo_tides.model.model_phases","title":"model_phases","text":"<pre><code>model_phases(\n    x,\n    y,\n    time,\n    model=\"EOT20\",\n    directory=None,\n    time_offset=\"15 min\",\n    return_tides=False,\n    **model_tides_kwargs\n)\n</code></pre> <p>Model tide phases at multiple coordinates or timesteps using multiple ocean tide models.</p> <p>Ebb and low phases (low-flow, high-flow, high-ebb, low-ebb) are calculated by running the <code>eo_tides.model.model_tides</code> function twice, once for the requested timesteps, and again after subtracting a small time offset (15 mins by default). If tides increased over this period, they are assigned as \"flow\"; if they decreased, they are assigned as \"ebb\". Tides are considered \"high\" if equal or greater than 0 metres tide height, otherwise \"low\".</p> <p>This function supports all parameters that are supported by <code>model_tides</code>.</p> <p>For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>float or list of floats</code> <p>One or more x coordinates at which to model tides. Assumes degrees longitude (EPSG:4326) by default; use <code>crs</code> to specify a different coordinate reference system.</p> required <code>float or list of floats</code> <p>One or more y coordinates at which to model tides. Assumes degrees latitude (EPSG:4326) by default; use <code>crs</code> to specify a different coordinate reference system.</p> required <code>DatetimeLike</code> <p>One or more UTC times at which to model tide heights. Accepts any time format compatible with <code>pandas.to_datetime()</code>, e.g. datetime.datetime, pd.Timestamp, pd.DatetimeIndex, numpy.datetime64, or date/time strings (e.g. \"2020-01-01 23:00\"). For example: <code>time = pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code>.</p> required <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>str</code> <p>The time offset/delta used to generate a time series of offset tide heights required for phase calculation. Defaults to \"15 min\"; can be any string passed to <code>pandas.Timedelta</code>.</p> <code>'15 min'</code> <code>bool</code> <p>Whether to return intermediate modelled tide heights as a \"tide_height\" column in the output dataframe. Defaults to False.</p> <code>False</code> <p>Optional parameters passed to the <code>eo_tides.model.model_tides</code> function. Important parameters include <code>output_format</code> (e.g. whether to return results in wide or long format), <code>crop</code> (whether to crop tide model constituent files on-the-fly to improve performance) etc.</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing modelled tide phases.</p> Source code in <code>eo_tides/model.py</code> <pre><code>def model_phases(\n    x: float | list[float] | xr.DataArray,\n    y: float | list[float] | xr.DataArray,\n    time: DatetimeLike,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    time_offset: str = \"15 min\",\n    return_tides: bool = False,\n    **model_tides_kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"Model tide phases at multiple coordinates or timesteps using multiple ocean tide models.\n\n    Ebb and low phases (low-flow, high-flow, high-ebb, low-ebb)\n    are calculated by running the `eo_tides.model.model_tides`\n    function twice, once for the requested timesteps, and again\n    after subtracting a small time offset (15 mins by default).\n    If tides increased over this period, they are assigned as\n    \"flow\"; if they decreased, they are assigned as \"ebb\".\n    Tides are considered \"high\" if equal or greater than 0\n    metres tide height, otherwise \"low\".\n\n    This function supports all parameters that are supported\n    by `model_tides`.\n\n    For tide model setup instructions, refer to the guide:\n    https://geoscienceaustralia.github.io/eo-tides/setup/\n\n    Parameters\n    ----------\n    x : float or list of floats\n        One or more x coordinates at which to model tides. Assumes\n        degrees longitude (EPSG:4326) by default; use `crs` to specify\n        a different coordinate reference system.\n    y : float or list of floats\n        One or more y coordinates at which to model tides. Assumes\n        degrees latitude (EPSG:4326) by default; use `crs` to specify\n        a different coordinate reference system.\n    time : DatetimeLike\n        One or more UTC times at which to model tide heights. Accepts\n        any time format compatible with `pandas.to_datetime()`, e.g.\n        datetime.datetime, pd.Timestamp, pd.DatetimeIndex, numpy.datetime64,\n        or date/time strings (e.g. \"2020-01-01 23:00\"). For example:\n        `time = pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`.\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        Defaults to \"EOT20\"; specify \"all\" to use all models available\n        in `directory`. For a full list of available and supported models,\n        run `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    time_offset: str, optional\n        The time offset/delta used to generate a time series of\n        offset tide heights required for phase calculation. Defaults\n        to \"15 min\"; can be any string passed to `pandas.Timedelta`.\n    return_tides: bool, optional\n        Whether to return intermediate modelled tide heights as a\n        \"tide_height\" column in the output dataframe. Defaults to False.\n    **model_tides_kwargs :\n        Optional parameters passed to the `eo_tides.model.model_tides`\n        function. Important parameters include `output_format` (e.g.\n        whether to return results in wide or long format), `crop`\n        (whether to crop tide model constituent files on-the-fly to\n        improve performance) etc.\n\n    Returns\n    -------\n    pandas.DataFrame\n        A dataframe containing modelled tide phases.\n\n    \"\"\"\n    # Pop output format and mode for special handling\n    output_format = model_tides_kwargs.pop(\"output_format\", \"long\")\n    mode = model_tides_kwargs.pop(\"mode\", \"one-to-many\")\n\n    # Model tides\n    tide_df = model_tides(\n        x=x,\n        y=y,\n        time=time,\n        model=model,\n        directory=directory,\n        **model_tides_kwargs,\n    )\n\n    # Model tides for a time 15 minutes prior to each previously\n    # modelled satellite acquisition time. This allows us to compare\n    # tide heights to see if they are rising or falling.\n    pre_df = model_tides(\n        x=x,\n        y=y,\n        time=time - pd.Timedelta(time_offset),\n        model=model,\n        directory=directory,\n        **model_tides_kwargs,\n    )\n\n    # Compare tides computed for each timestep. If the previous tide\n    # was higher than the current tide, the tide is 'ebbing'. If the\n    # previous tide was lower, the tide is 'flowing'\n    ebb_flow = (tide_df.tide_height &lt; pre_df.tide_height.to_numpy()).replace(\n        {True: \"ebb\", False: \"flow\"},\n    )\n\n    # If tides are greater than 0, then \"high\", otherwise \"low\"\n    high_low = (tide_df.tide_height &gt;= 0).replace({True: \"high\", False: \"low\"})\n\n    # Combine into one string and add to data\n    tide_df[\"tide_phase\"] = high_low.astype(str) + \"-\" + ebb_flow.astype(str)\n\n    # Optionally convert to a wide format dataframe with a tide model in\n    # each dataframe column\n    if output_format == \"wide\":\n        # Pivot into wide format with each time model as a column\n        print(\"Converting to a wide format dataframe\")\n        tide_df = tide_df.pivot(columns=\"tide_model\")  # noqa: PD010\n\n        # If in 'one-to-one' mode, reindex using our input time/x/y\n        # values to ensure the output is sorted the same as our inputs\n        if mode == \"one-to-one\":\n            output_indices = pd.MultiIndex.from_arrays(\n                [time, x, y],\n                names=[\"time\", \"x\", \"y\"],\n            )\n            tide_df = tide_df.reindex(output_indices)\n\n        # Optionally drop tides\n        if not return_tides:\n            return tide_df.drop(\"tide_height\", axis=1)[\"tide_phase\"]\n\n    # Optionally drop tide heights\n    if not return_tides:\n        return tide_df.drop(\"tide_height\", axis=1)\n\n    return tide_df\n</code></pre>"},{"location":"api/#eo_tides.model.model_phases(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.model.model_phases(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.model.model_phases(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.model.model_phases(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.model.model_phases(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.model.model_phases(time_offset)","title":"<code>time_offset</code>","text":""},{"location":"api/#eo_tides.model.model_phases(return_tides)","title":"<code>return_tides</code>","text":""},{"location":"api/#eo_tides.model.model_phases(**model_tides_kwargs)","title":"<code>**model_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.model.model_tides","title":"model_tides","text":"<pre><code>model_tides(\n    x,\n    y,\n    time,\n    model=\"EOT20\",\n    directory=None,\n    crs=\"EPSG:4326\",\n    mode=\"one-to-many\",\n    output_format=\"long\",\n    output_units=\"m\",\n    method=\"linear\",\n    extrapolate=True,\n    cutoff=None,\n    crop=\"auto\",\n    crop_buffer=5,\n    append_node=False,\n    constituents=None,\n    parallel=True,\n    parallel_splits=\"auto\",\n    parallel_max=None,\n    ensemble_models=None,\n    extra_databases=None,\n    **ensemble_kwargs\n)\n</code></pre> <p>Model tide heights at multiple coordinates or timesteps using using multiple ocean tide models.</p> <p>This function is parallelised to improve performance, and supports all tidal models supported by <code>pyTMD</code>, including:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> <li>Technical University of Denmark tide models (DTU23)</li> </ul> <p>This function requires access to tide model data files. For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>This function is a modification of the <code>pyTMD</code> package's <code>pyTMD.compute.tide_elevations</code> function. For more info: https://pytmd.readthedocs.io/en/latest/api_reference/compute.html#pyTMD.compute.tide_elevations https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#directories</p> <p>Parameters:</p> Name Type Description Default <code>float or list of floats</code> <p>One or more x coordinates at which to model tides. Assumes degrees longitude (EPSG:4326) by default; use <code>crs</code> to specify a different coordinate reference system.</p> required <code>float or list of floats</code> <p>One or more y coordinates at which to model tides. Assumes degrees latitude (EPSG:4326) by default; use <code>crs</code> to specify a different coordinate reference system.</p> required <code>DatetimeLike</code> <p>One or more UTC times at which to model tide heights. Accepts any time format compatible with <code>pandas.to_datetime()</code>, e.g. datetime.datetime, pd.Timestamp, pd.DatetimeIndex, numpy.datetime64, or date/time strings (e.g. \"2020-01-01 23:00\"). For example: <code>time = pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code>.</p> required <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>str</code> <p>Input coordinate reference system for x/y coordinates. Defaults to \"EPSG:4326\" (degrees latitude, longitude).</p> <code>'EPSG:4326'</code> <code>str</code> <p>Tide modelling analysis mode. Supports two options:</p> <ul> <li> <p><code>\"one-to-many\"</code>: Models tides at every x/y coordinate for every timestep in <code>time</code>. This is useful for Earth observation workflows where you want to model tides at many spatial points for a common set of acquisition times (e.g. satellite overpasses).</p> </li> <li> <p><code>\"one-to-one\"</code>: Model tides using one timestep for each x/y coordinate. In this mode, the number of x/y coordinates must match the number of timesteps in <code>time</code>.</p> </li> </ul> <code>'one-to-many'</code> <code>str</code> <p>Whether to return the output dataframe in long format (with results stacked vertically along \"tide_model\" and \"tide_height\" columns), or wide format (with a column for each tide model). Defaults to \"long\".</p> <code>'long'</code> <code>str</code> <p>Units for the returned tide heights. Options are:</p> <ul> <li><code>\"m\"</code> (default): floating point values in metres</li> <li><code>\"cm\"</code>: integer values in centimetres (x100)</li> <li><code>\"mm\"</code>: integer values in millimetres (x1000)</li> </ul> <p>Using integer units can help reduce memory usage.</p> <code>'m'</code> <code>str</code> <p>Method used to interpolate tide model constituent files. Defaults to \"linear\"; options include:</p> <ul> <li><code>\"linear\"</code>, <code>\"nearest\"</code>: scipy regular grid interpolations</li> <li><code>\"spline\"</code>: scipy bivariate spline interpolation</li> <li><code>\"bilinear\"</code>: quick bilinear interpolation</li> </ul> <code>'linear'</code> <code>bool</code> <p>If True (default), extrapolate tides inland of the valid tide model extent using nearest-neighbor interpolation. This can ensure tide are returned everywhere, but accuracy may degrade with distance from the valid model extent (e.g. inland or along complex estuaries or rivers). Set <code>cutoff</code> to define the maximum extrapolation distance.</p> <code>True</code> <code>float</code> <p>Maximum distance in kilometres to extrapolate tides inland of the valid tide model extent. The default of None allows extrapolation at any (i.e. infinite) distance.</p> <code>None</code> <code>bool or str</code> <p>Whether to crop tide model files on-the-fly to improve performance. Defaults to \"auto\", which enables cropping when supported (some clipped model files limited to the western hemisphere may not support on-the-fly cropping). Use <code>crop_buffer</code> to adjust the buffer distance used for cropping.</p> <code>'auto'</code> <code>int or float</code> <p>The buffer distance in degrees to crop tide model files around the requested x/y coordinates. Defaults to 5, which will crop model files using a five degree buffer.</p> <code>5</code> <code>bool</code> <p>Apply adjustments to harmonic constituents to allow for periodic modulations over the 18.6-year nodal period (lunar nodal tide). Default is False.</p> <code>False</code> <code>list</code> <p>Optional list of tide constituents to use for tide prediction. Default is None, which will use all available constituents.</p> <code>None</code> <code>bool</code> <p>Whether to parallelise tide modelling. If multiple tide models are requested, these will be run in parallel. If enough workers are available, the analysis will also be split into spatial chunks for additional parallelisation (see \"parallel_splits\" below). Default is True.</p> <code>True</code> <code>str or int</code> <p>Whether to split the input x and y coordinates into smaller, evenly-sized chunks that are processed in parallel. This can provide a large performance boost when processing large numbers of coordinates. The default is \"auto\", which will automatically attempt to determine optimal splits based on available CPUs, the number of input points, and the number of models.</p> <code>'auto'</code> <code>int</code> <p>Maximum number of processes to run in parallel. The default of None will automatically determine this from your available CPUs.</p> <code>None</code> <code>list of str</code> <p>An optional list of models used to generate the ensemble tide model if \"ensemble\" tide modelling is requested. Defaults to <code>[\"EOT20\", \"FES2012\", \"FES2014_extrapolated\", \"FES2022_extrapolated\", \"GOT4.10\", \"GOT5.5_extrapolated\", \"GOT5.6_extrapolated\", \"TPXO10-atlas-v2-nc\", \"TPXO8-atlas-nc\", \"TPXO9-atlas-v5-nc\"]</code>.</p> <code>None</code> <code>str or path or list</code> <p>Additional custom tide model definitions to load, provided as dictionaries or paths to JSON database files. Use this to enable custom tide models not included with <code>pyTMD</code>. See: https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#model-database</p> <code>None</code> <p>Keyword arguments used to customise the generation of optional ensemble tide models if \"ensemble\" tide modelling is requested. These are passed to the underlying <code>_ensemble_model</code> function. Useful parameters include <code>ranking_points</code> (path to model rankings data), <code>k</code> (for controlling how model rankings are interpolated), and <code>ensemble_top_n</code> (how many top models to use in the ensemble calculation).</p> <code>{}</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing modelled tide heights.</p> Source code in <code>eo_tides/model.py</code> <pre><code>def model_tides(\n    x: float | list[float] | xr.DataArray,\n    y: float | list[float] | xr.DataArray,\n    time: DatetimeLike,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    crs: str = \"EPSG:4326\",\n    mode: str = \"one-to-many\",\n    output_format: str = \"long\",\n    output_units: str = \"m\",\n    method: str = \"linear\",\n    extrapolate: bool = True,\n    cutoff: float | None = None,\n    crop: bool | str = \"auto\",\n    crop_buffer: float | None = 5,\n    append_node: bool = False,\n    constituents: list[str] | None = None,\n    parallel: bool = True,\n    parallel_splits: int | str = \"auto\",\n    parallel_max: int | None = None,\n    ensemble_models: list[str] | None = None,\n    extra_databases: str | os.PathLike | list | None = None,\n    **ensemble_kwargs,\n) -&gt; pd.DataFrame:\n    \"\"\"Model tide heights at multiple coordinates or timesteps using using multiple ocean tide models.\n\n    This function is parallelised to improve performance, and\n    supports all tidal models supported by `pyTMD`, including:\n\n    - Empirical Ocean Tide model (EOT20)\n    - Finite Element Solution tide models (FES2022, FES2014, FES2012)\n    - TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)\n    - Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)\n    - Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)\n    - Technical University of Denmark tide models (DTU23)\n\n    This function requires access to tide model data files.\n    For tide model setup instructions, refer to the guide:\n    https://geoscienceaustralia.github.io/eo-tides/setup/\n\n    This function is a modification of the `pyTMD` package's\n    `pyTMD.compute.tide_elevations` function. For more info:\n    https://pytmd.readthedocs.io/en/latest/api_reference/compute.html#pyTMD.compute.tide_elevations\n    https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#directories\n\n    Parameters\n    ----------\n    x : float or list of floats\n        One or more x coordinates at which to model tides. Assumes\n        degrees longitude (EPSG:4326) by default; use `crs` to specify\n        a different coordinate reference system.\n    y : float or list of floats\n        One or more y coordinates at which to model tides. Assumes\n        degrees latitude (EPSG:4326) by default; use `crs` to specify\n        a different coordinate reference system.\n    time : DatetimeLike\n        One or more UTC times at which to model tide heights. Accepts\n        any time format compatible with `pandas.to_datetime()`, e.g.\n        datetime.datetime, pd.Timestamp, pd.DatetimeIndex, numpy.datetime64,\n        or date/time strings (e.g. \"2020-01-01 23:00\"). For example:\n        `time = pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`.\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        Defaults to \"EOT20\"; specify \"all\" to use all models available\n        in `directory`. For a full list of available and supported models,\n        run `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    crs : str, optional\n        Input coordinate reference system for x/y coordinates.\n        Defaults to \"EPSG:4326\" (degrees latitude, longitude).\n    mode : str, optional\n        Tide modelling analysis mode. Supports two options:\n\n        - `\"one-to-many\"`: Models tides at every x/y coordinate for\n        every timestep in `time`. This is useful for Earth observation\n        workflows where you want to model tides at many spatial points\n        for a common set of acquisition times (e.g. satellite overpasses).\n\n        - `\"one-to-one\"`: Model tides using one timestep for each x/y\n        coordinate. In this mode, the number of x/y coordinates must\n        match the number of timesteps in `time`.\n    output_format : str, optional\n        Whether to return the output dataframe in long format (with\n        results stacked vertically along \"tide_model\" and \"tide_height\"\n        columns), or wide format (with a column for each tide model).\n        Defaults to \"long\".\n    output_units : str, optional\n        Units for the returned tide heights. Options are:\n\n        - `\"m\"` (default): floating point values in metres\n        - `\"cm\"`: integer values in centimetres (x100)\n        - `\"mm\"`: integer values in millimetres (x1000)\n\n        Using integer units can help reduce memory usage.\n    method : str, optional\n        Method used to interpolate tide model constituent files.\n        Defaults to \"linear\"; options include:\n\n        - `\"linear\"`, `\"nearest\"`: scipy regular grid interpolations\n        - `\"spline\"`: scipy bivariate spline interpolation\n        - `\"bilinear\"`: quick bilinear interpolation\n    extrapolate : bool, optional\n        If True (default), extrapolate tides inland of the valid tide\n        model extent using nearest-neighbor interpolation. This can\n        ensure tide are returned everywhere, but accuracy may degrade\n        with distance from the valid model extent (e.g. inland or along\n        complex estuaries or rivers). Set `cutoff` to define the\n        maximum extrapolation distance.\n    cutoff : float, optional\n        Maximum distance in kilometres to extrapolate tides inland of the\n        valid tide model extent. The default of None allows extrapolation\n        at any (i.e. infinite) distance.\n    crop : bool or str, optional\n        Whether to crop tide model files on-the-fly to improve performance.\n        Defaults to \"auto\", which enables cropping when supported (some\n        clipped model files limited to the western hemisphere may not support\n        on-the-fly cropping). Use `crop_buffer` to adjust the buffer\n        distance used for cropping.\n    crop_buffer : int or float, optional\n        The buffer distance in degrees to crop tide model files around the\n        requested x/y coordinates. Defaults to 5, which will crop model\n        files using a five degree buffer.\n    append_node : bool, optional\n        Apply adjustments to harmonic constituents to allow for periodic\n        modulations over the 18.6-year nodal period (lunar nodal tide).\n        Default is False.\n    constituents : list, optional\n        Optional list of tide constituents to use for tide prediction.\n        Default is None, which will use all available constituents.\n    parallel : bool, optional\n        Whether to parallelise tide modelling. If multiple tide models\n        are requested, these will be run in parallel. If enough workers\n        are available, the analysis will also be split into spatial\n        chunks for additional parallelisation (see \"parallel_splits\"\n        below). Default is True.\n    parallel_splits : str or int, optional\n        Whether to split the input x and y coordinates into smaller,\n        evenly-sized chunks that are processed in parallel. This can\n        provide a large performance boost when processing large numbers\n        of coordinates. The default is \"auto\", which will automatically\n        attempt to determine optimal splits based on available CPUs,\n        the number of input points, and the number of models.\n    parallel_max : int, optional\n        Maximum number of processes to run in parallel. The default of\n        None will automatically determine this from your available CPUs.\n    ensemble_models : list of str, optional\n        An optional list of models used to generate the ensemble tide\n        model if \"ensemble\" tide modelling is requested. Defaults to\n        `[\"EOT20\", \"FES2012\", \"FES2014_extrapolated\", \"FES2022_extrapolated\",\n        \"GOT4.10\", \"GOT5.5_extrapolated\", \"GOT5.6_extrapolated\",\n        \"TPXO10-atlas-v2-nc\", \"TPXO8-atlas-nc\", \"TPXO9-atlas-v5-nc\"]`.\n    extra_databases : str or path or list, optional\n        Additional custom tide model definitions to load, provided as\n        dictionaries or paths to JSON database files. Use this to\n        enable custom tide models not included with `pyTMD`.\n        See: https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#model-database\n    **ensemble_kwargs :\n        Keyword arguments used to customise the generation of optional\n        ensemble tide models if \"ensemble\" tide modelling is requested.\n        These are passed to the underlying `_ensemble_model` function.\n        Useful parameters include `ranking_points` (path to model\n        rankings data), `k` (for controlling how model rankings are\n        interpolated), and `ensemble_top_n` (how many top models to use\n        in the ensemble calculation).\n\n    Returns\n    -------\n    pandas.DataFrame\n        A dataframe containing modelled tide heights.\n\n    \"\"\"\n    # Turn inputs into arrays for consistent handling\n    x = np.atleast_1d(x)\n    y = np.atleast_1d(y)\n    time = _standardise_time(time)\n\n    # Validate input arguments\n    if time is None:\n        err_msg = \"Times for modelling tides must be provided via `time`.\"\n        raise ValueError(err_msg)\n\n    if method not in (\"bilinear\", \"spline\", \"linear\", \"nearest\"):\n        err_msg = (\n            f\"Invalid interpolation method '{method}'. Must be one of 'bilinear', 'spline', 'linear', or 'nearest'.\"\n        )\n        raise ValueError(err_msg)\n\n    if output_units not in (\"m\", \"cm\", \"mm\"):\n        err_msg = \"Output units must be either 'm', 'cm', or 'mm'.\"\n        raise ValueError(err_msg)\n\n    if output_format not in (\"long\", \"wide\"):\n        err_msg = \"Output format must be either 'long' or 'wide'.\"\n        raise ValueError(err_msg)\n\n    if not np.issubdtype(x.dtype, np.number):\n        err_msg = \"`x` must contain only valid numeric values, and must not be None.\"\n        raise TypeError(err_msg)\n\n    if not np.issubdtype(y.dtype, np.number):\n        err_msg = \"`y` must contain only valid numeric values, and must not be None.\"\n        raise TypeError(err_msg)\n\n    if len(x) != len(y):\n        err_msg = \"`x` and `y` must be the same length.\"\n        raise ValueError(err_msg)\n\n    if mode == \"one-to-one\" and len(x) != len(time):\n        err_msg = (\n            \"The number of supplied `x` and `y` points and `time` values must be \"\n            \"identical in 'one-to-one' mode. Use 'one-to-many' mode if you intended \"\n            \"to model multiple timesteps at each point.\"\n        )\n        raise ValueError(err_msg)\n\n    # Set tide modelling files directory. If no custom path is\n    # provided, try global environment variable.\n    directory = _set_directory(directory)\n\n    # Standardise model list, handling \"all\" and \"ensemble\" functionality,\n    # and any custom tide model definitions\n    models_to_process, models_requested, ensemble_models = _standardise_models(\n        model=model,\n        directory=directory,\n        ensemble_models=ensemble_models,\n        extra_databases=extra_databases,\n    )\n\n    # Update tide modelling func to add default keyword arguments that\n    # are used for every iteration during parallel processing\n    iter_func = partial(\n        _model_tides,\n        directory=directory,\n        crs=crs,\n        mode=mode,\n        output_units=output_units,\n        method=method,\n        extrapolate=extrapolate,\n        cutoff=np.inf if cutoff is None else cutoff,\n        crop=crop,\n        crop_buffer=crop_buffer,\n        append_node=append_node,\n        constituents=constituents,\n        extra_databases=extra_databases,\n    )\n\n    # If automatic parallel splits, calculate optimal value\n    # based on available parallelisation, number of points\n    # and number of models\n    if parallel_splits == \"auto\":\n        parallel_splits = _parallel_splits(\n            total_points=len(x),\n            model_count=len(models_to_process),\n            parallel_max=parallel_max,\n        )\n\n    # Verify that parallel splits are not larger than number of points\n    assert isinstance(parallel_splits, int)  # noqa: S101\n    if parallel_splits &gt; len(x):\n        err_msg = f\"Parallel splits ({parallel_splits}) cannot be larger than the number of points ({len(x)}).\"\n        raise ValueError(err_msg)\n\n    # Parallelise if either multiple models or multiple splits requested\n    if parallel &amp; ((len(models_to_process) &gt; 1) | (parallel_splits &gt; 1)):\n        with ProcessPoolExecutor(max_workers=parallel_max) as executor:\n            print(\n                f\"Modelling tides with {', '.join(models_to_process)} in parallel (models: {len(models_to_process)}, splits: {parallel_splits})\",\n            )\n\n            # Optionally split lon/lat points into `splits_n` chunks\n            # that will be applied in parallel\n            x_split = np.array_split(x, parallel_splits)\n            y_split = np.array_split(y, parallel_splits)\n\n            # Get every combination of models and lat/lon points, and\n            # extract as iterables that can be passed to `executor.map()`\n            # In \"one-to-many\" mode, pass entire set of timesteps to each\n            # parallel iteration by repeating timesteps by number of total\n            # parallel iterations. In \"one-to-one\" mode, split up\n            # timesteps into smaller parallel chunks too.\n            if mode == \"one-to-many\":\n                model_iters, x_iters, y_iters = zip(\n                    *[(m, x_split[i], y_split[i]) for m in models_to_process for i in range(parallel_splits)],\n                    strict=False,\n                )\n                time_iters = [time] * len(model_iters)\n            elif mode == \"one-to-one\":\n                time_split = np.array_split(time, parallel_splits)\n                model_iters, x_iters, y_iters, time_iters = zip(\n                    *[\n                        (m, x_split[i], y_split[i], time_split[i])\n                        for m in models_to_process\n                        for i in range(parallel_splits)\n                    ],\n                    strict=False,\n                )\n\n            # Apply func in parallel, iterating through each input param\n            try:\n                model_outputs = list(\n                    tqdm(\n                        executor.map(\n                            iter_func,\n                            model_iters,\n                            x_iters,\n                            y_iters,\n                            time_iters,\n                        ),\n                        total=len(model_iters),\n                    ),\n                )\n            except BrokenProcessPool:\n                err_msg = (\n                    \"Parallelised tide modelling failed, likely to to an out-of-memory error. \"\n                    \"Try reducing the size of your analysis, or set `parallel=False`.\"\n                )\n                raise RuntimeError(err_msg) from None\n\n    # Model tides in series if parallelisation is off\n    else:\n        model_outputs = []\n\n        for model_i in models_to_process:\n            print(f\"Modelling tides with {model_i}\")\n            tide_df = iter_func(model_i, x, y, time)\n            model_outputs.append(tide_df)\n\n    # Combine outputs into a single dataframe\n    tide_df = pd.concat(model_outputs, axis=0)\n\n    # Optionally compute ensemble model and add to dataframe\n    if \"ensemble\" in models_requested:\n        ensemble_df = ensemble_tides(tide_df, crs, ensemble_models, **ensemble_kwargs)\n\n        # Update requested models with any custom ensemble models, then\n        # filter the dataframe to keep only models originally requested\n        models_requested = list(\n            np.union1d(models_requested, ensemble_df.tide_model.unique()),\n        )\n        tide_df = pd.concat([tide_df, ensemble_df]).query(\n            \"tide_model in @models_requested\",\n        )\n\n    # Optionally convert to a wide format dataframe with a tide model in\n    # each dataframe column\n    if output_format == \"wide\":\n        # Pivot into wide format with each time model as a column\n        print(\"Converting to a wide format dataframe\")\n        tide_df = tide_df.pivot(columns=\"tide_model\", values=\"tide_height\")  # noqa: PD010\n\n        # If in 'one-to-one' mode, reindex using our input time/x/y\n        # values to ensure the output is sorted the same as our inputs\n        if mode == \"one-to-one\":\n            output_indices = pd.MultiIndex.from_arrays(\n                [time, x, y],\n                names=[\"time\", \"x\", \"y\"],\n            )\n            tide_df = tide_df.reindex(output_indices)\n\n    return tide_df\n</code></pre>"},{"location":"api/#eo_tides.model.model_tides(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.model.model_tides(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.model.model_tides(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.model.model_tides(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.model.model_tides(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.model.model_tides(crs)","title":"<code>crs</code>","text":""},{"location":"api/#eo_tides.model.model_tides(mode)","title":"<code>mode</code>","text":""},{"location":"api/#eo_tides.model.model_tides(output_format)","title":"<code>output_format</code>","text":""},{"location":"api/#eo_tides.model.model_tides(output_units)","title":"<code>output_units</code>","text":""},{"location":"api/#eo_tides.model.model_tides(method)","title":"<code>method</code>","text":""},{"location":"api/#eo_tides.model.model_tides(extrapolate)","title":"<code>extrapolate</code>","text":""},{"location":"api/#eo_tides.model.model_tides(cutoff)","title":"<code>cutoff</code>","text":""},{"location":"api/#eo_tides.model.model_tides(crop)","title":"<code>crop</code>","text":""},{"location":"api/#eo_tides.model.model_tides(crop_buffer)","title":"<code>crop_buffer</code>","text":""},{"location":"api/#eo_tides.model.model_tides(append_node)","title":"<code>append_node</code>","text":""},{"location":"api/#eo_tides.model.model_tides(constituents)","title":"<code>constituents</code>","text":""},{"location":"api/#eo_tides.model.model_tides(parallel)","title":"<code>parallel</code>","text":""},{"location":"api/#eo_tides.model.model_tides(parallel_splits)","title":"<code>parallel_splits</code>","text":""},{"location":"api/#eo_tides.model.model_tides(parallel_max)","title":"<code>parallel_max</code>","text":""},{"location":"api/#eo_tides.model.model_tides(ensemble_models)","title":"<code>ensemble_models</code>","text":""},{"location":"api/#eo_tides.model.model_tides(extra_databases)","title":"<code>extra_databases</code>","text":""},{"location":"api/#eo_tides.model.model_tides(**ensemble_kwargs)","title":"<code>**ensemble_kwargs</code>","text":""},{"location":"api/#eo_tides.eo","title":"eo_tides.eo","text":"<p>Tools for integrating satellite EO data with tide modelling.</p> <p>This module provides tools for combining satellite EO observations with tide heights and phases using one or more ocean tide models, both at the timestep and at the pixel level.</p> <p>Functions:</p> Name Description <code>pixel_tides</code> <p>Model tide heights for every dataset pixel using multiple ocean tide models.</p> <code>tag_tides</code> <p>Model tide heights and phases for every dataset timestep using multiple ocean tide models.</p> <code>tag_timeseries</code> <p>Match time series observations to the time steps of a dataset.</p>"},{"location":"api/#eo_tides.eo.pixel_tides","title":"pixel_tides","text":"<pre><code>pixel_tides(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    resample=True,\n    calculate_quantiles=None,\n    resolution=None,\n    buffer=None,\n    resample_method=\"bilinear\",\n    dask_chunks=None,\n    dask_compute=True,\n    **model_tides_kwargs\n)\n</code></pre> <p>Model tide heights for every dataset pixel using multiple ocean tide models.</p> <p>This function models tides into a low-resolution tide modelling grid covering the spatial extent of the input data (buffered to reduce potential edge effects). These modelled tides can then be resampled back into the original higher resolution dataset's extent and resolution to produce a modelled tide height for every pixel through time.</p> <p>This function uses the parallelised <code>model_tides</code> function under the hood. It supports all tidal models supported by <code>pyTMD</code>, including:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> <li>Technical University of Denmark tide models (DTU23)</li> </ul> <p>This function requires access to tide model data files. For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to define the spatial tide modelling grid. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, a new \"tide_model\" dimension will be added to the <code>xarray.DataArray</code> outputs. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>bool</code> <p>Whether to resample low resolution tides back into <code>data</code>'s original higher resolution grid. Set this to <code>False</code> if you do not want low resolution tides to be re-projected back to higher resolution.</p> <code>True</code> <code>tuple of float or numpy.ndarray</code> <p>Rather than returning all individual tides, low-resolution tides can be first aggregated using a quantile calculation by passing in a tuple or array of quantiles to compute. For example, this could be used to calculate the min/max tide across all times: <code>calculate_quantiles=(0.0, 1.0)</code>.</p> <code>None</code> <code>float</code> <p>The desired resolution of the low-resolution grid used for tide modelling. The default None will create a 5000 m resolution grid if <code>data</code> has a projected CRS (i.e. metre units), or a 0.05 degree resolution grid if <code>data</code> has a geographic CRS (e.g. degree units). Note: higher resolutions do not necessarily provide better tide modelling performance, as results will be limited by the resolution of the underlying global tide model (e.g. 1/16th degree / ~5 km resolution grid for FES2014).</p> <code>None</code> <code>float</code> <p>The amount by which to buffer the higher resolution grid extent when creating the new low resolution grid. This buffering ensures that modelled tides are seamless across analysis boundaries. This buffer is eventually be clipped away when the low-resolution modelled tides are re-projected back to the original resolution and extent of <code>data</code>. To ensure that at least two low-resolution grid pixels occur outside of the dataset bounds, the default None applies a 12000 m buffer if <code>data</code> has a projected CRS (i.e. metre units), or a 0.12 degree buffer if <code>data</code> has a geographic CRS (e.g. degree units).</p> <code>None</code> <code>str</code> <p>If resampling is requested (see <code>resample</code> above), use this resampling method when resampling from low resolution to high resolution pixels. Defaults to \"bilinear\"; valid options include \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.</p> <code>'bilinear'</code> <code>tuple of float</code> <p>Can be used to configure custom Dask chunking for the final resampling step. By default, chunks will be automatically set to match y/x chunks from <code>data</code> if they exist; otherwise chunks will be chosen to cover the entire y/x extent of the dataset. For custom chunks, provide a tuple in the form <code>(y, x)</code>, e.g. <code>(2048, 2048)</code>.</p> <code>None</code> <code>bool</code> <p>Whether to compute results of the resampling step using Dask. If False, <code>tides_highres</code> will be returned as a Dask-enabled array.</p> <code>True</code> <p>Optional parameters passed to the <code>eo_tides.model.model_tides</code> function. Important parameters include <code>cutoff</code> (used to extrapolate modelled tides away from the coast; defaults to <code>np.inf</code>), <code>crop</code> (whether to crop tide model constituent files on-the-fly to improve performance) etc.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tides_da</code> <code>DataArray</code> <p>A three-dimensional tide height array. If <code>resample=True</code> (default), a high-resolution array of tide heights will be returned that matches the exact spatial resolution and extents of <code>data</code>. This will contain either tide heights for every timestep in <code>data</code> (or in <code>times</code> if provided), or tide height quantiles for every quantile provided by <code>calculate_quantiles</code>. If <code>resample=False</code>, results for the intermediate low-resolution tide modelling grid will be returned instead.</p> Source code in <code>eo_tides/eo.py</code> <pre><code>def pixel_tides(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    resample: bool = True,\n    calculate_quantiles: np.ndarray | tuple[float, float] | None = None,\n    resolution: float | None = None,\n    buffer: float | None = None,\n    resample_method: str = \"bilinear\",\n    dask_chunks: tuple[float, float] | None = None,\n    dask_compute: bool = True,\n    **model_tides_kwargs,\n) -&gt; xr.DataArray:\n    \"\"\"Model tide heights for every dataset pixel using multiple ocean tide models.\n\n    This function models tides into a low-resolution tide\n    modelling grid covering the spatial extent of the input\n    data (buffered to reduce potential edge effects). These\n    modelled tides can then be resampled back into the original\n    higher resolution dataset's extent and resolution to\n    produce a modelled tide height for every pixel through time.\n\n    This function uses the parallelised `model_tides` function\n    under the hood. It supports all tidal models supported by\n    `pyTMD`, including:\n\n    - Empirical Ocean Tide model (EOT20)\n    - Finite Element Solution tide models (FES2022, FES2014, FES2012)\n    - TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)\n    - Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)\n    - Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)\n    - Technical University of Denmark tide models (DTU23)\n\n    This function requires access to tide model data files.\n    For tide model setup instructions, refer to the guide:\n    https://geoscienceaustralia.github.io/eo-tides/setup/\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to define the spatial tide modelling grid. If `data`\n        is an xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, a new \"tide_model\" dimension will be\n        added to the `xarray.DataArray` outputs. Defaults to \"EOT20\";\n        specify \"all\" to use all models available in `directory`.\n        For a full list of available and supported models, run\n        `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    resample : bool, optional\n        Whether to resample low resolution tides back into `data`'s original\n        higher resolution grid. Set this to `False` if you do not want\n        low resolution tides to be re-projected back to higher resolution.\n    calculate_quantiles : tuple of float or numpy.ndarray, optional\n        Rather than returning all individual tides, low-resolution tides\n        can be first aggregated using a quantile calculation by passing in\n        a tuple or array of quantiles to compute. For example, this could\n        be used to calculate the min/max tide across all times:\n        `calculate_quantiles=(0.0, 1.0)`.\n    resolution : float, optional\n        The desired resolution of the low-resolution grid used for tide\n        modelling. The default None will create a 5000 m resolution grid\n        if `data` has a projected CRS (i.e. metre units), or a 0.05 degree\n        resolution grid if `data` has a geographic CRS (e.g. degree units).\n        Note: higher resolutions do not necessarily provide better\n        tide modelling performance, as results will be limited by the\n        resolution of the underlying global tide model (e.g. 1/16th\n        degree / ~5 km resolution grid for FES2014).\n    buffer : float, optional\n        The amount by which to buffer the higher resolution grid extent\n        when creating the new low resolution grid. This buffering\n        ensures that modelled tides are seamless across analysis\n        boundaries. This buffer is eventually be clipped away when\n        the low-resolution modelled tides are re-projected back to the\n        original resolution and extent of `data`. To ensure that at least\n        two low-resolution grid pixels occur outside of the dataset\n        bounds, the default None applies a 12000 m buffer if `data` has a\n        projected CRS (i.e. metre units), or a 0.12 degree buffer if\n        `data` has a geographic CRS (e.g. degree units).\n    resample_method : str, optional\n        If resampling is requested (see `resample` above), use this\n        resampling method when resampling from low resolution to high\n        resolution pixels. Defaults to \"bilinear\"; valid options include\n        \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.\n    dask_chunks : tuple of float, optional\n        Can be used to configure custom Dask chunking for the final\n        resampling step. By default, chunks will be automatically set\n        to match y/x chunks from `data` if they exist; otherwise chunks\n        will be chosen to cover the entire y/x extent of the dataset.\n        For custom chunks, provide a tuple in the form `(y, x)`, e.g.\n        `(2048, 2048)`.\n    dask_compute : bool, optional\n        Whether to compute results of the resampling step using Dask.\n        If False, `tides_highres` will be returned as a Dask-enabled array.\n    **model_tides_kwargs :\n        Optional parameters passed to the `eo_tides.model.model_tides`\n        function. Important parameters include `cutoff` (used to\n        extrapolate modelled tides away from the coast; defaults to\n        `np.inf`), `crop` (whether to crop tide model constituent files\n        on-the-fly to improve performance) etc.\n\n    Returns\n    -------\n    tides_da : xr.DataArray\n        A three-dimensional tide height array.\n        If `resample=True` (default), a high-resolution array of tide\n        heights will be returned that matches the exact spatial resolution\n        and extents of `data`. This will contain either tide heights for\n        every timestep in `data` (or in `times` if provided), or tide height\n        quantiles for every quantile provided by `calculate_quantiles`.\n        If `resample=False`, results for the intermediate low-resolution\n        tide modelling grid will be returned instead.\n\n    \"\"\"\n    # Standardise data inputs, time and models\n    gbox, time_coords = _standardise_inputs(data, time)\n    dask_chunks = _resample_chunks(data, dask_chunks)\n    model = [model] if isinstance(model, str) else model\n\n    # Determine spatial dimensions\n    y_dim, x_dim = gbox.dimensions\n\n    # Determine resolution and buffer, using different defaults for\n    # geographic (i.e. degrees) and projected (i.e. metres) CRSs:\n    assert gbox.crs is not None  # noqa: S101\n    crs_units = gbox.crs.units[0][0:6]\n    if gbox.crs.geographic:\n        if resolution is None:\n            resolution = 0.05\n        elif resolution &gt; 360:\n            err_msg = (\n                f\"A resolution of greater than 360 was \"\n                f\"provided, but `data` has a geographic CRS \"\n                f\"in {crs_units} units. Did you accidentally \"\n                f\"provide a resolution in projected \"\n                f\"(i.e. metre) units?\",\n            )\n            raise ValueError(err_msg)\n        if buffer is None:\n            buffer = 0.12\n    else:\n        if resolution is None:\n            resolution = 5000\n        elif resolution &lt; 1:\n            err_msg = (\n                f\"A resolution of less than 1 was provided, \"\n                f\"but `data` has a projected CRS in \"\n                f\"{crs_units} units. Did you accidentally \"\n                f\"provide a resolution in geographic \"\n                f\"(degree) units?\",\n            )\n            raise ValueError(err_msg)\n        if buffer is None:\n            buffer = 12000\n\n    # Raise error if resolution is less than dataset resolution\n    dataset_res = gbox.resolution.x\n    if resolution &lt; dataset_res:\n        err_msg = (\n            f\"The resolution of the low-resolution tide \"\n            f\"modelling grid ({resolution:.2f}) is less \"\n            f\"than `data`'s pixel resolution ({dataset_res:.2f}). \"\n            f\"This can cause extremely slow tide modelling \"\n            f\"performance. Please select provide a resolution \"\n            f\"greater than {dataset_res:.2f} using \"\n            f\"`pixel_tides`'s 'resolution' parameter.\",\n        )\n        raise ValueError(err_msg)\n\n    # Create a new reduced resolution tide modelling grid after\n    # first buffering the grid\n    print(f\"Creating reduced resolution {resolution} x {resolution} {crs_units} tide modelling array\")\n    buffered_geobox = gbox.buffered(buffer)\n    rescaled_geobox = GeoBox.from_bbox(bbox=buffered_geobox.boundingbox, resolution=resolution)\n    rescaled_ds = odc.geo.xr.xr_zeros(rescaled_geobox)\n\n    # Flatten grid to 1D, then add time dimension\n    flattened_ds = rescaled_ds.stack(z=(x_dim, y_dim))\n    flattened_ds = flattened_ds.expand_dims(dim={\"time\": time_coords})\n\n    # Model tides in parallel, returning a pandas.DataFrame\n    tide_df = model_tides(\n        x=flattened_ds[x_dim],\n        y=flattened_ds[y_dim],\n        time=flattened_ds.time,\n        crs=f\"EPSG:{gbox.crs.epsg}\",\n        model=model,\n        directory=directory,\n        **model_tides_kwargs,\n    )\n\n    # Convert our pandas.DataFrame tide modelling outputs to xarray\n    tides_lowres = (\n        # Rename x and y dataframe indexes to match x and y xarray dims\n        tide_df.rename_axis([\"time\", x_dim, y_dim])\n        # Add tide model column to dataframe indexes so we can convert\n        # our dataframe to a multidimensional xarray\n        .set_index(\"tide_model\", append=True)\n        # Convert to xarray and select our tide modelling xr.DataArray\n        .to_xarray()\n        .tide_height\n        # Re-index and transpose into our input coordinates and dim order\n        .reindex_like(rescaled_ds)\n        .transpose(\"tide_model\", \"time\", y_dim, x_dim)\n    )\n\n    # Optionally calculate and return quantiles rather than raw data.\n    # Set dtype to dtype of the input data as quantile always returns\n    # float64 (memory intensive)\n    if calculate_quantiles is not None:\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            print(\"Computing tide quantiles\")\n            tides_lowres = tides_lowres.quantile(q=calculate_quantiles, dim=\"time\").astype(tides_lowres.dtype)\n\n    # If only one tidal model exists, squeeze out \"tide_model\" dim\n    if len(tides_lowres.tide_model) == 1:\n        tides_lowres = tides_lowres.squeeze(\"tide_model\")\n\n    # Ensure CRS is present before we apply any resampling\n    tides_lowres = tides_lowres.odc.assign_crs(gbox.crs)\n\n    # Reproject into original high resolution grid\n    if resample:\n        print(\"Reprojecting tides into original resolution\")\n        return _pixel_tides_resample(\n            tides_lowres,\n            gbox,\n            resample_method,\n            dask_chunks,\n            dask_compute,\n        )\n\n    print(\"Returning low resolution tide array\")\n    return tides_lowres\n</code></pre>"},{"location":"api/#eo_tides.eo.pixel_tides(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(resample)","title":"<code>resample</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(calculate_quantiles)","title":"<code>calculate_quantiles</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(resolution)","title":"<code>resolution</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(buffer)","title":"<code>buffer</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(resample_method)","title":"<code>resample_method</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(dask_chunks)","title":"<code>dask_chunks</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(dask_compute)","title":"<code>dask_compute</code>","text":""},{"location":"api/#eo_tides.eo.pixel_tides(**model_tides_kwargs)","title":"<code>**model_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides","title":"tag_tides","text":"<pre><code>tag_tides(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    tidepost_lat=None,\n    tidepost_lon=None,\n    return_phases=False,\n    **model_tides_kwargs\n)\n</code></pre> <p>Model tide heights and phases for every dataset timestep using multiple ocean tide models.</p> <p>Tides are modelled using the centroid of the dataset by default; use <code>tidepost_lat</code> and <code>tidepost_lon</code> to specify a custom tidal modelling location.</p> <p>The function supports all tidal models supported by <code>pyTMD</code>, including:</p> <ul> <li>Empirical Ocean Tide model (EOT20)</li> <li>Finite Element Solution tide models (FES2022, FES2014, FES2012)</li> <li>TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)</li> <li>Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)</li> <li>Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)</li> <li>Technical University of Denmark tide models (DTU23)</li> </ul> <p>This function requires access to tide model data files. For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to define the tide modelling location. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, a new \"tide_model\" dimension will be added to the <code>xarray.DataArray</code> outputs. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>float</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>float</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>bool</code> <p>Whether to model and return tide phases in addition to tide heights. If True, outputs will be returned as an xr.Dataset containing both \"tide_height\" and \"tide_phase\" variables.</p> <code>False</code> <p>Optional parameters passed to the <code>eo_tides.model.model_tides</code> function. Important parameters include <code>cutoff</code> (used to extrapolate modelled tides away from the coast; defaults to <code>np.inf</code>), <code>crop</code> (whether to crop tide model constituent files on-the-fly to improve performance) etc.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>tides_da</code> <code>DataArray or Dataset</code> <p>If <code>return_phases=False</code>: a one-dimensional \"tide_height\" xr.DataArray. If <code>return_phases=True</code>: a one-dimensional xr.Dataset containing \"tide_height\" and \"tide_phase\" variables. Outputs will contain values for every timestep in <code>data</code>, or for every time in <code>times</code> if provided.</p> Source code in <code>eo_tides/eo.py</code> <pre><code>def tag_tides(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    tidepost_lat: float | None = None,\n    tidepost_lon: float | None = None,\n    return_phases: bool = False,\n    **model_tides_kwargs,\n) -&gt; xr.DataArray | xr.Dataset:\n    \"\"\"Model tide heights and phases for every dataset timestep using multiple ocean tide models.\n\n    Tides are modelled using the centroid of the dataset by\n    default; use `tidepost_lat` and `tidepost_lon` to specify\n    a custom tidal modelling location.\n\n    The function supports all tidal models supported by `pyTMD`,\n    including:\n\n    - Empirical Ocean Tide model (EOT20)\n    - Finite Element Solution tide models (FES2022, FES2014, FES2012)\n    - TOPEX/POSEIDON global tide models (TPXO10, TPXO9, TPXO8)\n    - Global Ocean Tide models (GOT5.6, GOT5.5, GOT4.10, GOT4.8, GOT4.7)\n    - Hamburg direct data Assimilation Methods for Tides models (HAMTIDE11)\n    - Technical University of Denmark tide models (DTU23)\n\n    This function requires access to tide model data files.\n    For tide model setup instructions, refer to the guide:\n    https://geoscienceaustralia.github.io/eo-tides/setup/\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to define the tide modelling location. If `data`\n        is an xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, a new \"tide_model\" dimension will be\n        added to the `xarray.DataArray` outputs. Defaults to \"EOT20\";\n        specify \"all\" to use all models available in `directory`.\n        For a full list of available and supported models, run\n        `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    tidepost_lat, tidepost_lon : float, optional\n        Optional coordinates used to model tides. The default is None,\n        which uses the centroid of the dataset as the tide modelling\n        location.\n    return_phases : bool, optional\n        Whether to model and return tide phases in addition to tide heights.\n        If True, outputs will be returned as an xr.Dataset containing both\n        \"tide_height\" and \"tide_phase\" variables.\n    **model_tides_kwargs :\n        Optional parameters passed to the `eo_tides.model.model_tides`\n        function. Important parameters include `cutoff` (used to\n        extrapolate modelled tides away from the coast; defaults to\n        `np.inf`), `crop` (whether to crop tide model constituent files\n        on-the-fly to improve performance) etc.\n\n    Returns\n    -------\n    tides_da : xr.DataArray or xr.Dataset\n        If `return_phases=False`: a one-dimensional \"tide_height\" xr.DataArray.\n        If `return_phases=True`: a one-dimensional xr.Dataset containing\n        \"tide_height\" and \"tide_phase\" variables.\n        Outputs will contain values for every timestep in `data`, or for\n        every time in `times` if provided.\n\n    \"\"\"\n    # Standardise data inputs, time and models\n    gbox, time_coords = _standardise_inputs(data, time)\n    model = [model] if isinstance(model, str) else model\n\n    # If custom tide posts are not provided, use dataset centroid\n    if tidepost_lat is None or tidepost_lon is None:\n        lon, lat = gbox.geographic_extent.centroid.coords[0]\n        print(f\"Setting tide modelling location from dataset centroid: {lon:.2f}, {lat:.2f}\")\n    else:\n        lon, lat = tidepost_lon, tidepost_lat\n        print(f\"Using tide modelling location: {lon:.2f}, {lat:.2f}\")\n\n    # Either model both tides and phases, or model only tides\n    if return_phases:\n        # Model tide phases and heights for each observation\n        tide_df = model_phases(\n            x=lon,\n            y=lat,\n            time=time_coords,\n            model=model,\n            directory=directory,\n            crs=\"EPSG:4326\",\n            return_tides=True,\n            **model_tides_kwargs,\n        )\n\n    else:\n        # Model tide heights for each observation\n        tide_df = model_tides(\n            x=lon,\n            y=lat,\n            time=time_coords,\n            model=model,\n            directory=directory,\n            crs=\"EPSG:4326\",\n            **model_tides_kwargs,\n        )\n\n    # If tides cannot be successfully modeled (e.g. if the centre of the\n    # xarray dataset is located is over land), raise an exception\n    if tide_df.tide_height.isna().all():\n        err_msg = (\n            f\"Tides could not be modelled for dataset centroid located \"\n            f\"at {tidepost_lon:.2f}, {tidepost_lat:.2f}. This can occur if \"\n            f\"this coordinate occurs over land. Please manually specify \"\n            f\"a tide modelling location located over water using the \"\n            f\"`tidepost_lat` and `tidepost_lon` parameters.\",\n        )\n        raise ValueError(err_msg)\n\n    # Convert to xarray format, squeezing to return an xr.DataArray if\n    # dataframe contains only one \"tide_height\" column\n    tides_da = tide_df.reset_index().set_index([\"time\", \"tide_model\"]).drop([\"x\", \"y\"], axis=1).squeeze().to_xarray()\n\n    # If only one tidal model exists, squeeze out \"tide_model\" dim\n    if len(tides_da.tide_model) == 1:\n        tides_da = tides_da.squeeze(\"tide_model\")\n\n    return tides_da\n</code></pre>"},{"location":"api/#eo_tides.eo.tag_tides(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(tidepost_lat)","title":"<code>tidepost_lat</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(tidepost_lon)","title":"<code>tidepost_lon</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(return_phases)","title":"<code>return_phases</code>","text":""},{"location":"api/#eo_tides.eo.tag_tides(**model_tides_kwargs)","title":"<code>**model_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.eo.tag_timeseries","title":"tag_timeseries","text":"<pre><code>tag_timeseries(\n    timeseries,\n    data,\n    time=None,\n    method=\"nearest\",\n    tolerance=\"1h\",\n    output_name=\"tide_height\",\n)\n</code></pre> <p>Match time series observations to the time steps of a dataset.</p> <p>This function aligns external time series data (for example, sea level or tide gauge measurements) to the timestamps of an <code>xarray</code> dataset (e.g. multi-dimensional satellite data). It is similar to <code>tag_tides</code>, but uses observed time series data instead of modelled tides.</p> <p>Parameters:</p> Name Type Description Default <code>DataArray or Series</code> <p>A one-dimensional time series of values (e.g. sea level measurements) with a time dimension or index.</p> required <code>Dataset or DataArray</code> <p>The multi-dimensional dataset (e.g. satellite data) to align the time series to. If this is an xarray object, it should include a \"time\" dimension. If <code>data</code> has no time dimension, you must provide times manually using the <code>time</code> argument.</p> required <code>DatetimeLike</code> <p>Custom times to align to, used only if <code>data</code> has no \"time\" dimension. Can be any format that <code>pandas.to_datetime()</code> can interpret, e.g. <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str</code> <p>How to match time points from <code>timeseries</code> to <code>data</code>. The default (\"nearest\") finds the closest time; \"ffill\" and \"bfill\" can be used to match using forward or backward filling instead. Use <code>tolerance</code> to set the maximum allowed time gap.</p> <code>'nearest'</code> <code>str</code> <p>The maximum time difference allowed when matching. Matches that are farther apart than this will return <code>NaN</code>.</p> <code>'1h'</code> <code>str</code> <p>Name used for the output <code>xr.DataArray</code>. Defaults to \"tide_height\" to match the name used by other <code>eo-tides</code> functions.</p> <code>'tide_height'</code> <p>Returns:</p> Type Description <code>DataArray</code> <p>The input time series data matched to the time steps of <code>data</code>. Each time step in <code>data</code> will have a corresponding value from <code>timeseries</code>, or <code>NaN</code> if no match was found.</p> Source code in <code>eo_tides/eo.py</code> <pre><code>def tag_timeseries(\n    timeseries: xr.DataArray | pd.Series,\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    method: str = \"nearest\",\n    tolerance: str = \"1h\",\n    output_name: str = \"tide_height\",\n):\n    \"\"\"Match time series observations to the time steps of a dataset.\n\n    This function aligns external time series data (for example, sea level\n    or tide gauge measurements) to the timestamps of an `xarray` dataset\n    (e.g. multi-dimensional satellite data). It is similar to `tag_tides`,\n    but uses observed time series data instead of modelled tides.\n\n    Parameters\n    ----------\n    timeseries : xr.DataArray or pd.Series\n        A one-dimensional time series of values (e.g. sea level measurements)\n        with a time dimension or index.\n    data : xarray.Dataset or xarray.DataArray\n        The multi-dimensional dataset (e.g. satellite data) to align the time\n        series to. If this is an xarray object, it should include a \"time\"\n        dimension. If `data` has no time dimension, you must\n        provide times manually using the `time` argument.\n    time : DatetimeLike, optional\n        Custom times to align to, used only if `data` has no \"time\" dimension.\n        Can be any format that `pandas.to_datetime()` can interpret, e.g.\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    method : str, optional\n        How to match time points from `timeseries` to `data`. The default\n        (\"nearest\") finds the closest time; \"ffill\" and \"bfill\" can be used to\n        match using forward or backward filling instead. Use `tolerance` to set\n        the maximum allowed time gap.\n    tolerance : str, optional\n        The maximum time difference allowed when matching. Matches that are\n        farther apart than this will return `NaN`.\n    output_name : str, optional\n        Name used for the output `xr.DataArray`. Defaults to \"tide_height\"\n        to match the name used by other `eo-tides` functions.\n\n    Returns\n    -------\n    xr.DataArray\n        The input time series data matched to the time steps of `data`.\n        Each time step in `data` will have a corresponding value from\n        `timeseries`, or `NaN` if no match was found.\n\n    \"\"\"\n    # Standardise data inputs, time\n    _, time_coords = _standardise_inputs(data, time)\n\n    # Convert to xarray if required\n    if isinstance(timeseries, pd.Series):\n        timeseries_da = timeseries.to_xarray()\n    elif isinstance(timeseries, xr.DataArray):\n        timeseries_da = timeseries\n    else:\n        err_msg = \"Only `pandas.Series` and `xarray.DataArray` inputs are supported for `timeseries`.\"\n        raise TypeError(err_msg)\n\n    # Squeeze out dimensions with only one unique value\n    timeseries_da = timeseries_da.squeeze(drop=True)\n\n    # Handle missing \"time\" dimension\n    if \"time\" not in timeseries_da.dims:\n        # If multiple dimensions with none named 'time', raise an error\n        if len(timeseries_da.dims) &gt; 1:\n            err_msg = (\n                \"`timeseries` includes multiple dimensions/indexes, but \"\n                \"could not automatically determine which represents time. \"\n                \"Ensure that `timeseries` contains at least one dimension/index \"\n                \"named 'time'.\"\n            )\n            raise ValueError(err_msg)\n\n        # If just one dimension, rename that to 'time'\n        old_dim = timeseries_da.dims[0]\n        timeseries_da = timeseries_da.rename({old_dim: \"time\"})\n\n    # Verify that the time dimension contains datetime values\n    if not np.issubdtype(timeseries_da.get_index(\"time\").dtype, np.datetime64):\n        err_msg = (\n            \"The `time` index in `timeseries` is not a datetime type. Please \"\n            \"provide data with a datetime-based time index (e.g. using \"\n            \"`pd.to_datetime()`).\"\n        )\n        raise ValueError(err_msg)\n\n    # Extract times to match time dimension of `satellite_ds` and rename\n    timeseries_aligned_da = timeseries_da.reindex(time=time_coords, method=method, tolerance=tolerance).rename(\n        output_name\n    )\n\n    # Raise warning if no valid data is returned\n    if timeseries_aligned_da.isnull().all():\n        warning_msg = (\n            \"The output array contains no valid values (i.e. all NaN). \"\n            \"Ensure that `timeseries` covers the same time period as \"\n            \"`data`, or provide a more relaxed `tolerance`.\"\n        )\n        warnings.warn(warning_msg, stacklevel=2)\n\n    return timeseries_aligned_da\n</code></pre>"},{"location":"api/#eo_tides.eo.tag_timeseries(timeseries)","title":"<code>timeseries</code>","text":""},{"location":"api/#eo_tides.eo.tag_timeseries(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.eo.tag_timeseries(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.eo.tag_timeseries(method)","title":"<code>method</code>","text":""},{"location":"api/#eo_tides.eo.tag_timeseries(tolerance)","title":"<code>tolerance</code>","text":""},{"location":"api/#eo_tides.eo.tag_timeseries(output_name)","title":"<code>output_name</code>","text":""},{"location":"api/#eo_tides.stats","title":"eo_tides.stats","text":"<p>Tools for analysing local tide dynamics and satellite biases.</p> <p>This module provides functions to assess how well satellite EO data captures real-world tides, and reveals potential tide biases in satellite EO data coverage.</p> <p>Functions:</p> Name Description <code>pixel_stats</code> <p>Generate tide statistics and satellite tide bias metrics for every dataset pixel.</p> <code>tide_aliasing</code> <p>Calculate aliasing periods for tidal constituents given satellite revisit intervals.</p> <code>tide_stats</code> <p>Generate tide statistics and satellite tide bias metrics for every dataset timestep.</p>"},{"location":"api/#eo_tides.stats.pixel_stats","title":"pixel_stats","text":"<pre><code>pixel_stats(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    resample=True,\n    modelled_freq=\"3h\",\n    min_max_q=(0.0, 1.0),\n    resample_method=\"bilinear\",\n    dask_chunks=None,\n    dask_compute=True,\n    extrapolate=True,\n    cutoff=10,\n    **pixel_tides_kwargs\n)\n</code></pre> <p>Generate tide statistics and satellite tide bias metrics for every dataset pixel.</p> <p>Takes a multi-dimensional dataset and generate pixel-level tide statistics and satellite-observed tide bias metrics, calculated based on every timestep in the satellite data and modelled into the spatial extent of the imagery.</p> <p>By comparing the subset of tides observed by satellites against the full astronomical tidal range, we can evaluate whether the tides observed by satellites are biased (e.g. fail to observe either the highest or lowest tides) due to tide aliasing interactions with sun-synchronous satellite overpasses.</p> <p>Compared to <code>tide_stats</code>, this function models tide metrics spatially to produce a two-dimensional output for each statistic.</p> <p>For more information about the tidal statistics computed by this function, refer to Figure 8 in Bishop-Taylor et al. 2018: https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to calculate spatial tide statistics. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, a new \"tide_model\" dimension will be added to the <code>xarray.Dataset</code> output. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>bool</code> <p>Whether to resample tide statistics back into <code>data</code>'s original higher resolution grid. Set this to <code>False</code> if you want to return lower-resolution tide statistics (which can be useful for assessing tide biases across large spatial extents).</p> <code>True</code> <code>str</code> <p>An optional string giving the frequency at which to model tides when computing the full modelled tidal range. Defaults to '3h', which computes a tide height for every three hours across the temporal extent of <code>data</code>.</p> <code>'3h'</code> <code>tuple</code> <p>Quantiles used to calculate max and min observed and modelled astronomical tides. By default <code>(0.0, 1.0)</code> which is equivalent to minimum and maximum; for a softer threshold that is more robust to outliers use e.g. <code>(0.1, 0.9)</code>.</p> <code>(0.0, 1.0)</code> <code>str</code> <p>If resampling is requested (see <code>resample</code> above), use this resampling method when resampling from low resolution to high resolution pixels. Defaults to \"bilinear\"; valid options include \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.</p> <code>'bilinear'</code> <code>tuple of float</code> <p>Can be used to configure custom Dask chunking for the final resampling step. By default, chunks will be automatically set to match y/x chunks from <code>data</code> if they exist; otherwise chunks will be chosen to cover the entire y/x extent of the dataset. For custom chunks, provide a tuple in the form <code>(y, x)</code>, e.g. <code>(2048, 2048)</code>.</p> <code>None</code> <code>bool</code> <p>Whether to compute results of the resampling step using Dask. If False, <code>stats_ds</code> will be returned as a Dask-enabled array.</p> <code>True</code> <code>bool</code> <p>Whether to extrapolate tides into x and y coordinates outside of the valid tide modelling domain using nearest-neighbor. Defaults to True.</p> <code>True</code> <code>float</code> <p>Extrapolation cutoff in kilometers. To avoid producing tide statistics too far inland, the default is 10 km.</p> <code>10</code> <p>Optional parameters passed to the <code>eo_tides.eo.pixel_tides</code> function.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>stats_ds</code> <code>Dataset</code> <p>An <code>xarray.Dataset</code> containing the following statistics as two-dimensional data variables:</p> <ul> <li><code>mot</code>: mean tide height observed by the satellite (metres)</li> <li><code>mat</code>: mean modelled astronomical tide height (metres)</li> <li><code>lot</code>: minimum tide height observed by the satellite (metres)</li> <li><code>lat</code>: minimum tide height from modelled astronomical tidal range (metres)</li> <li><code>hot</code>: maximum tide height observed by the satellite (metres)</li> <li><code>hat</code>: maximum tide height from modelled astronomical tidal range (metres)</li> <li><code>otr</code>: tidal range observed by the satellite (metres)</li> <li><code>tr</code>: modelled astronomical tide range (metres)</li> <li><code>spread</code>: proportion of the full modelled tidal range observed by the satellite</li> <li><code>offset_low</code>: proportion of the lowest tides never observed by the satellite</li> <li><code>offset_high</code>: proportion of the highest tides never observed by the satellite</li> </ul> Source code in <code>eo_tides/stats.py</code> <pre><code>def pixel_stats(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str | list[str] = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    resample: bool = True,\n    modelled_freq: str = \"3h\",\n    min_max_q: tuple[float, float] = (0.0, 1.0),\n    resample_method: str = \"bilinear\",\n    dask_chunks: tuple[float, float] | None = None,\n    dask_compute: bool = True,\n    extrapolate: bool = True,\n    cutoff: float = 10,\n    **pixel_tides_kwargs,\n) -&gt; xr.Dataset:\n    \"\"\"Generate tide statistics and satellite tide bias metrics for every dataset pixel.\n\n    Takes a multi-dimensional dataset and generate pixel-level\n    tide statistics and satellite-observed tide bias metrics,\n    calculated based on every timestep in the satellite data and\n    modelled into the spatial extent of the imagery.\n\n    By comparing the subset of tides observed by satellites\n    against the full astronomical tidal range, we can evaluate\n    whether the tides observed by satellites are biased\n    (e.g. fail to observe either the highest or lowest tides)\n    due to tide aliasing interactions with sun-synchronous satellite\n    overpasses.\n\n    Compared to `tide_stats`, this function models tide metrics\n    spatially to produce a two-dimensional output for each statistic.\n\n    For more information about the tidal statistics computed by this\n    function, refer to Figure 8 in Bishop-Taylor et al. 2018:\n    &lt;https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8&gt;\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to calculate spatial tide statistics. If `data`\n        is an xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, a new \"tide_model\" dimension will be\n        added to the `xarray.Dataset` output. Defaults to \"EOT20\";\n        specify \"all\" to use all models available in `directory`.\n        For a full list of available and supported models, run\n        `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    resample : bool, optional\n        Whether to resample tide statistics back into `data`'s original\n        higher resolution grid. Set this to `False` if you want to return\n        lower-resolution tide statistics (which can be useful for\n        assessing tide biases across large spatial extents).\n    modelled_freq : str, optional\n        An optional string giving the frequency at which to model tides\n        when computing the full modelled tidal range. Defaults to '3h',\n        which computes a tide height for every three hours across the\n        temporal extent of `data`.\n    min_max_q : tuple, optional\n        Quantiles used to calculate max and min observed and modelled\n        astronomical tides. By default `(0.0, 1.0)` which is equivalent\n        to minimum and maximum; for a softer threshold that is more\n        robust to outliers use e.g. `(0.1, 0.9)`.\n    resample_method : str, optional\n        If resampling is requested (see `resample` above), use this\n        resampling method when resampling from low resolution to high\n        resolution pixels. Defaults to \"bilinear\"; valid options include\n        \"nearest\", \"cubic\", \"min\", \"max\", \"average\" etc.\n    dask_chunks : tuple of float, optional\n        Can be used to configure custom Dask chunking for the final\n        resampling step. By default, chunks will be automatically set\n        to match y/x chunks from `data` if they exist; otherwise chunks\n        will be chosen to cover the entire y/x extent of the dataset.\n        For custom chunks, provide a tuple in the form `(y, x)`, e.g.\n        `(2048, 2048)`.\n    dask_compute : bool, optional\n        Whether to compute results of the resampling step using Dask.\n        If False, `stats_ds` will be returned as a Dask-enabled array.\n    extrapolate : bool, optional\n        Whether to extrapolate tides into x and y coordinates outside of\n        the valid tide modelling domain using nearest-neighbor. Defaults\n        to True.\n    cutoff : float, optional\n        Extrapolation cutoff in kilometers. To avoid producing tide\n        statistics too far inland, the default is 10 km.\n    **pixel_tides_kwargs :\n        Optional parameters passed to the `eo_tides.eo.pixel_tides`\n        function.\n\n    Returns\n    -------\n    stats_ds : xarray.Dataset\n        An `xarray.Dataset` containing the following statistics as two-dimensional data variables:\n\n        - `mot`: mean tide height observed by the satellite (metres)\n        - `mat`: mean modelled astronomical tide height (metres)\n        - `lot`: minimum tide height observed by the satellite (metres)\n        - `lat`: minimum tide height from modelled astronomical tidal range (metres)\n        - `hot`: maximum tide height observed by the satellite (metres)\n        - `hat`: maximum tide height from modelled astronomical tidal range (metres)\n        - `otr`: tidal range observed by the satellite (metres)\n        - `tr`: modelled astronomical tide range (metres)\n        - `spread`: proportion of the full modelled tidal range observed by the satellite\n        - `offset_low`: proportion of the lowest tides never observed by the satellite\n        - `offset_high`: proportion of the highest tides never observed by the satellite\n\n    \"\"\"\n    # Standardise data inputs, time and models\n    gbox, obs_times = _standardise_inputs(data, time)\n    dask_chunks = _resample_chunks(data, dask_chunks)\n    model = [model] if isinstance(model, str) else model\n\n    # Generate range of times covering entire period of satellite record\n    assert obs_times is not None  # noqa: S101\n    all_times = pd.date_range(\n        start=obs_times.min().item(),\n        end=obs_times.max().item(),\n        freq=modelled_freq,\n    )\n\n    # Model tides for observed timesteps\n    obs_tides_da = pixel_tides(\n        gbox,\n        time=obs_times,\n        model=model,\n        directory=directory,\n        resample=False,\n        extrapolate=extrapolate,\n        cutoff=cutoff,\n        **pixel_tides_kwargs,\n    )\n\n    # Model tides for all modelled timesteps\n    all_tides_da = pixel_tides(\n        gbox,\n        time=all_times,\n        model=model,\n        directory=directory,\n        resample=False,\n        extrapolate=extrapolate,\n        cutoff=cutoff,\n        **pixel_tides_kwargs,\n    )\n\n    # Calculate statistics\n    stats_lowres = _tide_statistics(obs_tides_da, all_tides_da, min_max_q=min_max_q)\n\n    # Assign CRS and geobox to allow reprojection\n    stats_lowres = stats_lowres.odc.assign_crs(crs=gbox.crs)\n\n    # Reproject statistics into original high resolution grid\n    if resample:\n        print(\"Reprojecting statistics into original resolution\")\n        return _pixel_tides_resample(\n            stats_lowres,\n            gbox,\n            resample_method,\n            dask_chunks,\n            dask_compute,\n            None,\n        )\n\n    print(\"Returning low resolution statistics array\")\n    return stats_lowres\n</code></pre>"},{"location":"api/#eo_tides.stats.pixel_stats(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(resample)","title":"<code>resample</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(modelled_freq)","title":"<code>modelled_freq</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(min_max_q)","title":"<code>min_max_q</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(resample_method)","title":"<code>resample_method</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(dask_chunks)","title":"<code>dask_chunks</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(dask_compute)","title":"<code>dask_compute</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(extrapolate)","title":"<code>extrapolate</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(cutoff)","title":"<code>cutoff</code>","text":""},{"location":"api/#eo_tides.stats.pixel_stats(**pixel_tides_kwargs)","title":"<code>**pixel_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.stats.tide_aliasing","title":"tide_aliasing","text":"<pre><code>tide_aliasing(\n    satellites,\n    constituents=None,\n    units=\"days\",\n    max_inf=None,\n    style=True,\n)\n</code></pre> <p>Calculate aliasing periods for tidal constituents given satellite revisit intervals.</p> <p>This function uses <code>pyTMD.arguments.aliasing_period</code> to calculate the aliasing periods between satellite overpass periods and the natural cycles of tidal constituents. The aliasing period describes how long it would take for a satellite to sample the entire tidal cycle for each constituent, based on the satellite's observation frequency.</p> <p>Short aliasing periods mean the satellite will observe the full range of tidal variation relatively quickly, reducing the risk of tide-related bias. Long aliasing periods indicate that it will take much longer to sample all tidal conditions, increasing the risk that satellite analyses may misrepresent tidal dynamics.</p> <p>Revisit periods are approximate and based on nominal repeat cycles at the equator. Actual observation frequency may vary due to latitude, cloud cover, sensor availability, and acquisition planning. Custom revisit intervals can be defined by passing a dictionary to <code>satellites</code>, e.g. <code>satellites={\"custom-sat\": 5}</code>.</p> <p>For more information, refer to https://pytmd.readthedocs.io/en/latest/api_reference/arguments.html#pyTMD.arguments.aliasing_period</p> <p>Parameters:</p> Name Type Description Default <code>list of str or dict</code> <p>List of satellite names to analyse, or a custom dictionary with satellite names as keys and revisit frequency in days as values. Supported satellites include:</p> <ul> <li>Landsat (optical):<ul> <li>Two satellites combined: \"landsat\"</li> <li>Individual: \"landsat-5\", \"landsat-7\", \"landsat-8\", \"landsat-9\"</li> </ul> </li> <li>Sentinel-2 (optical):<ul> <li>Two satellites combined: \"sentinel-2\"</li> <li>Individual: \"sentinel-2a\", \"sentinel-2b\", \"sentinel-2c\"</li> </ul> </li> <li>Sentinel-1 (C-band SAR):<ul> <li>Two satellites combined: \"sentinel-1\"</li> <li>Individual: \"sentinel-1a\", \"sentinel-1b\", \"sentinel-1c\"</li> </ul> </li> <li>Sentinel-3:<ul> <li>OLCI (optical): \"sentinel-3a-olci\", \"sentinel-3b-olci\", \"sentinel-3c-olci\"</li> <li>SLSTR (thermal): \"sentinel-3a-slstr\", \"sentinel-3b-slstr, \"sentinel-3c-slstr\"</li> <li>SRAL (altimetry): \"sentinel-3a-sral\", \"sentinel-3b-sral, \"sentinel-3c-sral\"</li> </ul> </li> <li>SWOT (KaRIn swath altimetry): \"swot\"</li> <li>NISAR (L- and S-band SAR): \"nisar\"</li> </ul> required <code>list of str or None</code> <p>List of tidal constituents to include. If None, use a list of major constituents. Constituent names should be lowercase (e.g., \"m2\", \"k1\").</p> <code>None</code> <code>str</code> <p>Output time units for the aliasing periods. Must be one of: \"years\", \"days\", \"hours\", or \"minutes\". Default is \"days\".</p> <code>'days'</code> <code>float</code> <p>Maximum aliasing period to display in seconds. Values exceeding this threshold are replaced with <code>np.inf</code>. Defaults to equivalent of 10 years if no value is provided.</p> <code>None</code> <code>bool</code> <p>If True, returns a styled <code>pandas.DataFrame</code>. If False, returns a raw DataFrame. Default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A table showing aliasing periods for each tidal constituent across the given satellites. The result is styled with a color gradient if <code>style=True</code>, or returned as a plain DataFrame.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; eo_tide_aliasing([\"sentinel-2\", \"landsat-8\"])\n&gt;&gt;&gt; eo_tide_aliasing([\"swot\"], constituents=[\"m2\", \"k1\"], units=\"hours\", style=False)\n&gt;&gt;&gt; eo_tide_aliasing({\"custom-sat\": 5})\n</code></pre> Source code in <code>eo_tides/stats.py</code> <pre><code>def tide_aliasing(\n    satellites: list[str] | dict[str, float],\n    constituents: list[str] | None = None,\n    units: str = \"days\",\n    max_inf: float | None = None,\n    style: bool = True,\n):\n    \"\"\"Calculate aliasing periods for tidal constituents given satellite revisit intervals.\n\n    This function uses `pyTMD.arguments.aliasing_period` to calculate the\n    aliasing periods between satellite overpass periods and the natural\n    cycles of tidal constituents. The aliasing period describes how long\n    it would take for a satellite to sample the entire tidal cycle for\n    each constituent, based on the satellite's observation frequency.\n\n    Short aliasing periods mean the satellite will observe the full range\n    of tidal variation relatively quickly, reducing the risk of tide-related\n    bias. Long aliasing periods indicate that it will take much longer to\n    sample all tidal conditions, increasing the risk that satellite analyses\n    may misrepresent tidal dynamics.\n\n    Revisit periods are approximate and based on nominal repeat cycles at the equator.\n    Actual observation frequency may vary due to latitude, cloud cover, sensor\n    availability, and acquisition planning. Custom revisit intervals can be\n    defined by passing a dictionary to `satellites`, e.g. `satellites={\"custom-sat\": 5}`.\n\n    For more information, refer to https://pytmd.readthedocs.io/en/latest/api_reference/arguments.html#pyTMD.arguments.aliasing_period\n\n    Parameters\n    ----------\n    satellites : list of str or dict\n        List of satellite names to analyse, or a custom dictionary with\n        satellite names as keys and revisit frequency in days as values.\n        Supported satellites include:\n\n        - Landsat (optical):\n            - Two satellites combined: \"landsat\"\n            - Individual: \"landsat-5\", \"landsat-7\", \"landsat-8\", \"landsat-9\"\n        - Sentinel-2 (optical):\n            - Two satellites combined: \"sentinel-2\"\n            - Individual: \"sentinel-2a\", \"sentinel-2b\", \"sentinel-2c\"\n        - Sentinel-1 (C-band SAR):\n            - Two satellites combined: \"sentinel-1\"\n            - Individual: \"sentinel-1a\", \"sentinel-1b\", \"sentinel-1c\"\n        - Sentinel-3:\n            - OLCI (optical): \"sentinel-3a-olci\", \"sentinel-3b-olci\", \"sentinel-3c-olci\"\n            - SLSTR (thermal): \"sentinel-3a-slstr\", \"sentinel-3b-slstr, \"sentinel-3c-slstr\"\n            - SRAL (altimetry): \"sentinel-3a-sral\", \"sentinel-3b-sral, \"sentinel-3c-sral\"\n        - SWOT (KaRIn swath altimetry): \"swot\"\n        - NISAR (L- and S-band SAR): \"nisar\"\n    constituents : list of str or None, optional\n        List of tidal constituents to include. If None, use a list of major\n        constituents. Constituent names should be lowercase (e.g., \"m2\", \"k1\").\n    units : str, optional\n        Output time units for the aliasing periods. Must be one of:\n        \"years\", \"days\", \"hours\", or \"minutes\". Default is \"days\".\n    max_inf : float, optional\n        Maximum aliasing period to display in seconds. Values exceeding\n        this threshold are replaced with `np.inf`. Defaults to equivalent of 10\n        years if no value is provided.\n    style : bool, optional\n        If True, returns a styled `pandas.DataFrame`. If False, returns a raw\n        DataFrame. Default is True.\n\n    Returns\n    -------\n    pandas.DataFrame\n        A table showing aliasing periods for each tidal constituent across the given satellites.\n        The result is styled with a color gradient if `style=True`, or returned as a plain DataFrame.\n\n    Examples\n    --------\n    &gt;&gt;&gt; eo_tide_aliasing([\"sentinel-2\", \"landsat-8\"])\n    &gt;&gt;&gt; eo_tide_aliasing([\"swot\"], constituents=[\"m2\", \"k1\"], units=\"hours\", style=False)\n    &gt;&gt;&gt; eo_tide_aliasing({\"custom-sat\": 5})\n\n    \"\"\"\n    # If satellites is a dict\n    if isinstance(satellites, dict):\n        revisit_dict = satellites | REVISIT_DICT\n        satellites = list(satellites.keys())\n    else:\n        revisit_dict = REVISIT_DICT\n\n    # Validate satellite names\n    invalid_sats = set(satellites) - set(revisit_dict)\n    if invalid_sats:\n        valid = \", \".join(sorted(revisit_dict))\n        error_msg = f\"Unknown satellite(s): {', '.join(invalid_sats)}. Must be one of: {valid}\"\n        raise ValueError(error_msg)\n\n    # Time unit factors\n    unit_factors = {\n        \"seconds\": 1,\n        \"minutes\": 60,\n        \"hours\": 3600,\n        \"days\": 86400,\n        \"years\": 31556952,\n    }\n\n    # Use default list of constituents if none provided\n    if constituents is None:\n        constituents = list(MAJOR_CONSTITUENTS.keys())\n\n    # Extract frequency in radians per second for each constituent,\n    # and convert to period in seconds\n    omega = np.array([frequency(c)[0] for c in constituents])\n    period = 2 * np.pi / omega\n\n    # Compute aliasing period for each satellite\n    with warnings.catch_warnings():\n        warnings.filterwarnings(\n            \"ignore\",\n            category=RuntimeWarning,\n            message=\"divide by zero encountered in divide\",\n        )\n        aliasing_periods = {}\n        for sat in satellites:\n            revisit = revisit_dict[sat]\n            print(f\"Using {revisit} day revisit for {sat}\")\n            aliasing_periods[(\"aliasing_period\", sat)] = aliasing_period(\n                constituents,\n                unit_factors[\"days\"] * revisit,\n            )\n\n    # Combine into a dataframe\n    alias_df = pd.DataFrame(\n        index=pd.Index(constituents, name=\"constituents\"),\n        data={\n            (\"period\", \"\"): period,\n            **aliasing_periods,\n        },\n    )\n\n    # Raise error if unit is not supported\n    if units not in unit_factors:\n        error_msg = f\"Unit not supported: {units}; must be one of 'years', 'days', 'hours', 'minutes'\"\n        raise ValueError(error_msg)\n\n    # Set max value to infinity. If no max is provided, use 10 years\n    if max_inf is None:\n        max_inf = unit_factors[\"years\"] * 10\n    alias_df[alias_df &gt; max_inf] = np.inf\n\n    # Rescale to desired output time units\n    precision = 3 if units != \"years\" else 4\n    alias_df = (alias_df / unit_factors[units]).round(precision)\n\n    # Add constituent name column\n    alias_df.insert(0, column=\"name\", value=[MAJOR_CONSTITUENTS.get(c) for c in constituents])\n\n    # Style and return\n    df_subset = alias_df.loc[:, \"aliasing_period\"]\n    max_col = np.nanquantile(df_subset[np.isfinite(df_subset)].values, 0.9)\n\n    if style:\n        return alias_df.style.background_gradient(\n            axis=None,\n            vmin=0,\n            vmax=max_col * 1.5,\n            cmap=\"YlOrRd\",\n        ).format(precision=precision)\n    return alias_df\n</code></pre>"},{"location":"api/#eo_tides.stats.tide_aliasing(satellites)","title":"<code>satellites</code>","text":""},{"location":"api/#eo_tides.stats.tide_aliasing(constituents)","title":"<code>constituents</code>","text":""},{"location":"api/#eo_tides.stats.tide_aliasing(units)","title":"<code>units</code>","text":""},{"location":"api/#eo_tides.stats.tide_aliasing(max_inf)","title":"<code>max_inf</code>","text":""},{"location":"api/#eo_tides.stats.tide_aliasing(style)","title":"<code>style</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats","title":"tide_stats","text":"<pre><code>tide_stats(\n    data,\n    time=None,\n    model=\"EOT20\",\n    directory=None,\n    tidepost_lat=None,\n    tidepost_lon=None,\n    plain_english=True,\n    plot=True,\n    plot_var=None,\n    point_col=None,\n    modelled_freq=\"3h\",\n    min_max_q=(0.0, 1.0),\n    round_stats=3,\n    **tag_tides_kwargs\n)\n</code></pre> <p>Generate tide statistics and satellite tide bias metrics for every dataset timestep.</p> <p>Takes a multi-dimensional dataset and generate tide statistics and satellite-observed tide bias metrics, calculated based on every timestep in the satellite data and the geographic centroid of the imagery.</p> <p>By comparing the subset of tides observed by satellites against the full astronomical tidal range, we can evaluate whether the tides observed by satellites are biased (e.g. fail to observe either the highest or lowest tides) due to tide aliasing interactions with sun-synchronous satellite overpasses.</p> <p>For more information about the tidal statistics computed by this function, refer to Figure 8 in Bishop-Taylor et al. 2018: https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8</p> <p>Parameters:</p> Name Type Description Default <code>Dataset or DataArray or GeoBox</code> <p>A multi-dimensional dataset or GeoBox pixel grid that will be used to calculate tide statistics. If <code>data</code> is an xarray object, it should include a \"time\" dimension. If no \"time\" dimension exists or if <code>data</code> is a GeoBox, then times must be passed using the <code>time</code> parameter.</p> required <code>DatetimeLike</code> <p>By default, tides will be modelled using times from the \"time\" dimension of <code>data</code>. Alternatively, this param can be used to provide a custom set of times. Accepts any format that can be converted by <code>pandas.to_datetime()</code>. For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code></p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to use to model tides. If a list is provided, the resulting statistics will be returned as a <code>pandas.Dataframe</code>; otherwise a <code>pandas.Series</code> will be returned. Defaults to \"EOT20\"; specify \"all\" to use all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'EOT20'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>float or int</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>float or int</code> <p>Optional coordinates used to model tides. The default is None, which uses the centroid of the dataset as the tide modelling location.</p> <code>None</code> <code>bool</code> <p>An optional boolean indicating whether to print a plain english version of the tidal statistics to the screen. Defaults to True; only supported when a single tide model is passed to <code>model</code>.</p> <code>True</code> <code>bool</code> <p>An optional boolean indicating whether to plot how satellite- observed tide heights compare against the full tidal range. Defaults to True; only supported when a single tide model is passed to <code>model</code>.</p> <code>True</code> <code>str</code> <p>Optional name of a coordinate, dimension or variable in the array that will be used to plot observations with unique symbols. Defaults to None, which will plot all observations as circles.</p> <code>None</code> <code>str</code> <p>Colour used to plot points on the graph. Defaults to None which will automatically select colours.</p> <code>None</code> <code>str</code> <p>An optional string giving the frequency at which to model tides when computing the full modelled tidal range. Defaults to '3h', which computes a tide height for every three hours across the temporal extent of <code>data</code>.</p> <code>'3h'</code> <code>tuple</code> <p>Quantiles used to calculate max and min observed and modelled astronomical tides. By default <code>(0.0, 1.0)</code> which is equivalent to minimum and maximum; to use a softer threshold that is more robust to outliers, use e.g. <code>(0.1, 0.9)</code>.</p> <code>(0.0, 1.0)</code> <code>int</code> <p>The number of decimal places used to round the output statistics. Defaults to 3.</p> <code>3</code> <p>Optional parameters passed to the <code>eo_tides.eo.tag_tides</code> function that is used to model tides for each observed and modelled timestep.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>stats_df</code> <code>Series or Dataframe</code> <p>A pandas object containing the following statistics:</p> <ul> <li><code>y</code>: latitude used for modelling tide heights</li> <li><code>x</code>: longitude used for modelling tide heights</li> <li><code>mot</code>: mean tide height observed by the satellite (metres)</li> <li><code>mat</code>: mean modelled astronomical tide height (metres)</li> <li><code>lot</code>: minimum tide height observed by the satellite (metres)</li> <li><code>lat</code>: minimum tide height from modelled astronomical tidal range (metres)</li> <li><code>hot</code>: maximum tide height observed by the satellite (metres)</li> <li><code>hat</code>: maximum tide height from modelled astronomical tidal range (metres)</li> <li><code>otr</code>: tidal range observed by the satellite (metres)</li> <li><code>tr</code>: modelled astronomical tide range (metres)</li> <li><code>spread</code>: proportion of the full modelled tidal range observed by the satellite</li> <li><code>offset_low</code>: proportion of the lowest tides never observed by the satellite</li> <li><code>offset_high</code>: proportion of the highest tides never observed by the satellite</li> </ul> Source code in <code>eo_tides/stats.py</code> <pre><code>def tide_stats(\n    data: xr.Dataset | xr.DataArray | GeoBox,\n    time: DatetimeLike | None = None,\n    model: str = \"EOT20\",\n    directory: str | os.PathLike | None = None,\n    tidepost_lat: float | None = None,\n    tidepost_lon: float | None = None,\n    plain_english: bool = True,\n    plot: bool = True,\n    plot_var: str | None = None,\n    point_col: str | None = None,\n    modelled_freq: str = \"3h\",\n    min_max_q: tuple = (0.0, 1.0),\n    round_stats: int = 3,\n    **tag_tides_kwargs,\n) -&gt; pd.Series:\n    \"\"\"Generate tide statistics and satellite tide bias metrics for every dataset timestep.\n\n    Takes a multi-dimensional dataset and generate tide statistics\n    and satellite-observed tide bias metrics, calculated based on\n    every timestep in the satellite data and the geographic centroid\n    of the imagery.\n\n    By comparing the subset of tides observed by satellites\n    against the full astronomical tidal range, we can evaluate\n    whether the tides observed by satellites are biased\n    (e.g. fail to observe either the highest or lowest tides) due\n    to tide aliasing interactions with sun-synchronous satellite\n    overpasses.\n\n    For more information about the tidal statistics computed by this\n    function, refer to Figure 8 in Bishop-Taylor et al. 2018:\n    https://www.sciencedirect.com/science/article/pii/S0272771418308783#fig8\n\n    Parameters\n    ----------\n    data : xarray.Dataset or xarray.DataArray or odc.geo.geobox.GeoBox\n        A multi-dimensional dataset or GeoBox pixel grid that will\n        be used to calculate tide statistics. If `data` is an\n        xarray object, it should include a \"time\" dimension.\n        If no \"time\" dimension exists or if `data` is a GeoBox,\n        then times must be passed using the `time` parameter.\n    time : DatetimeLike, optional\n        By default, tides will be modelled using times from the\n        \"time\" dimension of `data`. Alternatively, this param can\n        be used to provide a custom set of times. Accepts any format\n        that can be converted by `pandas.to_datetime()`. For example:\n        `time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")`\n    model : str or list of str, optional\n        The tide model (or list of models) to use to model tides.\n        If a list is provided, the resulting statistics will be\n        returned as a `pandas.Dataframe`; otherwise a `pandas.Series`\n        will be returned. Defaults to \"EOT20\"; specify \"all\" to use\n        all models available in `directory`. For a full list of\n        available and supported models, run\n        `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    tidepost_lat, tidepost_lon : float or int, optional\n        Optional coordinates used to model tides. The default is None,\n        which uses the centroid of the dataset as the tide modelling\n        location.\n    plain_english : bool, optional\n        An optional boolean indicating whether to print a plain english\n        version of the tidal statistics to the screen. Defaults to True;\n        only supported when a single tide model is passed to `model`.\n    plot : bool, optional\n        An optional boolean indicating whether to plot how satellite-\n        observed tide heights compare against the full tidal range.\n        Defaults to True; only supported when a single tide model is\n        passed to `model`.\n    plot_var : str, optional\n        Optional name of a coordinate, dimension or variable in the array\n        that will be used to plot observations with unique symbols.\n        Defaults to None, which will plot all observations as circles.\n    point_col : str, optional\n        Colour used to plot points on the graph. Defaults to None which\n        will automatically select colours.\n    modelled_freq : str, optional\n        An optional string giving the frequency at which to model tides\n        when computing the full modelled tidal range. Defaults to '3h',\n        which computes a tide height for every three hours across the\n        temporal extent of `data`.\n    min_max_q : tuple, optional\n        Quantiles used to calculate max and min observed and modelled\n        astronomical tides. By default `(0.0, 1.0)` which is equivalent\n        to minimum and maximum; to use a softer threshold that is more\n        robust to outliers, use e.g. `(0.1, 0.9)`.\n    round_stats : int, optional\n        The number of decimal places used to round the output statistics.\n        Defaults to 3.\n    **tag_tides_kwargs :\n        Optional parameters passed to the `eo_tides.eo.tag_tides`\n        function that is used to model tides for each observed and\n        modelled timestep.\n\n    Returns\n    -------\n    stats_df : pandas.Series or pandas.Dataframe\n        A pandas object containing the following statistics:\n\n        - `y`: latitude used for modelling tide heights\n        - `x`: longitude used for modelling tide heights\n        - `mot`: mean tide height observed by the satellite (metres)\n        - `mat`: mean modelled astronomical tide height (metres)\n        - `lot`: minimum tide height observed by the satellite (metres)\n        - `lat`: minimum tide height from modelled astronomical tidal range (metres)\n        - `hot`: maximum tide height observed by the satellite (metres)\n        - `hat`: maximum tide height from modelled astronomical tidal range (metres)\n        - `otr`: tidal range observed by the satellite (metres)\n        - `tr`: modelled astronomical tide range (metres)\n        - `spread`: proportion of the full modelled tidal range observed by the satellite\n        - `offset_low`: proportion of the lowest tides never observed by the satellite\n        - `offset_high`: proportion of the highest tides never observed by the satellite\n\n    \"\"\"\n    # Standardise data inputs, time and models\n    gbox, obs_times = _standardise_inputs(data, time)\n\n    # Generate range of times covering entire period of satellite record\n    assert obs_times is not None  # noqa: S101\n    all_times = pd.date_range(\n        start=obs_times.min().item(),\n        end=obs_times.max().item(),\n        freq=modelled_freq,\n    )\n\n    # If custom tide modelling locations are not provided, use the\n    # dataset centroid\n    if not tidepost_lat or not tidepost_lon:\n        tidepost_lon, tidepost_lat = gbox.geographic_extent.centroid.coords[0]\n\n    # Model tides for observed timesteps\n    obs_tides_da = tag_tides(\n        gbox,\n        time=obs_times,\n        model=model,\n        directory=directory,\n        tidepost_lat=tidepost_lat,\n        tidepost_lon=tidepost_lon,\n        **tag_tides_kwargs,\n    )\n\n    # Model tides for all modelled timesteps\n    all_tides_da = tag_tides(\n        gbox,\n        time=all_times,\n        model=model,\n        directory=directory,\n        tidepost_lat=tidepost_lat,\n        tidepost_lon=tidepost_lon,\n        **tag_tides_kwargs,\n    )\n\n    # Calculate statistics\n    # # (cast ensures typing knows these are always DataArrays)\n    stats_ds = _tide_statistics(\n        cast(\"xr.DataArray\", obs_tides_da),\n        cast(\"xr.DataArray\", all_tides_da),\n        min_max_q=min_max_q,\n    )\n\n    # Convert to pandas and add tide post coordinates\n    stats_df = stats_ds.to_pandas().astype(\"float32\")\n    stats_df[\"x\"] = tidepost_lon\n    stats_df[\"y\"] = tidepost_lat\n\n    # Convert coordinates to index if dataframe\n    if isinstance(stats_df, pd.DataFrame):\n        stats_df = stats_df.set_index([\"x\", \"y\"], append=True)\n\n    # If a series, print and plot summaries\n    else:\n        if plain_english:\n            _stats_plain_english(\n                mot=stats_df.mot,\n                mat=stats_df.mat,\n                hot=stats_df.hot,\n                hat=stats_df.hat,\n                lot=stats_df.lot,\n                lat=stats_df.lat,\n                otr=stats_df.otr,\n                tr=stats_df.tr,\n                spread=stats_df.spread,\n                offset_low=stats_df.offset_low,\n                offset_high=stats_df.offset_high,\n            )\n\n        if plot:\n            _stats_figure(\n                all_tides_da=all_tides_da,\n                obs_tides_da=obs_tides_da,\n                hot=stats_df.hot,\n                hat=stats_df.hat,\n                lot=stats_df.lot,\n                lat=stats_df.lat,\n                spread=stats_df.spread,\n                offset_low=stats_df.offset_low,\n                offset_high=stats_df.offset_high,\n                plot_var=data[plot_var] if plot_var else None,\n                point_col=point_col,\n            )\n\n    # Return in Pandas format\n    return stats_df.round(round_stats)\n</code></pre>"},{"location":"api/#eo_tides.stats.tide_stats(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(tidepost_lat)","title":"<code>tidepost_lat</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(tidepost_lon)","title":"<code>tidepost_lon</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(plain_english)","title":"<code>plain_english</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(plot)","title":"<code>plot</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(plot_var)","title":"<code>plot_var</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(point_col)","title":"<code>point_col</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(modelled_freq)","title":"<code>modelled_freq</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(min_max_q)","title":"<code>min_max_q</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(round_stats)","title":"<code>round_stats</code>","text":""},{"location":"api/#eo_tides.stats.tide_stats(**tag_tides_kwargs)","title":"<code>**tag_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.validation","title":"eo_tides.validation","text":"<p>Validation tools for comparing modelled tides to observed tide gauge data.</p> <p>This module provides functions for loading, filtering, and analysing observed tide gauge data to validate modelled tide heights.</p> <p>Functions:</p> Name Description <code>eval_metrics</code> <p>Calculate common statistical validation metrics.</p> <code>load_gauge_gesla</code> <p>Load Global Extreme Sea Level Analysis (GESLA) tide gauge data.</p> <code>tide_correlation</code> <p>Ranks tide models based on their correlation with satellite-observed inundation patterns.</p>"},{"location":"api/#eo_tides.validation.eval_metrics","title":"eval_metrics","text":"<pre><code>eval_metrics(x, y, round=3, all_regress=False)\n</code></pre> <p>Calculate common statistical validation metrics.</p> <p>These include:</p> <ul> <li>Pearson correlation</li> <li>Root Mean Squared Error</li> <li>Mean Absolute Error</li> <li>R-squared</li> <li>Bias</li> <li>Linear regression parameters (slope, p-value, intercept, standard error)</li> </ul> <p>Parameters:</p> Name Type Description Default <code>array</code> <p>An array providing \"actual\" variable values.</p> required <code>array</code> <p>An array providing \"predicted\" variable values.</p> required <code>int</code> <p>Number of decimal places to round each metric to. Defaults to 3.</p> <code>3</code> <code>bool</code> <p>Whether to return linear regression p-value, intercept and standard error (in addition to only regression slope). Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>Series</code> <p>A <code>pd.Series</code> containing all calculated metrics.</p> Source code in <code>eo_tides/validation.py</code> <pre><code>def eval_metrics(x, y, round=3, all_regress=False):  # noqa: A002\n    \"\"\"Calculate common statistical validation metrics.\n\n    These include:\n\n    * Pearson correlation\n    * Root Mean Squared Error\n    * Mean Absolute Error\n    * R-squared\n    * Bias\n    * Linear regression parameters (slope, p-value, intercept, standard error)\n\n    Parameters\n    ----------\n    x : numpy.array\n        An array providing \"actual\" variable values.\n    y : numpy.array\n        An array providing \"predicted\" variable values.\n    round : int\n        Number of decimal places to round each metric\n        to. Defaults to 3.\n    all_regress : bool\n        Whether to return linear regression p-value,\n        intercept and standard error (in addition to\n        only regression slope). Defaults to False.\n\n    Returns\n    -------\n    pandas.Series\n        A `pd.Series` containing all calculated metrics.\n\n    \"\"\"\n    # Create dataframe to drop na\n    xy_df = pd.DataFrame({\"x\": x, \"y\": y}).dropna()\n\n    # Compute linear regression\n    lin_reg = stats.linregress(x=xy_df.x, y=xy_df.y)\n\n    # Calculate statistics\n    stats_dict = {\n        \"Correlation\": xy_df.corr().iloc[0, 1],\n        \"RMSE\": sqrt(mean_squared_error(xy_df.x, xy_df.y)),\n        \"MAE\": mean_absolute_error(xy_df.x, xy_df.y),\n        \"R-squared\": lin_reg.rvalue**2,\n        \"Bias\": (xy_df.y - xy_df.x).mean(),\n        \"Regression slope\": lin_reg.slope,\n    }\n\n    # Additional regression params\n    if all_regress:\n        stats_dict.update({\n            \"Regression p-value\": lin_reg.pvalue,\n            \"Regression intercept\": lin_reg.intercept,\n            \"Regression standard error\": lin_reg.stderr,\n        })\n\n    # Return as\n    return pd.Series(stats_dict).round(round)\n</code></pre>"},{"location":"api/#eo_tides.validation.eval_metrics(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.validation.eval_metrics(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.validation.eval_metrics(round)","title":"<code>round</code>","text":""},{"location":"api/#eo_tides.validation.eval_metrics(all_regress)","title":"<code>all_regress</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla","title":"load_gauge_gesla","text":"<pre><code>load_gauge_gesla(\n    x=None,\n    y=None,\n    site_code=None,\n    time=None,\n    max_distance=None,\n    correct_mean=False,\n    filter_use_flag=True,\n    site_metadata=True,\n    data_path=\"GESLA4_ALL\",\n    metadata_path=\"GESLA4_ALL.csv\",\n)\n</code></pre> <p>Load Global Extreme Sea Level Analysis (GESLA) tide gauge data.</p> <p>Load and process all available GESLA measured sea-level data with an <code>x, y, time</code> spatio-temporal query, or from a list of specific tide gauges. Can optionally filter by gauge quality and append detailed gauge metadata.</p> <p>Modified from original code in https://github.com/philiprt/GeslaDataset.</p> <p>Parameters:</p> Name Type Description Default <code>numeric or list / tuple</code> <p>Coordinates (in degrees longitude, latitude) used to load GESLA tide gauge observations. If provided as singular values (e.g. <code>x=150, y=-32</code>), then the nearest tide gauge will be returned. If provided as a list or tuple (e.g. <code>x=(150, 152), y=(-32, -30)</code>), then all gauges within the provided bounding box will be loaded. Leave as <code>None</code> to return all available gauges, or if providing a list of site codes using <code>site_code</code>.</p> <code>None</code> <code>numeric or list / tuple</code> <p>Coordinates (in degrees longitude, latitude) used to load GESLA tide gauge observations. If provided as singular values (e.g. <code>x=150, y=-32</code>), then the nearest tide gauge will be returned. If provided as a list or tuple (e.g. <code>x=(150, 152), y=(-32, -30)</code>), then all gauges within the provided bounding box will be loaded. Leave as <code>None</code> to return all available gauges, or if providing a list of site codes using <code>site_code</code>.</p> <code>None</code> <code>str or list of str</code> <p>GESLA site code(s) for which to load data (e.g. <code>site_code=\"62650\"</code>). If <code>site_code</code> is provided, <code>x</code> and <code>y</code> will be ignored.</p> <code>None</code> <code>tuple or list of str</code> <p>Time range to consider, given as a tuple of start and end dates, e.g. <code>time=(\"2020\", \"2021\")</code>. The default of None will return all tide observations from the year 1800 onward.</p> <code>None</code> <code>numeric</code> <p>Optional max distance within which to return the nearest tide gauge when <code>x</code> and <code>y</code> are provided as singular coordinates. Defaults to None, which will always return a tide gauge no matter how far away it is located from <code>x</code> and <code>y</code>.</p> <code>None</code> <code>bool</code> <p>Whether to correct sea level measurements to a standardised mean sea level by subtracting the mean of all observed sea level observations. This can be useful when GESLA tide heights come from different or unknown tide datums. Note: the observed mean sea level calculated here may differ from true long-term/ astronomical Mean Sea Level (MSL) datum.</p> <code>False</code> <code>bool</code> <p>Whether to filter out low quality observations with a \"use_flag\" value of 0 (do not use). Defaults to True.</p> <code>True</code> <code>bool</code> <p>Whether to add tide gauge station metadata as additional columns in the output DataFrame. Defaults to True.</p> <code>True</code> <code>str</code> <p>Path to the raw GESLA data files (\"GESLA-4 DATA\", accessible via: https://gesla787883612.wordpress.com/downloads/). Defaults to \"GESLA4_ALL\".</p> <code>'GESLA4_ALL'</code> <code>str</code> <p>Path to the GESLA station metadata file (\"GESLA-4 CSV META-DATA FILE\", accessible via: https://gesla787883612.wordpress.com/downloads/). Defaults to \"GESLA4_ALL.csv\".</p> <code>'GESLA4_ALL.csv'</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>Processed GESLA data as a DataFrame with columns including:</p> <ul> <li>\"time\": Timestamps,</li> <li>\"sea_level\": Observed sea level (m),</li> <li>\"qc_flag\": Observed sea level QC flag,</li> <li>\"use_flag\": Use-in-analysis flag (1 = use, 0 = do not use),</li> </ul> <p>...and additional columns from station metadata.</p> Source code in <code>eo_tides/validation.py</code> <pre><code>def load_gauge_gesla(\n    x=None,\n    y=None,\n    site_code=None,\n    time=None,\n    max_distance=None,\n    correct_mean=False,\n    filter_use_flag=True,\n    site_metadata=True,\n    data_path=\"GESLA4_ALL\",\n    metadata_path=\"GESLA4_ALL.csv\",\n):\n    \"\"\"Load Global Extreme Sea Level Analysis (GESLA) tide gauge data.\n\n    Load and process all available GESLA measured sea-level data\n    with an `x, y, time` spatio-temporal query, or from a list of\n    specific tide gauges. Can optionally filter by gauge quality\n    and append detailed gauge metadata.\n\n    Modified from original code in &lt;https://github.com/philiprt/GeslaDataset&gt;.\n\n    Parameters\n    ----------\n    x, y : numeric or list/tuple, optional\n        Coordinates (in degrees longitude, latitude) used to load GESLA\n        tide gauge observations. If provided as singular values\n        (e.g. `x=150, y=-32`), then the nearest tide gauge will be returned.\n        If provided as a list or tuple (e.g. `x=(150, 152), y=(-32, -30)`),\n        then all gauges within the provided bounding box will be loaded.\n        Leave as `None` to return all available gauges, or if providing a\n        list of site codes using `site_code`.\n    site_code : str or list of str, optional\n        GESLA site code(s) for which to load data (e.g. `site_code=\"62650\"`).\n        If `site_code` is provided, `x` and `y` will be ignored.\n    time : tuple or list of str, optional\n        Time range to consider, given as a tuple of start and end dates,\n        e.g. `time=(\"2020\", \"2021\")`. The default of None will return all\n        tide observations from the year 1800 onward.\n    max_distance : numeric, optional\n        Optional max distance within which to return the nearest tide gauge\n        when `x` and `y` are provided as singular coordinates. Defaults to\n        None, which will always return a tide gauge no matter how far away\n        it is located from `x` and `y`.\n    correct_mean : bool, optional\n        Whether to correct sea level measurements to a standardised mean\n        sea level by subtracting the mean of all observed sea level\n        observations. This can be useful when GESLA tide heights come\n        from different or unknown tide datums. Note: the observed mean\n        sea level calculated here may differ from true long-term/\n        astronomical Mean Sea Level (MSL) datum.\n    filter_use_flag : bool, optional\n        Whether to filter out low quality observations with a \"use_flag\"\n        value of 0 (do not use). Defaults to True.\n    site_metadata : bool, optional\n        Whether to add tide gauge station metadata as additional columns\n        in the output DataFrame. Defaults to True.\n    data_path : str, optional\n        Path to the raw GESLA data files (\"GESLA-4 DATA\", accessible via:\n        https://gesla787883612.wordpress.com/downloads/). Defaults to\n        \"GESLA4_ALL\".\n    metadata_path : str, optional\n        Path to the GESLA station metadata file (\"GESLA-4 CSV META-DATA FILE\",\n        accessible via: https://gesla787883612.wordpress.com/downloads/).\n        Defaults to \"GESLA4_ALL.csv\".\n\n    Returns\n    -------\n    pd.DataFrame\n        Processed GESLA data as a DataFrame with columns including:\n\n        - \"time\": Timestamps,\n        - \"sea_level\": Observed sea level (m),\n        - \"qc_flag\": Observed sea level QC flag,\n        - \"use_flag\": Use-in-analysis flag (1 = use, 0 = do not use),\n\n        ...and additional columns from station metadata.\n\n    \"\"\"\n    # Expand and validate data and metadata paths\n    data_path = Path(data_path).expanduser()\n    metadata_path = Path(metadata_path).expanduser()\n\n    if not data_path.exists():\n        err_msg = (\n            f\"GESLA raw data directory not found at `data_path={data_path}`.\\n\"\n            \"Download 'GESLA-4 DATA' from: \"\n            \"https://gesla787883612.wordpress.com/downloads/\"\n        )\n        raise FileNotFoundError(err_msg)\n\n    if not metadata_path.exists():\n        err_msg = (\n            f\"GESLA station metadata file not found at: `metadata_path={metadata_path}`.\\n\"\n            \"Download the 'GESLA-4 CSV META-DATA FILE' from: \"\n            \"https://gesla787883612.wordpress.com/downloads/\"\n        )\n        raise FileNotFoundError(err_msg)\n\n    # Load tide gauge metadata\n    metadata_df, metadata_gdf = _load_gauge_metadata(metadata_path)\n\n    # Use supplied site codes if available\n    if site_code is not None:\n        site_code = [site_code] if not isinstance(site_code, list) else site_code\n\n    # If x and y are tuples, use xy bounds to identify sites\n    elif isinstance(x, tuple | list) &amp; isinstance(y, tuple | list):\n        bbox = BoundingBox.from_xy(x, y)\n        site_code = metadata_gdf.cx[bbox.left : bbox.right, bbox.top : bbox.bottom].index\n\n    # If x and y are single numbers, select nearest row\n    elif isinstance(x, Number) &amp; isinstance(y, Number):\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            site_code = (\n                _nearest_row(metadata_gdf, x, y, max_distance).rename({\"index_right\": \"site_code\"}, axis=1).site_code\n            )\n\n        # Raise exception if no valid tide gauges are found\n        if site_code.isna().all():\n            err_msg = f\"No tide gauge found within {max_distance} degrees of {x}, {y}.\"\n            raise Exception(err_msg)\n\n    # Otherwise if all are None, return all available site codes\n    elif (site_code is None) &amp; (x is None) &amp; (y is None):\n        site_code = metadata_df.index.to_list()\n\n    else:\n        err_msg = (\n            \"`x` and `y` must be provided as either singular coordinates (e.g. `x=150`), or as a tuple bounding box (e.g. `x=(150, 152)`).\",\n        )\n        raise Exception(err_msg)\n\n    # Prepare times\n    if time is None:\n        time = [\"1800\", str(datetime.datetime.now().year)]\n    time = [time] if not isinstance(time, list | tuple) else time\n    start_time = _round_date_strings(time[0], round_type=\"start\")\n    end_time = _round_date_strings(time[-1], round_type=\"end\")\n\n    # Identify paths to load and nodata values for each site\n    metadata_df[\"file_name\"] = data_path / metadata_df[\"file_name\"]\n    paths_na = metadata_df.loc[site_code, [\"file_name\", \"null_value\"]]\n\n    # Load and combine into a single dataframe\n    gauge_list = [\n        _load_gesla_dataset(s, p, na_value=na)\n        for s, p, na in tqdm.tqdm(paths_na.itertuples(), total=len(paths_na), desc=\"Loading GESLA gauges\")\n    ]\n    data_df = pd.concat(gauge_list).sort_index().loc[slice(start_time, end_time)].reset_index().set_index(\"site_code\")\n\n    # Optionally filter by use flag column\n    if filter_use_flag:\n        data_df = data_df.loc[data_df.use_flag == 1]\n\n    # Optionally insert metadata into dataframe\n    if site_metadata:\n        if data_df.empty:\n            data_df = data_df.reindex(columns=[*data_df.columns, *metadata_df.columns])\n        else:\n            data_df[metadata_df.columns] = metadata_df.loc[site_code]\n\n    # Add time to index and remove duplicates\n    data_df = data_df.set_index(\"time\", append=True)\n    duplicates = data_df.index.duplicated()\n    if duplicates.sum() &gt; 0:\n        warnings.warn(\"Duplicate timestamps were removed.\", UserWarning, stacklevel=2)\n        data_df = data_df.loc[~duplicates]\n\n    # Remove observed mean sea level if requested\n    if correct_mean:\n        data_df[\"sea_level\"] = data_df[\"sea_level\"].sub(data_df.groupby(\"site_code\")[\"sea_level\"].transform(\"mean\"))\n\n    # If no rows are returned, raise a warning\n    if data_df.empty:\n        warnings.warn(\n            f\"No data found for site '{site_code}'. \"\n            \"Are you trying to load data using `time` for a period that does not have tide gauge measurements?\",\n            UserWarning,\n            stacklevel=2,\n        )\n\n    # Return data\n    return data_df\n</code></pre>"},{"location":"api/#eo_tides.validation.load_gauge_gesla(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(site_code)","title":"<code>site_code</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(max_distance)","title":"<code>max_distance</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(correct_mean)","title":"<code>correct_mean</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(filter_use_flag)","title":"<code>filter_use_flag</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(site_metadata)","title":"<code>site_metadata</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(data_path)","title":"<code>data_path</code>","text":""},{"location":"api/#eo_tides.validation.load_gauge_gesla(metadata_path)","title":"<code>metadata_path</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation","title":"tide_correlation","text":"<pre><code>tide_correlation(\n    x=None,\n    y=None,\n    time=(\"2022\", \"2024\"),\n    crs=\"EPSG:4326\",\n    data=None,\n    model=\"all\",\n    directory=None,\n    index_threshold=0.0,\n    freq_min=0.01,\n    freq_max=0.99,\n    corr_min=0.15,\n    buffer=2500,\n    cloud_cover=90,\n    load_ls=True,\n    load_s2=True,\n    **tag_tides_kwargs\n)\n</code></pre> <p>Ranks tide models based on their correlation with satellite-observed inundation patterns.</p> <p>Correlations are calculated between satellite-derived water index (e.g. Normalised Difference Water Index, NDWI) and tide heights across a buffered region around an input point. High correlations indicate that a tide model correctly sorted satellite imagery by tide height, with high tide observations being consistently wet, and low tide observations being consistently dry.</p> <p>By default Microsoft Planetary Computer is used for loading data; for advance use, a pre-loaded water index xarray.DataArray from any satellite data source can be provided via <code>data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>float</code> <p>X and Y coordinates of a coastal point of interest. Assumed to be \"EPSG:4326\" degrees lat/lon; use \"crs\" for custom CRSs.</p> <code>None</code> <code>float</code> <p>X and Y coordinates of a coastal point of interest. Assumed to be \"EPSG:4326\" degrees lat/lon; use \"crs\" for custom CRSs.</p> <code>None</code> <code>tuple</code> <p>The time range to load data for as a tuple of strings (e.g. <code>(\"2022\", \"2024\")</code>. We recommend using a long enough time period (e.g. 3+ years) to ensure that results are not affected by tide aliasing; see <code>eo_tides.stats.tide_aliasing</code> for more information.</p> <code>('2022', '2024')</code> <code>str</code> <p>Input coordinate reference system for x and y coordinates. Defaults to \"EPSG:4326\" (WGS84; degrees latitude, longitude).</p> <code>'EPSG:4326'</code> <code>DataArray</code> <p>For advanced use, an xarray.DataArray of water index (e.g. NDWI) data can be supplied. If so, all data loading parameters (<code>x</code>, <code>y</code>, <code>time</code>, <code>crs</code>, <code>buffer</code> <code>cloud_cover</code>, <code>load_ls</code>, <code>load_s2</code>) will be ignored.</p> <code>None</code> <code>str or list of str</code> <p>The tide model (or list of models) to compare. Defaults to \"all\", which will compare all models available in <code>directory</code>. For a full list of available and supported models, run <code>from eo_tides.utils import list_models; list_models()</code>.</p> <code>'all'</code> <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>float</code> <p>Water index (e.g. NDWI) threshold above which a pixel is considered wet.</p> <code>0.0</code> <code>float</code> <p>Minimum fraction of time a pixel must be wet to be considered intertidal and included in the analysis.</p> <code>0.01</code> <code>float</code> <p>Maximum fraction of time a pixel can be wet to be considered intertidal and included in the analysis.</p> <code>0.99</code> <code>float</code> <p>Minimum correlation between water index (e.g. NDWI) and tide heights to be considered intertidal and included in the analysis. To ensure a like-for-like comparison, model rankings are based on the average correlation across every pixel with a positive correlation of at least <code>corr_min</code> in any individual input model.</p> <code>0.15</code> <code>float</code> <p>Radius in meters for generating circular buffer around the input point.</p> <code>2500</code> <code>int</code> <p>The maximum threshold of cloud cover to load. Defaults to 90%.</p> <code>90</code> <code>bool</code> <p>Whether to load Landsat water index (e.g. NDWI) data.</p> <code>True</code> <code>bool</code> <p>Whether to load Sentinel-2 water index (e.g. NDWI) data.</p> <code>True</code> <p>Optional parameters passed to the <code>eo_tides.eo.tag_tides</code> function used to model tides.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>corr_df</code> <code>DataFrame</code> <p>DataFrame with correlation and ranking per tide model. Columns include:</p> <ul> <li>'correlation': mean correlation between water index (e.g. NDWI and tide heights each model</li> <li>'rank': model rank based on correlation (1 = highest)</li> </ul> <code>corr_da</code> <code>DataArray</code> <p>Per-pixel correlations for each model, restricted to likely intertidal pixels, with dynamic wetness frequency (e.g. not always dry or wet), and with a positive correlation with tide heights from at least one tide model.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from eo_tides import tide_correlation\n&gt;&gt;&gt; y, x = -16.99636, 123.61017\n&gt;&gt;&gt; corr_df, corr_da = tide_correlation(x=x, y=y, directory=\"tide_models/\", cloud_cover=10)\n</code></pre> Source code in <code>eo_tides/validation.py</code> <pre><code>def tide_correlation(\n    x: float | None = None,\n    y: float | None = None,\n    time: tuple[str, str] = (\"2022\", \"2024\"),\n    crs: str = \"EPSG:4326\",\n    data: xr.DataArray | None = None,\n    model: str | list[str] = \"all\",\n    directory: str | os.PathLike | None = None,\n    index_threshold: float = 0.0,\n    freq_min: float = 0.01,\n    freq_max: float = 0.99,\n    corr_min: float = 0.15,\n    buffer: float = 2500,\n    cloud_cover: float = 90,\n    load_ls: bool = True,\n    load_s2: bool = True,\n    **tag_tides_kwargs,\n):\n    \"\"\"Ranks tide models based on their correlation with satellite-observed inundation patterns.\n\n    Correlations are calculated between satellite-derived water index\n    (e.g. Normalised Difference Water Index, NDWI) and tide heights\n    across a buffered region around an input point. High correlations\n    indicate that a tide model correctly sorted satellite imagery by\n    tide height, with high tide observations being consistently wet,\n    and low tide observations being consistently dry.\n\n    By default Microsoft Planetary Computer is used for loading data;\n    for advance use, a pre-loaded water index xarray.DataArray from any\n    satellite data source can be provided via `data`.\n\n    Parameters\n    ----------\n    x, y : float, optional\n        X and Y coordinates of a coastal point of interest. Assumed\n        to be \"EPSG:4326\" degrees lat/lon; use \"crs\" for custom CRSs.\n    time : tuple, optional\n        The time range to load data for as a tuple of strings (e.g.\n        `(\"2022\", \"2024\")`. We recommend using a long enough time\n        period (e.g. 3+ years) to ensure that results are not affected\n        by tide aliasing; see `eo_tides.stats.tide_aliasing` for more\n        information.\n    crs : str, optional\n        Input coordinate reference system for x and y coordinates.\n        Defaults to \"EPSG:4326\" (WGS84; degrees latitude, longitude).\n    data : xr.DataArray, optional\n        For advanced use, an xarray.DataArray of water index (e.g. NDWI)\n        data can be supplied. If so, all data loading parameters (`x`,\n        `y`, `time`, `crs`, `buffer` `cloud_cover`, `load_ls`, `load_s2`)\n        will be ignored.\n    model : str or list of str, optional\n        The tide model (or list of models) to compare. Defaults to\n        \"all\", which will compare all models available in `directory`.\n        For a full list of available and supported models,\n        run `from eo_tides.utils import list_models; list_models()`.\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    index_threshold : float, optional\n        Water index (e.g. NDWI) threshold above which a pixel is\n        considered wet.\n    freq_min : float, optional\n        Minimum fraction of time a pixel must be wet to be considered\n        intertidal and included in the analysis.\n    freq_max : float, optional\n        Maximum fraction of time a pixel can be wet to be considered\n        intertidal and included in the analysis.\n    corr_min : float, optional\n        Minimum correlation between water index (e.g. NDWI) and tide\n        heights to be considered intertidal and included in the analysis.\n        To ensure a like-for-like comparison, model rankings are based on\n        the average correlation across every pixel with a positive\n        correlation of at least `corr_min` in any individual input model.\n    buffer : float, optional\n        Radius in meters for generating circular buffer around the\n        input point.\n    cloud_cover : int, optional\n        The maximum threshold of cloud cover to load. Defaults to 90%.\n    load_ls : bool, optional\n        Whether to load Landsat water index (e.g. NDWI) data.\n    load_s2 : bool, optional\n        Whether to load Sentinel-2 water index (e.g. NDWI) data.\n    **tag_tides_kwargs :\n        Optional parameters passed to the `eo_tides.eo.tag_tides`\n        function used to model tides.\n\n    Returns\n    -------\n    corr_df : pandas.DataFrame\n        DataFrame with correlation and ranking per tide model.\n        Columns include:\n\n        - 'correlation': mean correlation between water index\n        (e.g. NDWI and tide heights each model\n        - 'rank': model rank based on correlation (1 = highest)\n    corr_da : xr.DataArray\n        Per-pixel correlations for each model, restricted to likely\n        intertidal pixels, with dynamic wetness frequency (e.g. not\n        always dry or wet), and with a positive correlation with tide\n        heights from at least one tide model.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from eo_tides import tide_correlation\n    &gt;&gt;&gt; y, x = -16.99636, 123.61017\n    &gt;&gt;&gt; corr_df, corr_da = tide_correlation(x=x, y=y, directory=\"tide_models/\", cloud_cover=10)\n\n    \"\"\"\n    # Use custom xarray.DataArray if provided\n    if data is not None:\n        # Verify is xr.DataArray\n        if not isinstance(data, xr.DataArray):\n            err_msg = \"Must provide an xarray.DataArray to `data`.\"\n            raise Exception(err_msg)\n\n        water_index = data\n        x, y = data.odc.geobox.geographic_extent.centroid.coords[0]\n\n    # Otherwise load data for point using MPC\n    elif (x is not None) and (y is not None):\n        # Create circular study area around point\n        geom = point(x=x, y=y, crs=crs).to_crs(\"utm\").buffer(buffer).to_crs(\"EPSG:4326\")\n\n        # Load time series water_index (e.g. NDWI) for selected time period and location\n        water_index = load_ndwi_mpc(\n            time=time,\n            geopolygon=geom,\n            mask_geopolygon=True,\n            cloud_cover=cloud_cover,\n            load_ls=load_ls,\n            load_s2=load_s2,\n        ).ndwi\n\n    # Raise error if no valid inputs are provided\n    else:\n        err_msg = \"Must provide both `x` and `y`, or `data`.\"\n        raise Exception(err_msg)\n\n    # Threshold water_index to identify wet pixels, then calculate\n    # overall wetness frequency (making sure NaN pixels are\n    # correctly masked to ensure correct statistics)\n    wet = (water_index &gt; index_threshold).where(water_index.notnull())\n    freq = wet.mean(dim=\"time\")\n\n    # Model tides using selected models (all available by default).\n    # Use cast to tell mypy this will always be an xr.DataArray.\n    tides_da = cast(\"xr.DataArray\", tag_tides(water_index, model=model, directory=directory, **tag_tides_kwargs))\n\n    # Calculate correlation between wetness and each tide model\n    corr = xr.corr(wet, tides_da, dim=\"time\")\n\n    # Restrict data to likely intertidal pixels, with dynamic\n    # wetness frequency (e.g. not always dry or wet), and\n    # with a positive correlation with tide heights from at\n    # least one tide model\n    corr_max = corr.max(dim=\"tide_model\")\n    corr_da = corr.where((freq &gt;= freq_min) &amp; (freq &lt;= freq_max) &amp; (corr_max &gt;= corr_min))\n    corr_da.load()\n\n    # Calculate mean correlation per model and valid data coverage\n    corr_mean = corr_da.mean(dim=[\"x\", \"y\"])\n    valid_perc = corr_da.notnull().mean().item()\n\n    # Create DataFrame with correlation and rank\n    corr_df = (\n        # Convert to dataframe\n        corr_mean.to_dataframe(name=\"correlation\")\n        .drop(\"spatial_ref\", axis=1)\n        # Add rankings\n        .assign(rank=lambda df: df.correlation.rank(ascending=False))\n        .astype(\"float32\")\n        # Add metadata\n        .assign(x=x, y=y, valid_perc=valid_perc)\n    )\n\n    return corr_df, corr_da\n</code></pre>"},{"location":"api/#eo_tides.validation.tide_correlation(x)","title":"<code>x</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(y)","title":"<code>y</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(crs)","title":"<code>crs</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(data)","title":"<code>data</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(index_threshold)","title":"<code>index_threshold</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(freq_min)","title":"<code>freq_min</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(freq_max)","title":"<code>freq_max</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(corr_min)","title":"<code>corr_min</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(buffer)","title":"<code>buffer</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(cloud_cover)","title":"<code>cloud_cover</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(load_ls)","title":"<code>load_ls</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(load_s2)","title":"<code>load_s2</code>","text":""},{"location":"api/#eo_tides.validation.tide_correlation(**tag_tides_kwargs)","title":"<code>**tag_tides_kwargs</code>","text":""},{"location":"api/#eo_tides.stac","title":"eo_tides.stac","text":"<p>Tools for loading satellite EO data using STAC.</p> <p>This module provides utilities for loading EO data via SpatioTemporal Asset Catalog (STAC) metadata, such as those available on platforms like Microsoft Planetary Computer.</p> <p>Functions:</p> Name Description <code>load_ndwi_mpc</code> <p>Load an NDWI time-series from Landsat and/or Sentinel-2 from Microsoft Planetary Computer.</p> <code>stac_load</code> <p>Query and load satellite data from a STAC API.</p>"},{"location":"api/#eo_tides.stac.load_ndwi_mpc","title":"load_ndwi_mpc","text":"<pre><code>load_ndwi_mpc(\n    time=None,\n    lon=None,\n    lat=None,\n    bbox=None,\n    geopolygon=None,\n    mask_geopolygon=False,\n    crs=\"utm\",\n    resolution=30,\n    resampling=\"cubic\",\n    cloud_cover=90,\n    load_ls=True,\n    load_s2=True,\n    chunks={\"x\": 2048, \"y\": 2048},\n    fail_on_error=False,\n)\n</code></pre> <p>Load an NDWI time-series from Landsat and/or Sentinel-2 from Microsoft Planetary Computer.</p> <p>Landsat and Sentinel-2 satellite data are accessed from the Microsoft Planetary Computer (\"landsat-c2-l2\" and \"sentinel-2-l2a\") STAC API using a set of opinionated loading and cloud-masking parameters. These parameters may not be optimal for all use cases; we recommend reviewing and/or modifying them prior to formal analysis.</p> <p>Parameters:</p> Name Type Description Default <code>tuple</code> <p>The time range to load data for as a tuple of strings (e.g. <code>(\"2020\", \"2021\")</code>. If not provided, data will be loaded for all available timesteps.</p> <code>None</code> <code>tuple</code> <p>Tuples defining the spatial x and y extent to load in degrees.</p> <code>None</code> <code>tuple</code> <p>Tuples defining the spatial x and y extent to load in degrees.</p> <code>None</code> <code>(BoundingBox, tuple or list)</code> <p>Load data into the extent of a bounding box (left, bottom, right, top).</p> <code>None</code> <code>multiple types</code> <p>Load data into the extents of a geometry. This could be an odc.geo Geometry, a GeoJSON dictionary, Shapely geometry, GeoPandas DataFrame or GeoSeries. GeoJSON and Shapely inputs are assumed to be in EPSG:4326 coordinates.</p> <code>None</code> <code>bool</code> <p>Whether to mask pixels as nodata if they are outside the extent of a provided geopolygon. Defaults to False.</p> <code>False</code> <code>str</code> <p>The Coordinate Reference System (CRS) to load data into. Defaults to \"utm\", which will attempt to load data into its native UTM CRS to minimise resampling.</p> <code>'utm'</code> <code>int</code> <p>Spatial resolution to load data in. Defaults to 30 metres.</p> <code>30</code> <code>str</code> <p>Resampling method used for surface reflectance bands. Defaults to \"cubic\"; \"nearest\" will always be used for categorical cloud masking bands.</p> <code>'cubic'</code> <code>int</code> <p>The maximum threshold of cloud cover to load. Defaults to 90%.</p> <code>90</code> <code>bool</code> <p>Whether to query and load Landsat data (\"landsat-c2-l2\").</p> <code>True</code> <code>bool</code> <p>Whether to query and load Sentinel-2 data (\"sentinel-2-l2a\").</p> <code>True</code> <code>dictionary</code> <p>Dask chunking used to load data as lazy Dask backed arrays. Defaults to <code>{\"x\": 2048, \"y\": 2048}</code>.</p> <code>{'x': 2048, 'y': 2048}</code> <code>bool</code> <p>Whether to return an error if any individual satellite datasets cannot be loaded. Defaults to False, which prevents ephemeral cloud access issues from failing the analysis.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>satellite_ds</code> <code>Dataset</code> <p>The loaded dataset as an <code>xarray.Dataset</code>, containing a single \"ndwi\" <code>xarray.DataArray</code>.</p> Source code in <code>eo_tides/stac.py</code> <pre><code>def load_ndwi_mpc(\n    time: tuple[str, str] | None = None,\n    lon: tuple[float, float] | None = None,\n    lat: tuple[float, float] | None = None,\n    bbox: BoundingBox | tuple | list | None = None,\n    geopolygon: Any | None = None,\n    mask_geopolygon: bool = False,\n    crs: str = \"utm\",\n    resolution: float = 30,\n    resampling: str = \"cubic\",\n    cloud_cover: float = 90,\n    load_ls: bool = True,\n    load_s2: bool = True,\n    chunks: dict[str, int] = {\"x\": 2048, \"y\": 2048},\n    fail_on_error: bool = False,\n) -&gt; Dataset:\n    \"\"\"Load an NDWI time-series from Landsat and/or Sentinel-2 from Microsoft Planetary Computer.\n\n    Landsat and Sentinel-2 satellite data are accessed from the Microsoft\n    Planetary Computer (\"landsat-c2-l2\" and \"sentinel-2-l2a\") STAC API using\n    a set of opinionated loading and cloud-masking parameters.\n    These parameters may not be optimal for all use cases; we recommend\n    reviewing and/or modifying them prior to formal analysis.\n\n    Parameters\n    ----------\n    time : tuple, optional\n        The time range to load data for as a tuple of strings (e.g.\n        `(\"2020\", \"2021\")`. If not provided, data will be loaded for\n        all available timesteps.\n    lon, lat : tuple, optional\n        Tuples defining the spatial x and y extent to load in degrees.\n    bbox : BoundingBox, tuple or list, optional\n        Load data into the extent of a bounding box (left, bottom, right, top).\n    geopolygon : multiple types, optional\n        Load data into the extents of a geometry. This could be an\n        odc.geo Geometry, a GeoJSON dictionary, Shapely geometry, GeoPandas\n        DataFrame or GeoSeries. GeoJSON and Shapely inputs are assumed to\n        be in EPSG:4326 coordinates.\n    mask_geopolygon : bool, optional\n        Whether to mask pixels as nodata if they are outside the extent\n        of a provided geopolygon. Defaults to False.\n    crs : str, optional\n        The Coordinate Reference System (CRS) to load data into. Defaults\n        to \"utm\", which will attempt to load data into its native UTM\n        CRS to minimise resampling.\n    resolution : int, optional\n        Spatial resolution to load data in. Defaults to 30 metres.\n    resampling : str, optional\n        Resampling method used for surface reflectance bands. Defaults\n        to \"cubic\"; \"nearest\" will always be used for categorical cloud\n        masking bands.\n    cloud_cover : int, optional\n        The maximum threshold of cloud cover to load. Defaults to 90%.\n    load_ls : bool, optional\n        Whether to query and load Landsat data (\"landsat-c2-l2\").\n    load_s2 : bool, optional\n        Whether to query and load Sentinel-2 data (\"sentinel-2-l2a\").\n    chunks : dictionary, optional\n        Dask chunking used to load data as lazy Dask backed arrays.\n        Defaults to `{\"x\": 2048, \"y\": 2048}`.\n    fail_on_error : bool, optional\n        Whether to return an error if any individual satellite datasets\n        cannot be loaded. Defaults to False, which prevents ephemeral\n        cloud access issues from failing the analysis.\n\n    Returns\n    -------\n    satellite_ds : xarray.Dataset\n        The loaded dataset as an `xarray.Dataset`, containing a single\n        \"ndwi\" `xarray.DataArray`.\n\n    \"\"\"\n    # Assemble parameters used for querying STAC API\n    query_params = {\n        \"time\": time,\n        \"geopolygon\": geopolygon,\n        \"bbox\": bbox,\n        \"lon\": lon,\n        \"lat\": lat,\n    }\n\n    # Assemble parameters used for loading data into xarray format\n    load_params = {\n        \"crs\": crs,\n        \"resolution\": resolution,\n        \"chunks\": chunks,\n        \"fail_on_error\": fail_on_error,\n        \"groupby\": \"solar_day\",\n        \"resampling\": {\"qa_pixel\": \"nearest\", \"SCL\": \"nearest\", \"*\": resampling},\n    }\n\n    # List to hold outputs for each sensor (Landsat, Sentinel-2)\n    output_list = []\n\n    if load_ls:\n        # Load Landsat\n        ds_ls, items_ls = stac_load(\n            product=\"landsat-c2-l2\",\n            bands=(\"green\", \"nir08\", \"qa_pixel\"),\n            stac_query={\n                \"eo:cloud_cover\": {\"lt\": cloud_cover},\n                \"landsat:collection_category\": {\"in\": [\"T1\"]},\n            },\n            **query_params,  # type: ignore[arg-type]\n            **load_params,  # type: ignore[arg-type]\n        )\n\n        # Apply simple Landsat cloud mask\n        cloud_mask = (\n            # Bit 3: high confidence cloud, bit 4: high confidence shadow\n            # https://medium.com/analytics-vidhya/python-for-geosciences-\n            # raster-bit-masks-explained-step-by-step-8620ed27141e\n            np.bitwise_and(ds_ls.qa_pixel, 1 &lt;&lt; 3) | np.bitwise_and(ds_ls.qa_pixel, 1 &lt;&lt; 4)\n        ) == 0\n        ds_ls = ds_ls.where(cloud_mask).drop_vars(\"qa_pixel\")\n\n        # Rescale to between 0.0 and 1.0\n        ds_ls = (ds_ls.where(ds_ls != 0) * 0.0000275 + -0.2).clip(0, 1)\n\n        # Convert to NDWI\n        ndwi_ls = (ds_ls.green - ds_ls.nir08) / (ds_ls.green + ds_ls.nir08)\n        output_list.append(ndwi_ls)\n\n    if load_s2:\n        # Load Sentinel-2\n        ds_s2, items_s2 = stac_load(\n            product=\"sentinel-2-l2a\",\n            bands=(\"green\", \"nir\", \"SCL\"),\n            stac_query={\n                \"eo:cloud_cover\": {\"lt\": cloud_cover},\n            },\n            **query_params,  # type: ignore[arg-type]\n            **load_params,  # type: ignore[arg-type]\n        )\n\n        # Apply simple Sentinel-2 cloud mask\n        # 1: defective, 3: shadow, 9: high confidence cloud\n        cloud_mask = ~ds_s2.SCL.isin([0, 1, 3, 9])\n        ds_s2 = ds_s2.where(cloud_mask).drop_vars(\"SCL\")\n\n        # Sentinel-2 Processing Baseline 4.0 introduced new offset/scaling\n        # after January 25 2022. We have to split our data before and after\n        # this date, and apply different scaling to each\n        ds_s2_pre = ds_s2.sel(time=slice(None, \"2022-01-25\"))\n        ds_s2_post = ds_s2.sel(time=slice(\"2022-01-26\", None))\n        ds_s2_pre = (ds_s2_pre.where(ds_s2_pre != 0) * 0.0001).clip(0, 1)\n        ds_s2_post = ((ds_s2_post.where(ds_s2_post != 0) - 1000) * 0.0001).clip(0, 1)\n\n        # Combine both rescaled datasets\n        ds_s2 = xr.concat([ds_s2_pre, ds_s2_post], dim=\"time\")\n\n        # Convert to NDWI\n        ndwi_s2 = (ds_s2.green - ds_s2.nir) / (ds_s2.green + ds_s2.nir)\n        output_list.append(ndwi_s2)\n\n    # Merge into a single dataset\n    ndwi = xr.concat(output_list, dim=\"time\").sortby(\"time\").to_dataset(name=\"ndwi\")\n\n    # Optionally mask areas outside of supplied geopolygon (this has to be\n    # applied here because applying it at the `stac_load` level converts\n    # cloud masking bands to \"float32\".\n    if mask_geopolygon &amp; (geopolygon is not None):\n        geopolygon = _normalize_geometry(geopolygon)\n        ndwi = ndwi.odc.mask(poly=geopolygon)\n\n    return ndwi\n</code></pre>"},{"location":"api/#eo_tides.stac.load_ndwi_mpc(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(lon)","title":"<code>lon</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(lat)","title":"<code>lat</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(bbox)","title":"<code>bbox</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(geopolygon)","title":"<code>geopolygon</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(mask_geopolygon)","title":"<code>mask_geopolygon</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(crs)","title":"<code>crs</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(resolution)","title":"<code>resolution</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(resampling)","title":"<code>resampling</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(cloud_cover)","title":"<code>cloud_cover</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(load_ls)","title":"<code>load_ls</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(load_s2)","title":"<code>load_s2</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(chunks)","title":"<code>chunks</code>","text":""},{"location":"api/#eo_tides.stac.load_ndwi_mpc(fail_on_error)","title":"<code>fail_on_error</code>","text":""},{"location":"api/#eo_tides.stac.stac_load","title":"stac_load","text":"<pre><code>stac_load(\n    product,\n    bands=None,\n    time=None,\n    lon=None,\n    lat=None,\n    bbox=None,\n    geopolygon=None,\n    mask_geopolygon=False,\n    stac_query=None,\n    stac_url=\"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    dtype=None,\n    **load_params\n)\n</code></pre> <p>Query and load satellite data from a STAC API.</p> <p>Uses <code>pystac_client</code> to query a SpatioTemporal Asset Catalogue (STAC), then load the results as a multi-temporal <code>xarray.Dataset</code> using <code>odc-stac</code>.</p> <p>Defaults to using the Microsoft Planetary Computer STAC API.</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The name of the product (i.e. STAC \"collection\") to load.</p> required <code>str or list</code> <p>List of band names to load. Defaults to all, also accepts a single band name (e.g. \"red\").</p> <code>None</code> <code>tuple</code> <p>The time range to load data for as a tuple of strings (e.g. <code>(\"2020\", \"2021\")</code>. If not provided, data will be loaded for all available timesteps.</p> <code>None</code> <code>tuple</code> <p>Tuples defining the spatial x and y extent to load in degrees.</p> <code>None</code> <code>tuple</code> <p>Tuples defining the spatial x and y extent to load in degrees.</p> <code>None</code> <code>tuple</code> <p>Load data into the extent of a bounding box (left, bottom, right, top).</p> <code>None</code> <code>multiple types</code> <p>Load data into the extents of a geometry. This could be an odc.geo Geometry, a GeoJSON dictionary, Shapely geometry, GeoPandas DataFrame or GeoSeries. GeoJSON and Shapely inputs are assumed to be in EPSG:4326 coordinates.</p> <code>None</code> <code>bool</code> <p>Whether to mask pixels as <code>NaN</code> if they are outside the extent of a provided geopolygon. Defaults to False; note that this will convert all bands to <code>float32</code> dtype, so should be used with caution for any integer or boolean bands (e.g. cloud masks etc).</p> <code>False</code> <code>dict</code> <p>A query dictionary to further filter the data using STAC metadata. If not provided, no additional filtering will be applied. For example: <code>stac_query = {\"eo:cloud_cover\": {\"lt\": 10}}</code>.</p> <code>None</code> <code>str</code> <p>The URL of the STAC API endpoint to query and load data from. Defaults to \"https://planetarycomputer.microsoft.com/api/stac/v1\".</p> <code>'https://planetarycomputer.microsoft.com/api/stac/v1'</code> <code>optional</code> <p>Data type to load data into. The default will use the dataset's default dtype. If <code>mask_geopolygon=True</code>, data will be returned in <code>float32</code> with pixels outside the mask set to <code>NaN</code>.</p> <code>None</code> <code>dict</code> <p>Additional parameters to be passed to <code>odc.stac.load()</code> to customise how data is loaded.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>ds</code> <code>Dataset</code> <p>The loaded dataset as an <code>xarray.Dataset</code>.</p> <code>items</code> <code>ItemCollection</code> <p>STAC items returned by <code>pystac_client</code>.</p> Source code in <code>eo_tides/stac.py</code> <pre><code>def stac_load(\n    product: str,\n    bands: str | list[str] | tuple[str, ...] | None = None,\n    time: tuple[str, str] | None = None,\n    lon: tuple[float, float] | None = None,\n    lat: tuple[float, float] | None = None,\n    bbox: tuple[float, float, float, float] | None = None,\n    geopolygon: Any | None = None,\n    mask_geopolygon: bool = False,\n    stac_query: dict | None = None,\n    stac_url: str = \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    dtype: Any | None = None,\n    **load_params,\n) -&gt; tuple[Dataset, ItemCollection]:\n    \"\"\"Query and load satellite data from a STAC API.\n\n    Uses `pystac_client` to query a SpatioTemporal Asset Catalogue (STAC),\n    then load the results as a multi-temporal `xarray.Dataset` using\n    `odc-stac`.\n\n    Defaults to using the Microsoft Planetary Computer STAC API.\n\n    Parameters\n    ----------\n    product : str\n        The name of the product (i.e. STAC \"collection\") to load.\n    bands : str or list, optional\n        List of band names to load. Defaults to all, also accepts a\n        single band name (e.g. \"red\").\n    time : tuple, optional\n        The time range to load data for as a tuple of strings (e.g.\n        `(\"2020\", \"2021\")`. If not provided, data will be loaded for\n        all available timesteps.\n    lon, lat : tuple, optional\n        Tuples defining the spatial x and y extent to load in degrees.\n    bbox : tuple, optional\n        Load data into the extent of a bounding box (left, bottom, right, top).\n    geopolygon : multiple types, optional\n        Load data into the extents of a geometry. This could be an\n        odc.geo Geometry, a GeoJSON dictionary, Shapely geometry, GeoPandas\n        DataFrame or GeoSeries. GeoJSON and Shapely inputs are assumed to\n        be in EPSG:4326 coordinates.\n    mask_geopolygon : bool, optional\n        Whether to mask pixels as `NaN` if they are outside the extent\n        of a provided geopolygon. Defaults to False; note that this\n        will convert all bands to `float32` dtype, so should be used with\n        caution for any integer or boolean bands (e.g. cloud masks etc).\n    stac_query : dict, optional\n        A query dictionary to further filter the data using STAC metadata.\n        If not provided, no additional filtering will be applied. For\n        example: `stac_query = {\"eo:cloud_cover\": {\"lt\": 10}}`.\n    stac_url : str, optional\n        The URL of the STAC API endpoint to query and load data from.\n        Defaults to \"https://planetarycomputer.microsoft.com/api/stac/v1\".\n    dtype : optional\n        Data type to load data into. The default will use the dataset's\n        default dtype. If `mask_geopolygon=True`, data will be returned\n        in `float32` with pixels outside the mask set to `NaN`.\n    **load_params : dict\n        Additional parameters to be passed to `odc.stac.load()` to customise\n        how data is loaded.\n\n    Returns\n    -------\n    ds : xarray.Dataset\n        The loaded dataset as an `xarray.Dataset`.\n    items : pystac.item_collection.ItemCollection\n        STAC items returned by `pystac_client`.\n\n    \"\"\"\n    # Connect to client\n    catalog = pystac_client.Client.open(\n        stac_url,\n        modifier=(planetary_computer.sign_inplace if \"planetarycomputer\" in stac_url else None),\n    )\n\n    # Set dtype; use provided unless `mask_geopolygon` is provided,\n    # in which case use `float32`.\n    dtype = \"float32\" if mask_geopolygon else dtype\n\n    # Set up time for query\n    time = \"/\".join(time) if time is not None else None\n\n    # Extract degree lat/lon bounding box for STAC query\n    bbox_4326, geopolygon = _get_bbox(bbox=bbox, geopolygon=geopolygon, lon=lon, lat=lat)\n\n    # Find matching items\n    search = catalog.search(\n        collections=product,\n        bbox=(bbox_4326.left, bbox_4326.bottom, bbox_4326.right, bbox_4326.top),\n        datetime=time,\n        query=stac_query if stac_query is not None else None,\n    )\n\n    # Check how many items were returned\n    items = search.item_collection()\n    print(f\"Found {len(items)} STAC items for {product}\")\n\n    # Load with ODC STAC\n    ds = odc.stac.load(\n        items=items,\n        bands=bands,\n        bbox=bbox,\n        geopolygon=geopolygon,\n        lon=lon,\n        lat=lat,\n        dtype=dtype,\n        **load_params,\n    )\n\n    # Optionally mask areas outside of supplied geopolygon\n    if mask_geopolygon &amp; (geopolygon is not None):\n        ds = ds.odc.mask(poly=geopolygon)\n\n    return ds, items\n</code></pre>"},{"location":"api/#eo_tides.stac.stac_load(product)","title":"<code>product</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(bands)","title":"<code>bands</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(time)","title":"<code>time</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(lon)","title":"<code>lon</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(lat)","title":"<code>lat</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(bbox)","title":"<code>bbox</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(geopolygon)","title":"<code>geopolygon</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(mask_geopolygon)","title":"<code>mask_geopolygon</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(stac_query)","title":"<code>stac_query</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(stac_url)","title":"<code>stac_url</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(dtype)","title":"<code>dtype</code>","text":""},{"location":"api/#eo_tides.stac.stac_load(**load_params)","title":"<code>**load_params</code>","text":""},{"location":"api/#eo_tides.utils","title":"eo_tides.utils","text":"<p>General-purpose utilities for tide model setup and data processing.</p> <p>This module includes tools for listing and clipping model files, performing spatial interpolation, and other helper tools used across the eo_tides package.</p> <p>Functions:</p> Name Description <code>clip_models</code> <p>Clip NetCDF-format ocean tide models to a bounding box.</p> <code>idw</code> <p>Perform Inverse Distance Weighting (IDW) interpolation.</p> <code>list_models</code> <p>List all tide models available for tide modelling.</p>"},{"location":"api/#eo_tides.utils.clip_models","title":"clip_models","text":"<pre><code>clip_models(\n    input_directory,\n    output_directory,\n    bbox,\n    model=None,\n    buffer=5,\n    overwrite=False,\n)\n</code></pre> <p>Clip NetCDF-format ocean tide models to a bounding box.</p> <p>This function identifies all NetCDF-format tide models in a given input directory, including \"ATLAS-netcdf\" (e.g. TPXO9-atlas-nc), \"FES-netcdf\" (e.g. FES2022, EOT20), and \"GOT-netcdf\" (e.g. GOT5.5) format files. Files for each model are then clipped to the extent of the provided bounding box, handling model-specific file structures. After each model is clipped, the result is exported to the output directory and verified with <code>pyTMD</code> to ensure the clipped data is suitable for tide modelling.</p> <p>For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>str or PathLike</code> <p>Path to directory containing input NetCDF-format tide model files.</p> required <code>str or PathLike</code> <p>Path to directory where clipped NetCDF files will be exported.</p> required <code>tuple of float</code> <p>Bounding box for clipping the tide models in EPSG:4326 degrees coordinates, specified as <code>(left, bottom, right, top)</code>.</p> required <code>str or list of str</code> <p>The tide model (or models) to clip. Defaults to None, which will automatically identify and clip all NetCDF-format models in the input directly.</p> <code>None</code> <code>float</code> <p>Buffer distance (in degrees) added to the bounding box to provide sufficient data on edges of study area. Defaults to 5 degrees.</p> <code>5</code> <code>bool</code> <p>If True, overwrite existing files in the output directory. Defaults to False.</p> <code>False</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; clip_models(\n...     input_directory=\"tide_models/\",\n...     output_directory=\"tide_models_clipped/\",\n...     bbox=(-8.968392, 50.070574, 2.447160, 59.367122),\n... )\n</code></pre> Source code in <code>eo_tides/utils.py</code> <pre><code>def clip_models(\n    input_directory: str | os.PathLike,\n    output_directory: str | os.PathLike,\n    bbox: tuple[float, float, float, float],\n    model: list | None = None,\n    buffer: float = 5,\n    overwrite: bool = False,\n) -&gt; None:\n    \"\"\"Clip NetCDF-format ocean tide models to a bounding box.\n\n    This function identifies all NetCDF-format tide models in a\n    given input directory, including \"ATLAS-netcdf\" (e.g. TPXO9-atlas-nc),\n    \"FES-netcdf\" (e.g. FES2022, EOT20), and \"GOT-netcdf\" (e.g. GOT5.5)\n    format files. Files for each model are then clipped to the extent of\n    the provided bounding box, handling model-specific file structures.\n    After each model is clipped, the result is exported to the output\n    directory and verified with `pyTMD` to ensure the clipped data is\n    suitable for tide modelling.\n\n    For tide model setup instructions, refer to the guide:\n    https://geoscienceaustralia.github.io/eo-tides/setup/\n\n    Parameters\n    ----------\n    input_directory : str or os.PathLike\n        Path to directory containing input NetCDF-format tide model files.\n    output_directory : str or os.PathLike\n        Path to directory where clipped NetCDF files will be exported.\n    bbox : tuple of float\n        Bounding box for clipping the tide models in EPSG:4326 degrees\n        coordinates, specified as `(left, bottom, right, top)`.\n    model : str or list of str, optional\n        The tide model (or models) to clip. Defaults to None, which\n        will automatically identify and clip all NetCDF-format models\n        in the input directly.\n    buffer : float, optional\n        Buffer distance (in degrees) added to the bounding box to provide\n        sufficient data on edges of study area. Defaults to 5 degrees.\n    overwrite : bool, optional\n        If True, overwrite existing files in the output directory.\n        Defaults to False.\n\n    Examples\n    --------\n    &gt;&gt;&gt; clip_models(\n    ...     input_directory=\"tide_models/\",\n    ...     output_directory=\"tide_models_clipped/\",\n    ...     bbox=(-8.968392, 50.070574, 2.447160, 59.367122),\n    ... )\n\n    \"\"\"\n    # Get input and output paths\n    input_directory = _set_directory(input_directory)\n    output_directory = pathlib.Path(output_directory)\n\n    # Prepare bounding box\n    bbox = odc.geo.geom.BoundingBox(*bbox, crs=\"EPSG:4326\").buffered(buffer)\n\n    # Identify NetCDF models\n    model_database = load_database()[\"elevation\"]\n    netcdf_formats = [\"ATLAS-netcdf\", \"FES-netcdf\", \"GOT-netcdf\"]\n    netcdf_models = {k for k, v in model_database.items() if v[\"format\"] in netcdf_formats}\n\n    # Identify subset of available and requested NetCDF models\n    available_models, _ = list_models(directory=input_directory, show_available=False, show_supported=False)\n    requested_models = list(np.atleast_1d(model)) if model is not None else available_models\n    available_netcdf_models = list(set(available_models) &amp; set(requested_models) &amp; set(netcdf_models))\n\n    # Raise error if no valid models found\n    if len(available_netcdf_models) == 0:\n        err_msg = f\"No valid NetCDF models found in {input_directory}.\"\n        raise ValueError(err_msg)\n\n    # If model list is provided,\n    print(f\"Preparing to clip suitable NetCDF models: {available_netcdf_models}\\n\")\n\n    # Loop through suitable models and export\n    for m in available_netcdf_models:\n        # Get model file and grid file list if they exist\n        model_files = model_database[m].get(\"model_file\", [])\n        grid_file = model_database[m].get(\"grid_file\", [])\n\n        # Convert to list of strings and combine\n        model_files = model_files if isinstance(model_files, list) else [model_files]\n        grid_file = grid_file if isinstance(grid_file, list) else [grid_file]\n        all_files = model_files + grid_file\n\n        # Loop through each model file and clip\n        for file in tqdm(all_files, desc=f\"Clipping {m}\"):\n            # Skip if it exists in output directory\n            if (output_directory / file).exists() and not overwrite:\n                continue\n\n            # Load model file\n            nc = xr.open_mfdataset(input_directory / file)\n\n            # Open file and clip according to model\n            if m in (\n                \"GOT5.5\",\n                \"GOT5.5_load\",\n                \"GOT5.5_extrapolated\",\n                \"GOT5.5D\",\n                \"GOT5.5D_extrapolated\",\n                \"GOT5.6\",\n                \"GOT5.6_extrapolated\",\n            ):\n                nc_clipped = _clip_model_file(\n                    nc,\n                    bbox,\n                    xdim=\"lon\",\n                    ydim=\"lat\",\n                    ycoord=\"latitude\",\n                    xcoord=\"longitude\",\n                )\n\n            elif m in (\"HAMTIDE11\",):\n                nc_clipped = _clip_model_file(nc, bbox, xdim=\"LON\", ydim=\"LAT\", ycoord=\"LAT\", xcoord=\"LON\")\n\n            elif m in (\n                \"EOT20\",\n                \"EOT20_load\",\n                \"FES2012\",\n                \"FES2014\",\n                \"FES2014_extrapolated\",\n                \"FES2014_load\",\n                \"FES2022\",\n                \"FES2022_extrapolated\",\n                \"FES2022_load\",\n            ):\n                nc_clipped = _clip_model_file(nc, bbox, xdim=\"lon\", ydim=\"lat\", ycoord=\"lat\", xcoord=\"lon\")\n\n            elif m in (\n                \"TPXO8-atlas-nc\",\n                \"TPXO9-atlas-nc\",\n                \"TPXO9-atlas-v2-nc\",\n                \"TPXO9-atlas-v3-nc\",\n                \"TPXO9-atlas-v4-nc\",\n                \"TPXO9-atlas-v5-nc\",\n                \"TPXO10-atlas-v2-nc\",\n            ):\n                nc_clipped = _clip_model_file(\n                    nc,\n                    bbox,\n                    xdim=\"nx\",\n                    ydim=\"ny\",\n                    ycoord=\"lat_z\",\n                    xcoord=\"lon_z\",\n                )\n\n            else:\n                err_msg = f\"Model {m} not supported\"\n                raise Exception(err_msg)\n\n            # Create directory and export\n            (output_directory / file).parent.mkdir(parents=True, exist_ok=True)\n            nc_clipped.to_netcdf(output_directory / file, mode=\"w\")\n\n        # Verify that models are ready\n        if pyTMD.io.model(directory=output_directory).elevation(m=m).verify:\n            print(\" \u2705 Clipped model exported and verified\")\n        else:\n            print(\" \u274c Clipped model exported but unable to be verified\")\n\n    print(f\"\\nOutputs exported to {output_directory}\")\n    list_models(directory=output_directory, show_available=True, show_supported=False)\n</code></pre>"},{"location":"api/#eo_tides.utils.clip_models(input_directory)","title":"<code>input_directory</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(output_directory)","title":"<code>output_directory</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(bbox)","title":"<code>bbox</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(model)","title":"<code>model</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(buffer)","title":"<code>buffer</code>","text":""},{"location":"api/#eo_tides.utils.clip_models(overwrite)","title":"<code>overwrite</code>","text":""},{"location":"api/#eo_tides.utils.idw","title":"idw","text":"<pre><code>idw(\n    input_z,\n    input_x,\n    input_y,\n    output_x,\n    output_y,\n    p=1,\n    k=10,\n    max_dist=None,\n    k_min=1,\n    epsilon=1e-12,\n)\n</code></pre> <p>Perform Inverse Distance Weighting (IDW) interpolation.</p> <p>This function performs fast IDW interpolation by creating a KDTree from the input coordinates then uses it to find the <code>k</code> nearest neighbors for each output point. Weights are calculated based on the inverse distance to each neighbor, with weights decreasing with increasing distance.</p> <p>Code inspired by: https://github.com/DahnJ/REM-xarray</p> <p>Parameters:</p> Name Type Description Default <code>array - like</code> <p>Array of values at the input points. This can be either a 1-dimensional array, or a 2-dimensional array where each column (axis=1) represents a different set of values to be interpolated.</p> required <code>array - like</code> <p>Array of x-coordinates of the input points.</p> required <code>array - like</code> <p>Array of y-coordinates of the input points.</p> required <code>array - like</code> <p>Array of x-coordinates where the interpolation is to be computed.</p> required <code>array - like</code> <p>Array of y-coordinates where the interpolation is to be computed.</p> required <code>int or float</code> <p>Power function parameter defining how rapidly weightings should decrease as distance increases. Higher values of <code>p</code> will cause weights for distant points to decrease rapidly, resulting in nearby points having more influence on predictions. Defaults to 1.</p> <code>1</code> <code>int</code> <p>Number of nearest neighbors to use for interpolation. <code>k=1</code> is equivalent to \"nearest\" neighbour interpolation. Defaults to 10.</p> <code>10</code> <code>int or float</code> <p>Restrict neighbouring points to less than this distance. By default, no distance limit is applied.</p> <code>None</code> <code>int</code> <p>If <code>max_dist</code> is provided, some points may end up with less than <code>k</code> nearest neighbours, potentially producing less reliable interpolations. Set <code>k_min</code> to set any points with less than <code>k_min</code> neighbours to NaN. Defaults to 1.</p> <code>1</code> <code>float</code> <p>Small value added to distances to prevent division by zero errors in the case that output coordinates are identical to input coordinates. Defaults to 1e-12.</p> <code>1e-12</code> <p>Returns:</p> Name Type Description <code>interp_values</code> <code>ndarray</code> <p>Interpolated values at the output coordinates. If <code>input_z</code> is 1-dimensional, <code>interp_values</code> will also be 1-dimensional. If <code>input_z</code> is 2-dimensional, <code>interp_values</code> will have the same number of rows as <code>input_z</code>, with each column (axis=1) representing interpolated values for one set of input data.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; input_z = [1, 2, 3, 4, 5]\n&gt;&gt;&gt; input_x = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; input_y = [0, 1, 2, 3, 4]\n&gt;&gt;&gt; output_x = [0.5, 1.5, 2.5]\n&gt;&gt;&gt; output_y = [0.5, 1.5, 2.5]\n&gt;&gt;&gt; idw(input_z, input_x, input_y, output_x, output_y, k=2)\narray([1.5, 2.5, 3.5])\n</code></pre> Source code in <code>eo_tides/utils.py</code> <pre><code>def idw(\n    input_z,\n    input_x,\n    input_y,\n    output_x,\n    output_y,\n    p=1,\n    k=10,\n    max_dist=None,\n    k_min=1,\n    epsilon=1e-12,\n):\n    \"\"\"Perform Inverse Distance Weighting (IDW) interpolation.\n\n    This function performs fast IDW interpolation by creating a KDTree\n    from the input coordinates then uses it to find the `k` nearest\n    neighbors for each output point. Weights are calculated based on the\n    inverse distance to each neighbor, with weights decreasing with\n    increasing distance.\n\n    Code inspired by: &lt;https://github.com/DahnJ/REM-xarray&gt;\n\n    Parameters\n    ----------\n    input_z : array-like\n        Array of values at the input points. This can be either a\n        1-dimensional array, or a 2-dimensional array where each column\n        (axis=1) represents a different set of values to be interpolated.\n    input_x : array-like\n        Array of x-coordinates of the input points.\n    input_y : array-like\n        Array of y-coordinates of the input points.\n    output_x : array-like\n        Array of x-coordinates where the interpolation is to be computed.\n    output_y : array-like\n        Array of y-coordinates where the interpolation is to be computed.\n    p : int or float, optional\n        Power function parameter defining how rapidly weightings should\n        decrease as distance increases. Higher values of `p` will cause\n        weights for distant points to decrease rapidly, resulting in\n        nearby points having more influence on predictions. Defaults to 1.\n    k : int, optional\n        Number of nearest neighbors to use for interpolation. `k=1` is\n        equivalent to \"nearest\" neighbour interpolation. Defaults to 10.\n    max_dist : int or float, optional\n        Restrict neighbouring points to less than this distance.\n        By default, no distance limit is applied.\n    k_min : int, optional\n        If `max_dist` is provided, some points may end up with less than\n        `k` nearest neighbours, potentially producing less reliable\n        interpolations. Set `k_min` to set any points with less than\n        `k_min` neighbours to NaN. Defaults to 1.\n    epsilon : float, optional\n        Small value added to distances to prevent division by zero\n        errors in the case that output coordinates are identical to\n        input coordinates. Defaults to 1e-12.\n\n    Returns\n    -------\n    interp_values : numpy.ndarray\n        Interpolated values at the output coordinates. If `input_z` is\n        1-dimensional, `interp_values` will also be 1-dimensional. If\n        `input_z` is 2-dimensional, `interp_values` will have the same\n        number of rows as `input_z`, with each column (axis=1)\n        representing interpolated values for one set of input data.\n\n    Examples\n    --------\n    &gt;&gt;&gt; input_z = [1, 2, 3, 4, 5]\n    &gt;&gt;&gt; input_x = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; input_y = [0, 1, 2, 3, 4]\n    &gt;&gt;&gt; output_x = [0.5, 1.5, 2.5]\n    &gt;&gt;&gt; output_y = [0.5, 1.5, 2.5]\n    &gt;&gt;&gt; idw(input_z, input_x, input_y, output_x, output_y, k=2)\n    array([1.5, 2.5, 3.5])\n\n    \"\"\"\n    # Convert to numpy arrays\n    input_x = np.atleast_1d(input_x)\n    input_y = np.atleast_1d(input_y)\n    input_z = np.atleast_1d(input_z)\n    output_x = np.atleast_1d(output_x)\n    output_y = np.atleast_1d(output_y)\n\n    # Verify input and outputs have matching lengths\n    if not (input_z.shape[0] == len(input_x) == len(input_y)):\n        err_msg = \"All of `input_z`, `input_x` and `input_y` must be the same length.\"\n        raise ValueError(err_msg)\n    if len(output_x) != len(output_y):\n        err_msg = \"Both `output_x` and `output_y` must be the same length.\"\n        raise ValueError(err_msg)\n\n    # Verify k is smaller than total number of points, and non-zero\n    if k &gt; input_z.shape[0]:\n        err_msg = (\n            f\"The requested number of nearest neighbours (`k={k}`) \"\n            f\"is smaller than the total number of points ({input_z.shape[0]}).\",\n        )\n        raise ValueError(err_msg)\n    if k == 0:\n        err_msg = \"Interpolation based on `k=0` nearest neighbours is not valid.\"\n        raise ValueError(err_msg)\n\n    # Create KDTree to efficiently find nearest neighbours\n    points_xy = np.column_stack((input_y, input_x))\n    tree = KDTree(points_xy)\n\n    # Determine nearest neighbours and distances to each\n    grid_stacked = np.column_stack((output_y, output_x))\n    distances, indices = tree.query(grid_stacked, k=k, workers=-1)\n\n    # If k == 1, add an additional axis for consistency\n    if k == 1:\n        distances = distances[..., np.newaxis]\n        indices = indices[..., np.newaxis]\n\n    # Add small epsilon to distances to prevent division by zero errors\n    # if output coordinates are the same as input coordinates\n    distances = np.maximum(distances, epsilon)\n\n    # Set distances above max to NaN if specified\n    if max_dist is not None:\n        distances[distances &gt; max_dist] = np.nan\n\n    # Calculate weights based on distance to k nearest neighbours.\n    weights = 1 / np.power(distances, p)\n    weights = weights / np.nansum(weights, axis=1).reshape(-1, 1)\n\n    # 1D case: Compute weighted sum of input_z values for each output point\n    if input_z.ndim == 1:\n        interp_values = np.nansum(weights * input_z[indices], axis=1)\n\n    # 2D case: Compute weighted sum for each set of input_z values\n    # weights[..., np.newaxis] adds a dimension for broadcasting\n    else:\n        interp_values = np.nansum(\n            weights[..., np.newaxis] * input_z[indices],\n            axis=1,\n        )\n\n    # Set any points with less than `k_min` valid weights to NaN\n    interp_values[np.isfinite(weights).sum(axis=1) &lt; k_min] = np.nan\n\n    return interp_values\n</code></pre>"},{"location":"api/#eo_tides.utils.idw(input_z)","title":"<code>input_z</code>","text":""},{"location":"api/#eo_tides.utils.idw(input_x)","title":"<code>input_x</code>","text":""},{"location":"api/#eo_tides.utils.idw(input_y)","title":"<code>input_y</code>","text":""},{"location":"api/#eo_tides.utils.idw(output_x)","title":"<code>output_x</code>","text":""},{"location":"api/#eo_tides.utils.idw(output_y)","title":"<code>output_y</code>","text":""},{"location":"api/#eo_tides.utils.idw(p)","title":"<code>p</code>","text":""},{"location":"api/#eo_tides.utils.idw(k)","title":"<code>k</code>","text":""},{"location":"api/#eo_tides.utils.idw(max_dist)","title":"<code>max_dist</code>","text":""},{"location":"api/#eo_tides.utils.idw(k_min)","title":"<code>k_min</code>","text":""},{"location":"api/#eo_tides.utils.idw(epsilon)","title":"<code>epsilon</code>","text":""},{"location":"api/#eo_tides.utils.list_models","title":"list_models","text":"<pre><code>list_models(\n    directory=None,\n    show_available=True,\n    show_supported=True,\n    raise_error=False,\n    extra_databases=None,\n)\n</code></pre> <p>List all tide models available for tide modelling.</p> <p>This function scans the specified tide model directory and returns a list of models that are available in the directory as well as the full list of all models supported by <code>eo-tides</code> and <code>pyTMD</code>.</p> <p>For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/</p> <p>Parameters:</p> Name Type Description Default <code>str</code> <p>The directory containing tide model data files. If no path is provided, this will default to the environment variable <code>EO_TIDES_TIDE_MODELS</code> if set, or raise an error if not. Tide modelling files should be stored in sub-folders for each model that match the structure required by <code>pyTMD</code> (https://geoscienceaustralia.github.io/eo-tides/setup/).</p> <code>None</code> <code>bool</code> <p>Whether to print a list of locally available models.</p> <code>True</code> <code>bool</code> <p>Whether to print a list of all supported models, in addition to models available locally.</p> <code>True</code> <code>bool</code> <p>If True, raise an error if no available models are found. If False, raise a warning.</p> <code>False</code> <code>str or path or list</code> <p>Additional custom tide model definitions to load, provided as dictionaries or paths to JSON database files. Use this to enable custom tide models not included with <code>pyTMD</code>. See: https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#model-database</p> <code>None</code> <p>Returns:</p> Name Type Description <code>available_models</code> <code>list of str</code> <p>A list of all tide models available within <code>directory</code>.</p> <code>supported_models</code> <code>list of str</code> <p>A list of all tide models supported by <code>eo-tides</code>.</p> Source code in <code>eo_tides/utils.py</code> <pre><code>def list_models(\n    directory: str | os.PathLike | None = None,\n    show_available: bool = True,\n    show_supported: bool = True,\n    raise_error: bool = False,\n    extra_databases: str | os.PathLike | list | None = None,\n) -&gt; tuple[list[str], list[str]]:\n    \"\"\"List all tide models available for tide modelling.\n\n    This function scans the specified tide model directory\n    and returns a list of models that are available in the\n    directory as well as the full list of all models supported\n    by `eo-tides` and `pyTMD`.\n\n    For tide model setup instructions, refer to the guide:\n    https://geoscienceaustralia.github.io/eo-tides/setup/\n\n    Parameters\n    ----------\n    directory : str, optional\n        The directory containing tide model data files. If no path is\n        provided, this will default to the environment variable\n        `EO_TIDES_TIDE_MODELS` if set, or raise an error if not.\n        Tide modelling files should be stored in sub-folders for each\n        model that match the structure required by `pyTMD`\n        (&lt;https://geoscienceaustralia.github.io/eo-tides/setup/&gt;).\n    show_available : bool, optional\n        Whether to print a list of locally available models.\n    show_supported : bool, optional\n        Whether to print a list of all supported models, in\n        addition to models available locally.\n    raise_error : bool, optional\n        If True, raise an error if no available models are found.\n        If False, raise a warning.\n    extra_databases : str or path or list, optional\n        Additional custom tide model definitions to load, provided as\n        dictionaries or paths to JSON database files. Use this to\n        enable custom tide models not included with `pyTMD`.\n        See: https://pytmd.readthedocs.io/en/latest/getting_started/Getting-Started.html#model-database\n\n    Returns\n    -------\n    available_models : list of str\n        A list of all tide models available within `directory`.\n    supported_models : list of str\n        A list of all tide models supported by `eo-tides`.\n\n    \"\"\"\n    init()  # Initialize colorama\n\n    # Set tide modelling files directory. If no custom path is\n    # provided, try global environment variable.\n    directory = _set_directory(directory)\n\n    # Load supported models from pyTMD database, adding extras if required\n    extra_databases = [] if extra_databases is None else extra_databases\n    model_database = load_database(extra_databases=extra_databases)[\"elevation\"]\n\n    # Get full list of supported models\n    supported_models = list(model_database.keys())\n\n    # Extract expected model paths\n    expected_paths = {}\n    for m in supported_models:\n        model_file = model_database[m][\"model_file\"]\n\n        # Handle GOT5.6 differently to ensure we test for presence of GOT5.6 constituents\n        if m in (\"GOT5.6\", \"GOT5.6_extrapolated\"):\n            model_file = next(file for file in model_file if \"GOT5.6\" in file)\n        else:\n            model_file = model_file[0] if isinstance(model_file, list) else model_file\n\n        # Add expected path to dict, adding directory prefix\n        expected_paths[m] = str(directory / pathlib.Path(model_file).expanduser().parent)\n\n    # Define column widths\n    status_width = 4  # Width for emoji\n    name_width = max(len(name) for name in supported_models)\n    path_width = max(len(path) for path in expected_paths.values())\n\n    # Print list of supported models, marking available and\n    # unavailable models and appending available to list\n    if show_available or show_supported:\n        total_width = min(status_width + name_width + path_width + 6, 80)\n        print(\"\u2500\" * total_width)\n        print(f\"{'\udb40\udc20\ud83c\udf0a':^{status_width}} | {'Model':&lt;{name_width}} | {'Expected path':&lt;{path_width}}\")\n        print(\"\u2500\" * total_width)\n\n    available_models = []\n    for m in supported_models:\n        try:\n            # Load model\n            model_file = pyTMD.io.model(directory=directory, extra_databases=extra_databases).elevation(m=m)\n\n            # Append model to list of available model\n            available_models.append(m)\n\n            if show_available:\n                # Mark available models with a green tick\n                status = \"\u2705\"\n                print(f\"{status:^{status_width}}\u2502 {m:&lt;{name_width}} \u2502 {expected_paths[m]:&lt;{path_width}}\")\n        except FileNotFoundError:  # noqa: PERF203\n            if show_supported:\n                # Mark unavailable models with a red cross\n                status = \"\u274c\"\n                print(\n                    f\"{status:^{status_width}}\u2502 {Style.DIM}{m:&lt;{name_width}} \u2502 {expected_paths[m]:&lt;{path_width}}{Style.RESET_ALL}\",\n                )\n\n    if show_available or show_supported:\n        print(\"\u2500\" * total_width)\n\n        # Print summary\n        print(f\"\\n{Style.BRIGHT}Summary:{Style.RESET_ALL}\")\n        print(f\"Available models: {len(available_models)}/{len(supported_models)}\")\n\n    # Raise error or warning if no models are available\n    if not available_models:\n        warning_msg = textwrap.dedent(\n            f\"\"\"\n            No valid tide models were found in `{directory}`.\n            Please ensure that the path you provided is correct, or set the `EO_TIDES_TIDE_MODELS` environment variable to point to a valid tide model directory.\n            For tide model setup instructions, refer to the guide: https://geoscienceaustralia.github.io/eo-tides/setup/\n            \"\"\",\n        ).strip()\n\n        if raise_error:\n            raise Exception(warning_msg) from None\n        warnings.warn(warning_msg, UserWarning, stacklevel=2)\n\n    # Return list of available and supported models\n    return available_models, supported_models\n</code></pre>"},{"location":"api/#eo_tides.utils.list_models(directory)","title":"<code>directory</code>","text":""},{"location":"api/#eo_tides.utils.list_models(show_available)","title":"<code>show_available</code>","text":""},{"location":"api/#eo_tides.utils.list_models(show_supported)","title":"<code>show_supported</code>","text":""},{"location":"api/#eo_tides.utils.list_models(raise_error)","title":"<code>raise_error</code>","text":""},{"location":"api/#eo_tides.utils.list_models(extra_databases)","title":"<code>extra_databases</code>","text":""},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#0101-2025-10-22","title":"0.10.1 - 2025-10-22","text":""},{"location":"changelog/#whats-changed","title":"What's Changed","text":"<ul> <li>Only include Python code in build to reduce package size by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/137</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.10.0...0.10.1</p>"},{"location":"changelog/#0100-2025-10-20","title":"0.10.0 - 2025-10-20","text":""},{"location":"changelog/#whats-changed_1","title":"What's Changed","text":"<ul> <li>Add new <code>tag_timeseries</code> function for tagging satellite data with external timeseries data. This function is designed to take a 1D timeseries of tide heights or water levels, and map these back to each satellite observation timestep. This can be used to tag satellite data with observed tides, instead of tides modelled using global tide models. https://github.com/GeoscienceAustralia/eo-tides/pull/134</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.9.2...0.10.0</p>"},{"location":"changelog/#092-2025-10-07","title":"0.9.2 - 2025-10-07","text":""},{"location":"changelog/#whats-changed_2","title":"What's Changed","text":"<ul> <li>Update validation code and notebook examples in https://github.com/GeoscienceAustralia/eo-tides/pull/132</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.9.1...0.9.2</p>"},{"location":"changelog/#091-2025-10-02","title":"0.9.1 - 2025-10-02","text":""},{"location":"changelog/#whats-changed_3","title":"What's Changed","text":"<ul> <li>Move STAC loading package dependencies to default requirements in https://github.com/GeoscienceAustralia/eo-tides/pull/130</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.9.0...0.9.1</p>"},{"location":"changelog/#090-2025-10-01","title":"0.9.0 - 2025-10-01","text":""},{"location":"changelog/#whats-changed_4","title":"What's Changed","text":"<p>This release adds new functionality for loading satellite data using STAC metadata, and for ranking tide model performance based on their correlation with satell-observed patterns of inundation. For more information, see:</p> <ul> <li>https://geoscienceaustralia.github.io/eo-tides/api/#eo_tides.validation.tide_correlation</li> <li>https://geoscienceaustralia.github.io/eo-tides/api/#eo_tides.stac.stac_load</li> <li>https://geoscienceaustralia.github.io/eo-tides/api/#eo_tides.stac.load_ndwi_mpc</li> </ul> <p>Jupyter Notebook example: https://geoscienceaustralia.github.io/eo-tides/notebooks/Validating_tides/#tide-correlation-model-rankings</p>"},{"location":"changelog/#new-features","title":"New features","text":"<ul> <li>Add NDWI-tide correlation function and STAC data loading tools in https://github.com/GeoscienceAustralia/eo-tides/pull/87</li> <li>Support STAC loading data by bounding box, geopolygon, Shapely, GeoPandas, GeoJSON in https://github.com/GeoscienceAustralia/eo-tides/pull/126</li> <li>Update tide correlation code, add support for masking to STAC functions by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/128</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.8.3...0.9.0</p>"},{"location":"changelog/#083-2025-09-16","title":"0.8.3 - 2025-09-16","text":""},{"location":"changelog/#whats-changed_5","title":"What's Changed","text":""},{"location":"changelog/#new-features_1","title":"New features","text":"<ul> <li>Add support for GESLA 4 tide gauge dataset in <code>validation.py</code> by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/123</li> </ul>"},{"location":"changelog/#other-changes","title":"Other changes","text":"<ul> <li>Minor fix to validation error format by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/121</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.8.2...0.8.3</p>"},{"location":"changelog/#082-2025-08-18","title":"0.8.2 - 2025-08-18","text":""},{"location":"changelog/#whats-changed_6","title":"What's Changed","text":""},{"location":"changelog/#breaking-changes","title":"Breaking changes","text":"<ul> <li>Refactor <code>tide_aliasing</code> function to use <code>constituent</code> param name instead of <code>c</code>, use a list of default major tide constituents from <code>pyTMD</code>, remove \"type\" column, and set a 10 year default max on period values by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/118</li> </ul>"},{"location":"changelog/#bug-fixes","title":"Bug fixes","text":"<ul> <li>Fix bug with specifying custom list of constituents in #117 by upgrading <code>pyTMD</code></li> </ul>"},{"location":"changelog/#other-changes_1","title":"Other changes","text":"<ul> <li>Add spell check to pre-commit, minor formatting updates by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/116</li> <li>Minor updates and upgrades to tests and <code>ruff</code>, <code>uv</code> versions by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/118</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.8.1...0.8.2</p>"},{"location":"changelog/#081-2025-07-17","title":"0.8.1 - 2025-07-17","text":""},{"location":"changelog/#whats-changed_7","title":"What's Changed","text":""},{"location":"changelog/#other-changes_2","title":"Other changes","text":"<ul> <li>Add new EO satellite tide aliasing function for evaluating potential temporal biases in EO analyses in https://github.com/GeoscienceAustralia/eo-tides/pull/113</li> <li>Add <code>jupyter</code> to notebook optional dependencies to make Jupyter Notebooks easier to run in https://github.com/GeoscienceAustralia/eo-tides/pull/112</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.8.0...0.8.1</p>"},{"location":"changelog/#080-2025-06-24","title":"0.8.0 - 2025-06-24","text":""},{"location":"changelog/#whats-changed_8","title":"What's Changed","text":"<p>This release provides new functionality to customise tide modelling:</p> <ol> <li>A new <code>extra_databases</code> parameter to model tides using models that are not natively supported by <code>pyTMD</code>, accepting custom tide model databases in either Python dictionary or JSON file format</li> <li>A new <code>constituents</code> parameter to restrict tide modelling to a custom subset of harmonic constituents</li> </ol> <p>For example, to model tides using a custom <code>EOT20_custom</code> tide model:</p> <pre><code>import pandas as pd\nfrom eo_tides.model import model_tides\n\ncustom_db_dict = {\n  \"elevation\": {\n    \"EOT20_custom\": {\n      \"format\": \"FES-netcdf\",\n      \"model_file\": [\n        \"EOT20/ocean_tides/2N2_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/J1_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/K1_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/K2_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/M2_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/M4_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/MF_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/MM_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/N2_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/O1_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/P1_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/Q1_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/S1_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/S2_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/SA_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/SSA_ocean_eot20.nc\",\n        \"EOT20/ocean_tides/T2_ocean_eot20.nc\"\n      ],\n      \"name\": \"EOT20_custom\",\n      \"reference\": \"https://doi.org/10.17882/79489\",\n      \"scale\": 0.01,\n      \"type\": \"z\",\n      \"variable\": \"tide_ocean\",\n      \"version\": \"EOT20\"\n    }\n  }\n}\n\nmodel_tides(\n    x=148,\n    y=-16,\n    time=pd.date_range(\"2022-01-01\", \"2023-12-31\", freq=\"1h\"),\n    model=[\"EOT20_custom\", \"EOT20\"],\n    directory=\"/var/share/tide_models/\",\n    extra_databases=custom_db_dict,\n    output_format=\"wide\",\n)\n</code></pre>"},{"location":"changelog/#new-features_2","title":"New features","text":"<ul> <li>Support custom tide models by passing in extra tide model databases by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/105</li> <li>Support customising constituents during tide modelling by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/108</li> </ul>"},{"location":"changelog/#other-changes_3","title":"Other changes","text":"<ul> <li>Major Ruff refactor by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/108</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.7.5...0.8.0</p>"},{"location":"changelog/#075-2025-06-23","title":"0.7.5 - 2025-06-23","text":""},{"location":"changelog/#whats-changed_9","title":"What's Changed","text":"<p>Minor update to remove Dask pin now that Dask compatability issue has been solved in <code>odc-stac</code></p>"},{"location":"changelog/#documentation-updates","title":"Documentation updates","text":"<ul> <li>Fix unlinked URLs in changelog by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/103</li> </ul>"},{"location":"changelog/#other-changes_4","title":"Other changes","text":"<ul> <li>Remove dask pin to close #76 by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/106</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.7.4...0.7.5</p>"},{"location":"changelog/#074-2025-05-30","title":"0.7.4 - 2025-05-30","text":""},{"location":"changelog/#whats-changed_10","title":"What's Changed","text":""},{"location":"changelog/#new-features_3","title":"New features","text":"<ul> <li>Add version attribute to init file by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/98</li> </ul>"},{"location":"changelog/#documentation-updates_1","title":"Documentation updates","text":"<ul> <li>Fix capitalisation in JOSS paper bibliography by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/97</li> <li>Update suggested citation to use new JOSS paper citation by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/100</li> </ul>"},{"location":"changelog/#other-changes_5","title":"Other changes","text":"<ul> <li>Update PR labelling and release template by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/99</li> <li>Reformat code with additional <code>ruff</code> linting rules by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/101</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@github-actions made their first contribution in https://github.com/GeoscienceAustralia/eo-tides/pull/96</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.7.3...0.7.4</p>"},{"location":"changelog/#073-2025-05-22","title":"0.7.3 - 2025-05-22","text":""},{"location":"changelog/#changes","title":"Changes","text":"<ul> <li>Use dynamic version handling via <code>hatch-vcs</code>, add automatic changelog update action by @robbibt in https://github.com/GeoscienceAustralia/eo-tides/pull/95</li> <li>Bump the python-deps group with 2 updates by @dependabot in https://github.com/GeoscienceAustralia/eo-tides/pull/94</li> </ul> <p>Full Changelog: https://github.com/GeoscienceAustralia/eo-tides/compare/0.7.2...0.7.3</p>"},{"location":"changelog/#072-2025-05-19","title":"0.7.2 - 2025-05-19","text":""},{"location":"changelog/#new-features_4","title":"New features","text":"<ul> <li>Minor updates to improve documentation around accessing GESLA 3.0 tide gauge data,</li> <li>Made validation functions more re-usable by removing hard-coded paths and adding helpful error messages.</li> </ul>"},{"location":"changelog/#071-2025-05-19","title":"0.7.1 - 2025-05-19","text":"<p>Minor update to package dependencies</p>"},{"location":"changelog/#070-2025-05-14","title":"0.7.0 - 2025-05-14","text":""},{"location":"changelog/#new-features_5","title":"New features","text":"<ul> <li>This version corresponds to the code archived as part of Journal of Open Source Software publication.   No new features introduced.</li> </ul>"},{"location":"changelog/#065-2025-05-08","title":"0.6.5 - 2025-05-08","text":""},{"location":"changelog/#new-features_6","title":"New features","text":"<ul> <li>Support for <code>pyTMD</code> versions 2.2.3 and 2.2.4</li> </ul>"},{"location":"changelog/#064-2025-02-31","title":"0.6.4 - 2025-02-31","text":""},{"location":"changelog/#new-features_7","title":"New features","text":"<ul> <li>Updated installation documentation to improve reproducibility</li> </ul>"},{"location":"changelog/#bug-fixes_1","title":"Bug fixes","text":"<ul> <li>Temporarily pinned Dask to avoid <code>odc-geo</code> and <code>odc-stac</code> errors</li> </ul>"},{"location":"changelog/#063-2025-03-20","title":"0.6.3 - 2025-03-20","text":""},{"location":"changelog/#new-features_8","title":"New features","text":"<ul> <li>Major updates to installation and setup documentation, to provide additional context about tide modelling data and installing <code>eo-tides</code> using both <code>pip</code> and <code>uv</code></li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"Bug fixes","text":"<ul> <li>Fixed bug where ensemble tide modelling used excessive memory, by ensuring dtype of ensemble modelled tides matches dtype of input modelled tides (#70)</li> <li>Added missing <code>dask</code> dependency to requirements (#68)</li> </ul>"},{"location":"changelog/#062-2025-02-25","title":"0.6.2 - 2025-02-25","text":""},{"location":"changelog/#new-features_9","title":"New features","text":"<ul> <li>Added <code>apply_node</code> parameteter to <code>model_tides</code> to apply <code>pyTMD</code>'s adjustments to harmonic constituents to allow for periodic modulations over the 18.6-year nodal period (lunar nodal tide). Default is False.</li> </ul>"},{"location":"changelog/#bug-fixes_3","title":"Bug fixes","text":"<ul> <li>Further fixes for bug causing tide model clipping with <code>clip_tides</code> to fail for bounding boxes completely west of the prime meridian (#50); default value for <code>crop</code> param is now <code>\"auto\"</code> instead of <code>True</code>.</li> </ul>"},{"location":"changelog/#061-2025-02-20","title":"0.6.1 - 2025-02-20","text":""},{"location":"changelog/#bug-fixes_4","title":"Bug fixes","text":"<ul> <li>Fixed bug causing tide model clipping with <code>clip_tides</code> to fail for bounding boxes completely west of the prime meridian (#50)</li> </ul>"},{"location":"changelog/#060-2025-02-11","title":"0.6.0 - 2025-02-11","text":""},{"location":"changelog/#new-features_10","title":"New features","text":"<ul> <li>Added <code>return_phases</code> parameter to <code>eo_tides.eo.tag_tides</code>, which will return a dataframe containing tide phase information for each satellite observation</li> <li>Added support for Technical University of Denmark tide models (DTU23)</li> <li>Minor docs improvements, updates for new FES2022 data format</li> </ul>"},{"location":"changelog/#050-2025-01-17","title":"0.5.0 - 2025-01-17","text":""},{"location":"changelog/#new-features_11","title":"New features","text":"<ul> <li>Added draft version of a Journal of Open Source Software paper</li> <li>Added benchmarking notebook that compares performance with parallelisation on and off</li> </ul>"},{"location":"changelog/#bug-fixes_5","title":"Bug fixes","text":"<ul> <li>Fix documentation to point to correct location of <code>list_models</code> function (e.g. <code>eo_tides.utils.list_models</code>)</li> </ul>"},{"location":"changelog/#breaking-changes_1","title":"Breaking changes","text":"<ul> <li>Removed Python 3.9 support</li> <li>Added Python 3.13 support</li> </ul>"},{"location":"changelog/#040-2025-12-21","title":"0.4.0 - 2025-12-21","text":""},{"location":"changelog/#new-features_12","title":"New features","text":"<ul> <li> <p>Publishes ensemble tide modelling code for combining multiple global ocean tide models into a single locally optimised ensemble tide model using external model ranking data (e.g. satellite altimetry or NDWI-tide correlations along the coastline).</p> </li> <li> <p>Update ensemble code to latest version that includes FES2022, GOT5.6 and TPXO10 tide models</p> </li> <li>Make ensemble model calculation function a top level function (i.e. rename from <code>_ensemble_model</code> to <code>ensemble_tides</code>)</li> <li> <p>Load tide model ranking points from external <code>flatgeobuf</code> format file for faster cloud access</p> </li> <li> <p>Major refactor to statistics functions to standardise code across both <code>pixel_stats</code> and <code>tide_stats</code> and add support for multiple models</p> </li> <li> <p><code>tide_stats</code> will now return a <code>pandas.Series</code> if one model is requested, and a <code>pandas.DataFrame</code> if multiple are requested</p> </li> <li> <p>Added a new <code>point_col</code> parameter to <code>tide_stats</code> to control the colour of plotted points. If <code>plot_var</code> is also provided, points will now be coloured differently by default.</p> </li> <li> <p>Added a new <code>crop_buffer</code> parameter to configure buffer distance when cropping model files with <code>crop=True</code> (defaults to 5 degrees)</p> </li> <li> <p>Reorder <code>model_tides</code> parameters to provide more logical flow and move more common params like <code>mode</code>, <code>output_format</code> and <code>output_units</code> higher</p> </li> </ul>"},{"location":"changelog/#bug-fixes_6","title":"Bug fixes","text":"<ul> <li>Fix warnings from <code>load_gauge_gesla</code> function</li> </ul>"},{"location":"changelog/#breaking-changes_2","title":"Breaking changes","text":"<ul> <li>The <code>plot_col</code> parameter from <code>tide_stats</code> has been renamed to <code>plot_var</code></li> </ul>"},{"location":"changelog/#031-2024-11-15","title":"0.3.1 - 2024-11-15","text":""},{"location":"changelog/#new-features_13","title":"New features","text":"<ul> <li>Add new \"all\" option to <code>model</code> param in <code>model_tides</code>, <code>pixel_tides</code> etc, which will model tides using all available tide models in your provided <code>directory</code>.</li> </ul>"},{"location":"changelog/#bug-fixes_7","title":"Bug fixes","text":"<ul> <li>Fix bug where GOT5.6 was not detected as a valid model because it contains files in multiple directories (e.g. both \"GOT5.6\" and \"GOT5.5\"). This also affected clipping GOT5.6 data using the <code>eo_tides.utils.clip_models</code> function.</li> </ul>"},{"location":"changelog/#030-2024-11-11","title":"0.3.0 - 2024-11-11","text":""},{"location":"changelog/#new-features_14","title":"New features","text":"<ul> <li>Added new <code>eo_tides.utils.clip_models</code> function for clipping tide models to a smaller spatial extent. This can have a major positive impact on performance, sometimes producing more than a 10 x speedup. This function identifies all NetCDF-format tide models in a given input directory, including \"ATLAS-netcdf\" (e.g. <code>TPXO9-atlas-nc</code>), \"FES-netcdf\" (e.g. <code>FES2022</code>, <code>EOT20</code>), and \"GOT-netcdf\" (e.g. <code>GOT5.5</code>) format files. Files for each model are then clipped to the extent of the provided bounding box, handling model-specific file structures. After each model is clipped, the result is exported to the output directory and verified with <code>pyTMD</code> to ensure the clipped data is suitable for tide modelling.</li> </ul>"},{"location":"changelog/#major-changes","title":"Major changes","text":"<ul> <li>The <code>parallel_splits</code> parameter that controls the number of chunks data is broken into for parallel analysis has been refactored to use a new default of \"auto\". This now attempts to automatically determine a sensible value based on available CPU, number of points, and number of models being run. All CPUs will be used where possible, unless this will produce splits with less than 1000 points in each (which would increase overhead). Parallel splits will be reduced if multiple models are requested, as these are run in parallel too and will compete for the same resources.</li> <li>Changed the default interpolation <code>method</code> from \"spline\" to \"linear\". This appears to produce the same results, but works considerably faster.</li> <li>Updates to enable correct cropping, recently resolved in PyTMD 2.1.8</li> </ul>"},{"location":"changelog/#breaking-changes_3","title":"Breaking changes","text":"<ul> <li>The <code>list_models</code> function has been relocated to <code>eo_tides.utils</code> (from <code>eo_tides.model</code>)</li> </ul>"},{"location":"changelog/#020-2024-10-30","title":"0.2.0 - 2024-10-30","text":""},{"location":"changelog/#new-features_15","title":"New features","text":"<ul> <li>New <code>model_phases</code> function for calculating tidal phases (\"low-flow\", high-flow\", \"high-ebb\", \"low-ebb\") for each tide height in a timeseries. Ebb and low phases are calculated by running the <code>eo_tides.model.model_tides</code> function twice, once for the requested timesteps, and again after subtracting a small time offset (by default, 15 minutes). If tides increased over this period, they are assigned as \"flow\"; if they decreased, they are assigned as \"ebb\". Tides are considered \"high\" if equal or greater than 0 metres tide height, otherwise \"low\".</li> <li>Major refactor to use consistent input parameters across all EO focused functions: input can now be either <code>xr.DataArray</code> or <code>xr.Dataset</code> or <code>odc.geo.geobox.GeoBox</code>; if an xarray object is passed, it must have a <code>\"time\"</code> dimension; if GeoBox is passed, time must be provided by the <code>time</code> parameter.</li> <li><code>time</code> parameters now accept any format that can be converted by <code>pandas.to_datetime()</code>; e.g. np.ndarray[datetime64], pd.DatetimeIndex, pd.Timestamp, datetime.datetime and strings (e.g. \"2020-01-01 23:00\").</li> <li><code>model_tides</code> now uses default cropping approach from <code>pyTMD</code>, rather than applying a bespoke 1 degree buffer around the selected analysis area</li> <li><code>model_tides</code> refactored to use simpler approach to loading tide consistuents enabled in <code>pyTMD==2.1.7</code></li> </ul>"},{"location":"changelog/#breaking-changes_4","title":"Breaking changes","text":"<ul> <li>The <code>ds</code> param in all satellite data functions (<code>tag_tides</code>, <code>pixel_tides</code>, <code>tide_stats</code>, <code>pixel_tides</code>) has been renamed to a more generic name <code>data</code> (to account for now accepting either <code>xarray.Dataset</code>, <code>xarray.DataArray</code> or a <code>odc.geo.geobox.GeoBox</code> inputs).</li> </ul>"},{"location":"changelog/#010-2024-10-18","title":"0.1.0 - 2024-10-18","text":""},{"location":"changelog/#new-features_16","title":"New features","text":"<ul> <li>Initial creation of <code>eo-tides</code> repo</li> </ul>"},{"location":"changelog/#breaking-changes_5","title":"Breaking changes","text":"<p>See Migrating from DEA Tools for a guide to updating your code from the original <code>Digital Earth Australia Notebooks and Tools</code> repository.</p>"},{"location":"credits/","title":"Citations and credits","text":""},{"location":"credits/#citing-eo-tides","title":"Citing <code>eo-tides</code>","text":"<p>To cite <code>eo-tides</code> in your work, please use the following Journal of Open Source Software citation:</p> Plain textBibTeX <pre><code>Bishop-Taylor, R., Phillips, C., Sagar, S., Newey, V., &amp; Sutterley, T., (2025). eo-tides: Tide modelling tools for large-scale satellite Earth observation analysis. Journal of Open Source Software, 10(109), 7786, https://doi.org/10.21105/joss.07786\n</code></pre> <pre><code>@article{Bishop-Taylor2025,\ndoi       = {10.21105/joss.07786},\nurl       = {https://doi.org/10.21105/joss.07786},\nyear      = {2025},\npublisher = {The Open Journal},\nvolume    = {10},\nnumber    = {109},\npages     = {7786},\nauthor    = {Robbi Bishop-Taylor and Claire Phillips and Stephen Sagar and Vanessa Newey and Tyler Sutterley},\ntitle     = {eo-tides: Tide modelling tools for large-scale satellite Earth observation analysis},\njournal   = {Journal of Open Source Software}\n}\n</code></pre> <p>In addition, please consider also citing the underlying <code>pyTMD</code> Python package which powers the tide modelling functionality behind <code>eo-tides</code>:</p> <pre><code>Sutterley, T. C., Alley, K., Brunt, K., Howard, S., Padman, L., Siegfried, M. (2017) pyTMD: Python-based tidal prediction software. 10.5281/zenodo.5555395\n</code></pre>"},{"location":"credits/#credits","title":"Credits","text":"<p><code>eo-tides</code> builds on (and wouldn't be possible without!) fundamental tide modelling tools provided by <code>pyTMD</code>. The authors wish to thank Dr. Tyler Sutterley for his ongoing development and support of this incredible modelling tool.</p> <p>Functions from <code>eo-tides</code> were originally developed in the <code>Digital Earth Australia Notebooks and Tools</code> repository. The authors would like to thank all DEA Notebooks contributors and maintainers for their invaluable assistance with code review, feature suggestions and code edits.</p> <p>FES Finite Element Solution tide models were developed, validated by the CTOH/LEGOS, France and distributed by Aviso+: https://www.aviso.altimetry.fr/en/data/products/sea-surface-height-products/regional/x-track-sla/x-track-l2p-sla-version-2022.html</p> <p>This repository was initialised using the <code>cookiecutter-uv</code> package.</p>"},{"location":"credits/#references","title":"References","text":"<p> <p>Carrere et al., OSTST 2022: A new barotropic tide model for global ocean: FES2022, https://doi.org/10.24400/527896/a03-2022.3287</p> <p>Egbert, Gary D., and Svetlana Y. Erofeeva. \"Efficient inverse modeling of barotropic ocean tides.\" Journal of Atmospheric and Oceanic Technology 19.2 (2002): 183-204.</p> <p>Florent H. Lyard, Loren Carrere, Ergane Fouchet, Mathilde Cancet, David Greenberg, G\u00e9rald Dibarboure and Nicolas Picot: \u201cFES2022 a step towards a SWOT-compliant tidal correction\u201d, to be submitted to Ocean Sciences.</p> <p>Hart-Davis Michael, Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry. SEANOE. https://doi.org/10.17882/79489</p> <p>Hart-Davis Michael G., Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20: a global ocean tide model from multi-mission satellite altimetry. Earth System Science Data, 13 (8), 3869-3884. https://doi.org/10.5194/essd-13-3869-2021</p> <p>Sutterley, T. C., Markus, T., Neumann, T. A., van den Broeke, M., van Wessem, J. M., and Ligtenberg, S. R. M.: Antarctic ice shelf thickness change from multimission lidar mapping, The Cryosphere, 13, 1801\u20131817, https://doi.org/10.5194/tc-13-1801-2019, 2019.</p> <p></p>"},{"location":"install/","title":"Installing <code>eo-tides</code>","text":""},{"location":"install/#stable-version","title":"Stable version","text":"<p>The latest stable release of <code>eo-tides</code> is:</p> <p></p> <p>It is compatible with the following Python versions:</p> <p></p> <p><code>eo-tides</code> can be installed into your Python environment using either <code>pip</code> (the standard Python package manager), or <code>uv</code> (a fast Python package manager written in Rust).</p> <p>Tip</p> <p>We recommend installing with <code>uv</code> as this makes it easy to set up an isolated environment containing compatible Python packages.</p> Installing with <code>pip</code>Installing with <code>uv</code> <p>Install <code>eo-tides</code>: <pre><code>python3 -m pip install eo-tides[notebooks]\n</code></pre></p> <p>The code above will also install additional package dependencies required for running Jupyter Notebook code examples (including <code>odc-stac</code> and <code>pystac-client</code> for loading satellite data).</p> <p>To install <code>eo-tides</code> with only essential package dependencies:</p> <pre><code>python3 -m pip install eo-tides\n</code></pre> <p>First, install <code>uv</code> using the method of your choice. Then:</p> <p>Create a new virtual environment with your chosen version of Python: <pre><code>uv venv --python 3.13\n</code></pre></p> <p>Activate your virtual environment:</p> Linux and macOSWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>Install <code>eo-tides</code> into your virtual environment:</p> <pre><code>uv pip install eo-tides[notebooks]\n</code></pre> <p>The code above will also install additional package dependencies required for running Jupyter Notebook code examples (including <code>odc-stac</code> and <code>pystac-client</code> for loading satellite data).</p> <p>To install <code>eo-tides</code> with only essential package dependencies: <pre><code>uv pip install eo-tides\n</code></pre></p> <p>You are now ready to run code using <code>eo-tides</code>! For example, you could launch your virtual environment with JupyterLab to run the example Jupyter Notebooks: <pre><code>uv run --with jupyter jupyter lab\n</code></pre></p>"},{"location":"install/#unstable-development-pre-releases","title":"Unstable development pre-releases","text":"<p>Unstable development pre-releases of <code>eo-tides</code> are also available:</p> <p></p> Installing with <code>pip</code>Installing with <code>uv</code> <p>Install an example <code>eo-tides</code> pre-release (see full list here), including additional <code>notebooks</code> dependencies: <pre><code>python3 -m pip install eo-tides[notebooks]==0.6.3.dev5\n</code></pre></p> <p>First, install <code>uv</code> using the method of your choice. Then:</p> <p>Create a new virtual environment with your chosen version of Python: <pre><code>uv venv --python 3.13\n</code></pre></p> <p>Activate your virtual environment:</p> Linux and macOSWindows <pre><code>source .venv/bin/activate\n</code></pre> <pre><code>.venv\\Scripts\\activate\n</code></pre> <p>Install an example <code>eo-tides</code> pre-release (see full list here), including additional <code>notebooks</code> dependencies: <pre><code>uv pip install eo-tides[notebooks]==0.6.3.dev5\n</code></pre></p> <p>Important</p> <p>Unstable development pre-releases may contain bugs and untested new features. Unless you need access to a specific unpublished feature, we recommend installing the latest stable version instead.</p>"},{"location":"install/#advanced-developing-locally","title":"Advanced: Developing locally","text":"<p>To work on <code>eo-tides</code> locally, we recommend using <code>uv</code>.</p> <p>First, install <code>uv</code> using the method of your choice.</p> <p>Clone the <code>eo-tides</code> repository:</p> <pre><code>git clone https://github.com/GeoscienceAustralia/eo-tides\ncd eo-tides/\n</code></pre> <p>Use <code>uv sync</code> to populate an environment with package dependencies from the <code>eo-tides</code> lockfile:</p> <pre><code>uv sync --all-extras\n</code></pre> <p>Set up pre-commit hooks:</p> <pre><code>uv run pre-commit install\n</code></pre> <p>We provide a pre-prepared Makefile that you can use to easily run common tasks:</p> <pre><code># Run code quality checks\nmake check\n\n# Run pytest tests\nmake test\n\n# Run Jupyter notebook tests\nmake test-notebooks\n\n# Build and preview documentation\nmake docs\n</code></pre>"},{"location":"install/#next-steps","title":"Next steps","text":"<p>Once you have installed <code>eo-tides</code>, you will need to download and set up at least one tide model before you can model tides.</p>"},{"location":"migration/","title":"Migrating from <code>dea_tools</code>","text":"<p>The <code>eo-tides</code> package contains functions that were previously available in the <code>Digital Earth Australia Notebooks and Tools</code> repository. To migrate your code from DEA Tools to <code>eo-tides</code>, please be aware of the following breaking changes:</p>"},{"location":"migration/#breaking-changes","title":"Breaking changes","text":""},{"location":"migration/#tide_m-renamed-to-tide_height","title":"\"tide_m\" renamed to \"tide_height\"","text":"<p>The default output tide heights column generated by the <code>model_tides</code> function and the <code>xarray.DataArray</code> outputs generated by <code>tag_tides</code> and <code>pixel_tides</code> have been renamed from <code>tide_m</code> to <code>tide_height</code>. This more clearly describes the data, particularly when used in combination with <code>output_units=\"cm\"</code> or <code>output_units=\"mm\"</code> which returns tide heights in non-metre units.</p> <p>Action required</p> <p>Update any references of <code>tide_m</code> to <code>tide_height</code></p>"},{"location":"migration/#default-model-changed-to-eot20","title":"Default model changed to \"EOT20\"","text":"<p>The default tide model has been changed from \"FES2014\" to the open source \"EOT20\" Empirical Ocean Tide tide model (CC BY 4.0):</p> <p>Hart-Davis Michael, Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry. SEANOE. https://doi.org/10.17882/79489</p> <p>Note that this change in default is primarily due to the permissive license of this model; the choice of optimal model will vary by study area and application.</p> <p>Action required</p> <p>To use FES2014, set <code>model=\"FES2014\"</code> instead of leaving the default <code>model=None</code>.</p>"},{"location":"migration/#tidal_tag-renamed-to-tag_tides","title":"<code>tidal_tag</code> renamed to <code>tag_tides</code>","text":"<p>Renamed for consistency with <code>model_tides</code> and <code>pixel_tides</code>.</p> <p>Action required</p> <p>Update references to <code>tidal_tag</code> to <code>tag_tides</code>.</p>"},{"location":"migration/#ds-param-renamed-to-data-now-accepts-geobox","title":"<code>ds</code> param renamed to <code>data</code>, now accepts <code>GeoBox</code>","text":"<p>The <code>ds</code> param in all satellite data functions (<code>tag_tides</code>, <code>pixel_tides</code>, <code>tide_stats</code>, <code>pixel_tides</code>) has been updated to accept either <code>xarray.Dataset</code>, <code>xarray.DataArray</code> or a <code>odc.geo.geobox.GeoBox</code>. To account for this change, the <code>ds</code> param has been renamed to a more generic name <code>data</code>.</p> <p>Action required</p> <p>Update: <pre><code>tag_tides(ds=your_data)\n</code></pre> To: <pre><code>tag_tides(data=your_data)\n</code></pre></p>"},{"location":"migration/#times-param-renamed-to-time-accepts-any-format-supported-by-pandasto_datetime","title":"<code>times</code> param renamed to <code>time</code>, accepts any format supported by <code>pandas.to_datetime()</code>","text":"<p>The <code>times</code> parameter has been renamed to <code>time</code>, and updated to more flexibly accept any time format that can be converted by <code>pandas.to_datetime()</code>; e.g. <code>np.ndarray[datetime64]</code>, <code>pd.DatetimeIndex</code>, <code>pd.Timestamp</code>, <code>datetime.datetime</code> and strings (e.g. <code>\"2020-01-01 23:00\"</code>). For example: <code>time=pd.date_range(start=\"2000\", end=\"2001\", freq=\"5h\")</code>.</p> <p>Action required</p> <p>Update: <pre><code>model_tides(..., times=...)\n</code></pre> To: <pre><code>model_tides(..., time=...)\n</code></pre></p>"},{"location":"migration/#tag_tides-now-returns-an-array-instead-of-updating-data-in-place","title":"<code>tag_tides</code> now returns an array instead of updating data in-place","text":"<p>The <code>tag_tides</code> function now returns an <code>xarray.DataArray</code> output containing tide heights, rather than appending tide height data to the original input dataset in-place. This change provides better consistency with <code>pixel_tides</code>, which also returns an array of tide heights.</p> <p>Action required</p> <p>Update: <pre><code>data = tag_tides(data, ...)\n</code></pre> To: <pre><code>data[\"tide_height\"] = tag_tides(data, ...)\n</code></pre></p>"},{"location":"migration/#pixel_tides-only-returns-a-single-array","title":"<code>pixel_tides</code> only returns a single array","text":"<p>The <code>pixel_tides</code> function has been updated to only ever return a single array as an output: a high-resolution tide height array matching the resolution of the input <code>data</code> by default, and a low-resolution tide height array if <code>resample=False</code>.</p> <p>Action required</p> <p>Update code to handle a single tide height array output from <code>pixel_tides</code>, instead of a tuple of high-resolution and low-resolution modelled tide height arrays.</p>"},{"location":"migration/#tide-model-directory-environment-variable-updated","title":"Tide model directory environment variable updated","text":"<p>The <code>DEA_TOOLS_TIDE_MODELS</code> environmental variable has been renamed to <code>EO_TIDES_TIDE_MODELS</code>.</p> <p>Action required</p> <p>Set the <code>EO_TIDES_TIDE_MODELS</code> environment variable instead of <code>DEA_TOOLS_TIDE_MODELS</code>.</p>"},{"location":"migration/#error-raised-if-both-directory-parameter-and-environment-variable-are-missing","title":"Error raised if both <code>directory</code> parameter and environment variable are missing","text":"<p>Previously, tide modelling functions used a fall-back tide modelling directory (<code>/var/share/tide_models</code>) if both the <code>directory</code> parameter and the tide model directory environment variable were absent. This fall-back has been removed, and an error will now be raised if no tide model directory is specified.</p> <p>Action required</p> <p>Ensure that either the <code>directory</code> parameter or the <code>EO_TIDES_TIDE_MODELS</code> environment variable are provided.</p>"},{"location":"setup/","title":"Setting up tide models","text":"<p>Important</p> <p><code>eo-tides</code> provides tools for modelling tides using global ocean tide models but does not host or maintain the model data itself. Users are responsible for accessing, using, and citing ocean tide model data in compliance with each model's licensing terms.</p> <p>Once you have installed <code>eo-tides</code>, we need to download and set up the external global ocean tide model data required for <code>eo-tides</code> to work. The following documentation provides instructions for getting started with several common global ocean tide models.</p> <p>Tip</p> <p>Please refer to the <code>pyTMD</code> documentation for additional instructions covering all other supported tide models.</p>"},{"location":"setup/#tide-model-files-and-harmonic-tidal-constituents","title":"Tide model files and harmonic tidal constituents","text":"<p>Tides are driven by complex gravitational interactions between the Earth, moon, and sun, which create periodic and predictable variations in sea level. These variations can be decomposed into a set of harmonic tidal constituents (also known as \"tidal constants\") with unique amplitudes and phases that correspond to different celestial influences.</p> <p>When downloading tide model data, you are retrieving these tidal constituents rather than direct modelled or measured tidal height outputs. Global ocean tide models use amplitudes and phases from these tidal constituents to precisely reconstruct tidal variations, allowing them to predict tide heights for any location on the planet and any moment in time \u2014 even into the future.</p> <p>Tip</p> <p>For a deep dive into the science of tide modelling and how harmonic tidal constituents are used by global ocean tide models, refer to <code>pyTMD</code> Ocean and Load Tides documentation.</p>"},{"location":"setup/#setting-up-a-tide-model-directory","title":"Setting up a tide model directory","text":"<p>As a first step, we need to create a directory that will contain our tide model data. This directory will be accessed by all <code>eo-tides</code> functions. For example, we might want to store our tide model data in a directory called <code>tide_models/</code>:</p> Relative pathFull path (Windows)Full path (Linux) <p><pre><code>tide_models/</code></pre></p> <p><pre><code>D:/projects/tide_models/</code></pre></p> <p><pre><code>/home/user/projects/tide_models/</code></pre></p> <p>Tip</p> <p>This directory doesn't need to be called <code>tide_models</code>; use any name and/or location that is convenient to you and accessible from your Python environment. Please refer to the documentation below for further details on configuring <code>eo-tides</code> to use this directory.</p>"},{"location":"setup/#downloading-tide-model-data","title":"Downloading tide model data","text":"<p>Now we need to download some data from one or more models, and save this into our tide model directory. Follow the guides below for some of the most commonly used global ocean tide models:</p> EOT20 Empirical Ocean Tide model (default) FES2022 Finite Element Solution tide models FES2014 Finite Element Solution tide models GOT Global Ocean Tide models TPXO Global Tidal Models DTU Technical University of Denmark tide models <p>Tip</p> <p>To allow you to improve tide modelling performance by clipping your tide model files (see below), we recommend downloading NetCDF-format versions of tide models wherever possible.</p>"},{"location":"setup/#eot20-empirical-ocean-tide-model-default","title":"EOT20 Empirical Ocean Tide model (default)","text":"<ol> <li>Visit EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry</li> <li> <p>Under <code>Data</code>, click <code>Download</code>:</p> <p></p> </li> <li> <p>Create a new directory inside your tide model directory called <code>EOT20/</code> to store the EOT20 model files.</p> </li> <li> <p>Extract the <code>85762.zip</code> and then <code>ocean_tides.zip</code> into this new directory.</p> </li> </ol> <p>You should end up with the following directory structure containing the extracted NetCDF files:</p> <pre><code>tide_models/EOT20/ocean_tides/\n    |- 2N2_ocean_eot20.nc\n    |- ...\n    |- T2_ocean_eot20.nc\n</code></pre>"},{"location":"setup/#fes2022-finite-element-solution-tide-models","title":"FES2022 Finite Element Solution tide models","text":"<ol> <li> <p>Register with AVISO+, and select <code>FES (Finite Element Solution - Oceanic Tides Heights)</code> from the <code>Licence Agreement and product selection</code> section:</p> <p></p> </li> <li> <p>Scroll to the bottom of the page and agree to the licence agreement. Your request will be sent for approval (this may take several days).</p> </li> <li>Once you are notified via email that your registration and access is approved, login to MY AVISO+.</li> <li> <p>Once logged in, select My products in the left-hand menu:</p> <p></p> </li> <li> <p><code>FES (Finite Element Solution - Oceanic Tides Heights)</code> should appear under <code>Your current subscriptions.</code> Right click on <code>Ftp</code>, and copy the FTP address.</p> <p></p> </li> <li> <p>Using an FTP client like FileZilla, log in to the FTP using your AVISO+ username and password:</p> <p></p> </li> <li> <p>Navigate to <code>/auxiliary/tide_model/</code>, and download the contents of one of the following FTP directory:</p> <ul> <li><code>fes2022b/ocean_tide_20241025/</code> (if using standard model data)</li> <li><code>fes2022b/ocean_tide_extrapolated/</code> (if using extrapolated model data)</li> </ul> <p>Tip</p> <p>The \"extrapolated\" version of FES models have been extended inland using a simple \"nearest\" extrapolation method to ensure data coverage across the entire coastal zone. This can be useful for ensuring you always return a modelled tide, but can also introduce uncertainty into your modelling (particularly in complex regions such as narrow peninsulas or inlets/embayments).</p> </li> <li> <p>Create a new nested folder inside your tide model directory called either <code>fes2022b/ocean_tide_20241025/</code> (if using standard model data) or <code>fes2022b/ocean_tide_extrapolated/</code> (if using extrapolated model data) to store your downloaded files.</p> </li> <li> <p>Copy your downloaded files into your new tide model directory folder, then uncompress each compressed <code>*.nc.xz</code> file (e.g. <code>xz -dk *.nc.xz</code>).</p> </li> </ol> <p>You should end up with the following directory structure containing uncompressed <code>.nc</code>-format NetCDF files:</p> <p><pre><code>tide_models/fes2022b/ocean_tide_20241025/\n    |- 2n2_fes2022.nc\n    |- ...\n    |- t2_fes2022.nc\n</code></pre> Or: <pre><code>tide_models/fes2022b/ocean_tide_extrapolated/\n    |- 2n2_fes2022.nc\n    |- ...\n    |- t2_fes2022.nc\n</code></pre></p>"},{"location":"setup/#fes2014-finite-element-solution-tide-models","title":"FES2014 Finite Element Solution tide models","text":"<ol> <li> <p>Register with AVISO+, and select <code>FES (Finite Element Solution - Oceanic Tides Heights)</code> from the <code>Licence Agreement and product selection</code> section:</p> <p></p> </li> <li> <p>Scroll to the bottom of the page and agree to the licence agreement. Your request will be sent for approval (this may take several days).</p> </li> <li>Once you are notified via email that your registration and access is approved, login to MY AVISO+.</li> <li> <p>Once logged in, select My products in the left-hand menu:</p> <p></p> </li> <li> <p><code>FES (Finite Element Solution - Oceanic Tides Heights)</code> should appear under <code>Your current subscriptions.</code> Right click on <code>Ftp</code>, and copy the FTP address.</p> <p></p> </li> <li> <p>Using an FTP client like FileZilla, log in to the FTP using your AVISO+ username and password:</p> <p></p> </li> <li> <p>Navigate to <code>/auxiliary/tide_model/</code>, and download the contents of one or more of the following directories:</p> <ul> <li><code>fes2014_elevations_and_load/fes2014b_elevations/</code></li> <li><code>fes2014_elevations_and_load/fes2014b_elevations_extrapolated/</code></li> </ul> <p>Tip</p> <p>The \"extrapolated\" version of FES have been extended inland using a simple \"nearest\" extrapolation method to ensure data coverage across the entire coastal zone. This can be useful for ensuring you always return a modelled tide, but can also introduce uncertainty into your modelling (particularly in complex regions such as narrow peninsulas or inlets/embayments).</p> </li> <li> <p>Create a new directory inside your tide model directory called <code>fes2014/</code> to store the FES2014 model files.</p> </li> <li> <p>Extract <code>ocean_tide.tar.xz</code> or <code>ocean_tide_extrapolated.tar.xz</code> into this directory (e.g. <code>tar -xf ocean_tide.tar.xz</code>).</p> </li> </ol> <p>You should end up with the following directory structure containing the extracted NetCDF files:</p> <p><pre><code>tide_models/fes2014/ocean_tide/\n   |- 2n2.nc\n   |- ...\n   |- t2.nc\n</code></pre> Or: <pre><code>tide_models/fes2014/ocean_tide_extrapolated/\n   |- 2n2.nc\n   |- ...\n   |- t2.nc\n</code></pre></p>"},{"location":"setup/#got-global-ocean-tide-models","title":"GOT Global Ocean Tide models","text":"<ol> <li>Visit Ocean tide models</li> <li> <p>Under <code>Short-period (diurnal/semidiurnal) tides</code>, click choose your desired GOT model:</p> <p></p> </li> <li> <p>Create a new directory inside your tide model directory called either <code>GOT4.7/</code>, <code>got4.8/</code>, <code>GOT4.10c/</code>, <code>GOT5.5/</code> or <code>GOT5.6/</code> to store the GOT model files.</p> </li> <li> <p>Extract your downloaded <code>.tar.gz</code> file into this new directory.</p> </li> </ol> <p>You should end up with the following directory structure containing the extracted NetCDF files:</p> <p><pre><code>tide_models/GOT5.6/ocean_tides/\n    |- ...\n</code></pre> Or: <pre><code>tide_models/GOT5.5/ocean_tides/\n    |- ...\n</code></pre></p> <p>Important</p> <p>Note that GOT5.6 requires that both GOT5.6 and GOT5.5 model files are downloaded and extracted.</p> <p>Or: <pre><code>tide_models/GOT4.10c/grids_oceantide/\n    |- ...\n</code></pre> Or: <pre><code>tide_models/got4.8/grids_oceantide/\n    |- ...\n</code></pre> Or: <pre><code>tide_models/GOT4.7/grids_oceantide/\n    |- ...\n</code></pre></p>"},{"location":"setup/#tpxo-global-tidal-models","title":"TPXO Global Tidal Models","text":"<ol> <li>Visit TPXO Registration</li> <li>Follow instructions to email TPXO authors for access, providing your name, institution, your intended application/use case, and which TPXO models you need (\"TPXO10-atlas-v2 netcdf\" or \"TPXO9-atlas-v5 netcdf\" are recommended to enable clipping).</li> <li> <p>If your request is approved, you will be emailed an invite to an app.box.com folder. Open this link, then click \"Download\" on the top-right to download your zipped model files.</p> <p></p> </li> <li> <p>Create a new directory inside your tide model directory called either <code>TPXO10_atlas_v2/</code> or <code>TPXO9_atlas_v5/</code> to store the TPXO model files.</p> </li> <li> <p>Extract your zipped model files (e.g. <code>TPXO10_atlas_v2_nc.zip</code> or <code>TPXO9_atlas_v5_nc.zip</code>) into this new directory.</p> </li> </ol> <p>You should end up with the following directory structure containing the extracted NetCDF files, depending on the model you downloaded:</p> <p><pre><code>tide_models/TPXO10_atlas_v2/\n    |- grid_tpxo10atlas_v2.nc\n    |- ...\n    |- u_s2_tpxo10_atlas_30_v2.nc\n</code></pre> Or: <pre><code>tide_models/TPXO9_atlas_v5/\n    |- grid_tpxo9_atlas_30_v5.nc\n    |- ...\n    |- u_s2_tpxo9_atlas_30_v5.nc\n</code></pre></p>"},{"location":"setup/#dtu-technical-university-of-denmark-tide-models","title":"DTU Technical University of Denmark tide models","text":"<ol> <li>Visit DTU23 Global Ocean Tide model (DTU23_OceanTide)</li> <li>Download <code>DTU23_OceanTide.zip</code></li> </ol> <ol> <li>Create a new directory inside your tide model directory called <code>DTU23_OceanTide</code> to store the DTU23 model files.</li> <li>Extract your zipped model files (e.g. <code>DTU23_OceanTide.zip</code>) into this new directory.</li> <li>Uncompress all compressed <code>*.d.gz</code> format files inside the <code>DTU23</code> folder (e.g. <code>gunzip -dk *.gz</code> from a terminal).</li> </ol> <p>You should end up with the following directory structure containing uncompressed <code>.d</code>-format files:</p> <pre><code>tide_models/DTU23_OceanTide/DTU23/\n    |- K1_DTU23.d\n    |- ...\n    |- S2_DTU23.d\n</code></pre>"},{"location":"setup/#verifying-available-and-supported-models","title":"Verifying available and supported models","text":"<p>You can check what tide models have been correctly set up for use by <code>eo-tides</code> using <code>eo_tides.utils.list_models</code>.</p> <p>The <code>list_models</code> function (like all main functions from <code>eo-tides</code>) requires you to specify either the relative or full/absolute path to your tide model directory using the <code>directory</code> parameter:</p> Relative pathFull path (Windows)Full path (Linux) <pre><code>from eo_tides.utils import list_models\n\navailable_models, supported_models = list_models(\n    directory=\"tide_models/\"\n)\n</code></pre> <p>Running <code>list_models</code> will print out a useful summary table, with supported tide models listed under \"Model\", and the expected path to their data within your tide model directory listed under \"Expected path\". Models that are correctly set up and available are marked with a \u2705, while unavailable (or incorrectly configured) models are marked with a \u274c:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\udb40\udc20\ud83c\udf0a  | Model        | Expected path\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2705  \u2502 EOT20        \u2502 tide_models/EOT20/ocean_tides\n\u274c  \u2502 FES2014      \u2502 tide_models/fes2014/ocean_tide\n\u2705  \u2502 HAMTIDE11    \u2502 tide_models/hamtide\n\u274c  \u2502 TPXO9.1      \u2502 tide_models/TPXO9.1/DATA\n...   ...            ...\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 2/50\n</code></pre> <pre><code>from eo_tides.utils import list_models\n\navailable_models, supported_models = list_models(\n    directory=\"D:/projects/tide_models/\"\n)\n</code></pre> <p>Running <code>list_models</code> will print out a useful summary table, with supported tide models listed under \"Model\", and the expected path to their data within your tide model directory listed under \"Expected path\". Models that are correctly set up and available are marked with a \u2705, while unavailable (or incorrectly configured) models are marked with a \u274c:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\udb40\udc20\ud83c\udf0a  | Model        | Expected path\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2705  \u2502 EOT20        \u2502 D:/projects/tide_models/EOT20/ocean_tides\n\u274c  \u2502 FES2014      \u2502 D:/projects/tide_models/fes2014/ocean_tide\n\u2705  \u2502 HAMTIDE11    \u2502 D:/projects/tide_models/hamtide\n\u274c  \u2502 TPXO9.1      \u2502 D:/projects/tide_models/TPXO9.1/DATA\n...   ...            ...\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 2/50\n</code></pre> <pre><code>from eo_tides.utils import list_models\n\navailable_models, supported_models = list_models(\n    directory=\"/home/user/projects/tide_models/\"\n)\n</code></pre> <p>Running <code>list_models</code> will print out a useful summary table, with supported tide models listed under \"Model\", and the expected path to their data within your tide model directory listed under \"Expected path\". Models that are correctly set up and available are marked with a \u2705, while unavailable (or incorrectly configured) models are marked with a \u274c:</p> <pre><code>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\udb40\udc20\ud83c\udf0a  | Model        | Expected path\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\u2705  \u2502 EOT20        \u2502 /home/user/projects/tide_models/EOT20/ocean_tides\n\u274c  \u2502 FES2014      \u2502 /home/user/projects/tide_models/fes2014/ocean_tide\n\u2705  \u2502 HAMTIDE11    \u2502 /home/user/projects/tide_models/hamtide\n\u274c  \u2502 TPXO9.1      \u2502 /home/user/projects/tide_models/TPXO9.1/DATA\n...   ...            ...\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 2/50\n</code></pre> <p>Tip</p> <p>If your downloaded models are marked as unavailable (\u274c), check that their data was correctly saved to the location specified in the \"Expected path\" column of the summary table.</p> <p>Any tide model marked with a \u2705 is now ready for tide modelling. For example, we could use the <code>eo_tides.model.model_tides</code> function, once again passing in the relative or absolute path to our tide model directory using the <code>directory</code> parameter.</p> <p>You can also specify a tide model to use with the <code>model</code> parameter. Model names should match the names given in the \"Model\" column of the <code>list_models</code> table above (by default, \"EOT20\" is used).</p> Relative pathFull path (Windows)Full path (Linux) <pre><code>import pandas as pd\nfrom eo_tides.model import model_tides\n\nmodel_tides(\n        x=155,\n        y=-35,\n        time=pd.date_range(\"2022-01-01\", \"2022-01-04\", freq=\"1D\"),\n        model=\"EOT20\",  # model name from \"Name\" column of `list_models`\n        directory=\"tide_models/\"  # relative path to `tide_models` directory\n)\n</code></pre> <pre><code>import pandas as pd\nfrom eo_tides.model import model_tides\n\nmodel_tides(\n        x=155,\n        y=-35,\n        time=pd.date_range(\"2022-01-01\", \"2022-01-04\", freq=\"1D\"),\n        model=\"EOT20\",  # model name from \"Name\" column of `list_models`\n        directory=\"D:/projects/tide_models/\"  # full path to `tide_models`\n)\n</code></pre> <pre><code>import pandas as pd\nfrom eo_tides.model import model_tides\n\nmodel_tides(\n        x=155,\n        y=-35,\n        time=pd.date_range(\"2022-01-01\", \"2022-01-04\", freq=\"1D\"),\n        model=\"EOT20\",  # model name from \"Name\" column of `list_models`\n        directory=\"/home/user/projects/tide_models/\"  # full path to `tide_models`\n)\n</code></pre> Advanced: Setting tide model directory via the EO_TIDES_TIDE_MODELS environmental variable"},{"location":"setup/#advanced-setting-tide-model-directory-via-the-eo_tides_tide_models-environmental-variable","title":"Advanced: Setting tide model directory via the <code>EO_TIDES_TIDE_MODELS</code> environmental variable","text":"<p>For more advanced usage, you can also set the path to your tide model directory by setting the <code>EO_TIDES_TIDE_MODELS</code> environment variable, avoiding the need to manually set the <code>directory</code> function parameter.</p> <p>This should be set to a full/absolute path to ensure it can be accessed from anywhere you run <code>eo-tides</code> code:</p> Full path (Windows)Full path (Linux) <pre><code>import os\nos.environ[\"EO_TIDES_TIDE_MODELS\"] = \"D:/projects/tide_models/\"\n</code></pre> <pre><code>import os\nos.environ[\"EO_TIDES_TIDE_MODELS\"] = \"/home/user/projects/tide_models/\"\n</code></pre> <p>All tide modelling functions from <code>eo-tides</code> will check for the presence of the <code>EO_TIDES_TIDE_MODELS</code> environment variable, and use it as the default <code>directory</code> path if available (the <code>EO_TIDES_TIDE_MODELS</code> environment variable will be overuled by the <code>directory</code> parameter if provided).</p> <p>Tip</p> <p>Setting the <code>EO_TIDES_TIDE_MODELS</code> environment variable can be useful when the location of your tide model directory might change between different environments, and you want to avoid hard-coding a single location via the <code>directory</code> parameter.</p>"},{"location":"setup/#clipping-model-files-to-improve-performance","title":"Clipping model files to improve performance","text":"<p>Highly recommended</p> <p>Clipping your model files to a smaller spatial extent is highly recommended, unless you are specifically running global-scale analyses.</p> <p>Running tide modelling on the default tide modelling data provided by external providers can be slow due to the large size of these files (especially for high-resolution models like FES2022). To improve performance, it can be extremely useful to clip your model files to a smaller region of interest (e.g. the extents of your country or coastal region). This can greatly improve run-times: potentially speeding up your tide modelling by over 10 times for large models!</p> <p>Once you have downloaded and verified your tide model data, you can use the <code>eo_tides.utils.clip_models</code> function to automatically clip your data, and export them to a new tide modelling directory:</p> <pre><code>from eo_tides.utils import clip_models\n\nclip_models(\n    input_directory=\"tide_models/\",\n    output_directory=\"tide_models_clipped/\",\n    bbox=(113.3, -43.6, 153.6, -10.7),\n)\n</code></pre> <p>When you run <code>clip_models</code>, the function will automatically identify suitable NetCDF-format models in your input directory, and clip each of them to the extent of your bounding box (specified as <code>(left, bottom, right, top)</code> in EPSG:4326 degree coordinates). After each model is clipped, the result is exported to your selected output directory and verified to ensure the clipped data is suitable for tide modelling:</p> <pre><code>Preparing to clip suitable NetCDF models: ['HAMTIDE11', 'EOT20']\n\nClipping HAMTIDE11: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 9/9 [00:03&lt;00:00,  2.60it/s]\n\u2705 Clipped model exported and verified\nClipping EOT20: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 17/17 [00:07&lt;00:00,  2.36it/s]\n\u2705 Clipped model exported and verified\n\nOutputs exported to tide_models_clipped/\n</code></pre> <p>You can now pass this new clipped tide model directory to all future <code>eo_tides</code> function calls for improved tide modelling performance, e.g.:</p> <pre><code>import pandas as pd\nfrom eo_tides.model import model_tides\n\nmodel_tides(\n        x=155,\n        y=-35,\n        time=pd.date_range(\"2022-01-01\", \"2022-01-04\", freq=\"1D\"),\n        model=\"EOT20\",\n        directory=\"tide_models_clipped/\"\n)\n</code></pre> <p>Example of tide model data for the M2 tidal constituent from <code>EOT20</code> clipped to Australia:</p> <p></p> <p>Tip</p> <p>Because only NetCDF-format tide models can be clipped, we recommend downloading NetCDF versions of your tide models wherever possible.</p>"},{"location":"setup/#next-steps","title":"Next steps","text":"<p>Now that you have installed <code>eo-tides</code> and set up some tide models, you can learn how to use <code>eo-tides</code> for modelling tides and analysing satellite data!</p>"},{"location":"notebooks/Case_study_intertidal/","title":"Mapping the intertidal zone","text":"In\u00a0[16]: Copied! <pre>import matplotlib.pyplot as plt\nimport odc.stac\nimport planetary_computer\nimport pystac_client\n\nfrom eo_tides.eo import tag_tides\nfrom eo_tides.stats import tide_stats\nfrom eo_tides.utils import list_models\n</pre> import matplotlib.pyplot as plt import odc.stac import planetary_computer import pystac_client  from eo_tides.eo import tag_tides from eo_tides.stats import tide_stats from eo_tides.utils import list_models In\u00a0[17]: Copied! <pre># Set the study area (xmin, ymin, xmax, ymax)\nbbox = [122.12, -18.25, 122.43, -17.93]\n\n# Set the time period\nstart_date = \"2022-01-01\"\nend_date = \"2023-12-31\"\n\n# Satellite products and bands to load\nsatellite_sensors = [\"landsat-c2-l2\"]\nbands = [\"green\", \"nir08\"]\n\n# Tide model and directory\ndirectory = \"../../tests/data/tide_models\"  # replace with the path to your tide data\nmodel = \"EOT20\"\n</pre> # Set the study area (xmin, ymin, xmax, ymax) bbox = [122.12, -18.25, 122.43, -17.93]  # Set the time period start_date = \"2022-01-01\" end_date = \"2023-12-31\"  # Satellite products and bands to load satellite_sensors = [\"landsat-c2-l2\"] bands = [\"green\", \"nir08\"]  # Tide model and directory directory = \"../../tests/data/tide_models\"  # replace with the path to your tide data model = \"EOT20\" <p>We can confirm our provided directory contains tide data:</p> In\u00a0[18]: Copied! <pre># Confirm we have model data\nlist_models(directory=directory, show_supported=False);\n</pre> # Confirm we have model data list_models(directory=directory, show_supported=False); <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \udb40\udc20\ud83c\udf0a  | Model                | Expected path                                                   \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2705  \u2502 EOT20                \u2502 ../../tests/data/tide_models/EOT20/ocean_tides                  \n \u2705  \u2502 GOT5.5               \u2502 ../../tests/data/tide_models/GOT5.5/ocean_tides                 \n \u2705  \u2502 HAMTIDE11            \u2502 ../../tests/data/tide_models/hamtide                            \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 3/52\n</pre> In\u00a0[19]: Copied! <pre># Connect to STAC catalog\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n# Set cloud access defaults\nodc.stac.configure_rio(\n    cloud_defaults=True,\n    aws={\"aws_unsigned\": True},\n)\n\n# Build a query and search the STAC catalog for all matching items\nquery = catalog.search(\n    bbox=bbox,\n    collections=satellite_sensors,\n    datetime=f\"{start_date}/{end_date}\",\n    query={\n        \"eo:cloud_cover\": {\"lt\": 5},  # Filter to images with &lt;5% cloud\n        \"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]},  # No Landsat 7\n    },\n)\n\n# Load data into xarray format\nds = odc.stac.load(\n    items=query.item_collection(),\n    bands=bands,\n    crs=\"utm\",\n    resolution=50,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\n# Apply USGS Landsat Collection 2 scaling factors to convert\n# surface reflectance to between 0.0 and 1.0. See:\n# https://www.usgs.gov/faqs/how-do-i-use-a-scale-factor-landsat-level-2-science-products\nds = (ds.where(ds != 0) * 0.0000275 + -0.2).clip(0, 1)\nprint(ds)\n</pre> # Connect to STAC catalog catalog = pystac_client.Client.open(     \"https://planetarycomputer.microsoft.com/api/stac/v1\",     modifier=planetary_computer.sign_inplace, )  # Set cloud access defaults odc.stac.configure_rio(     cloud_defaults=True,     aws={\"aws_unsigned\": True}, )  # Build a query and search the STAC catalog for all matching items query = catalog.search(     bbox=bbox,     collections=satellite_sensors,     datetime=f\"{start_date}/{end_date}\",     query={         \"eo:cloud_cover\": {\"lt\": 5},  # Filter to images with &lt;5% cloud         \"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]},  # No Landsat 7     }, )  # Load data into xarray format ds = odc.stac.load(     items=query.item_collection(),     bands=bands,     crs=\"utm\",     resolution=50,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  # Apply USGS Landsat Collection 2 scaling factors to convert # surface reflectance to between 0.0 and 1.0. See: # https://www.usgs.gov/faqs/how-do-i-use-a-scale-factor-landsat-level-2-science-products ds = (ds.where(ds != 0) * 0.0000275 + -0.2).clip(0, 1) print(ds) <pre>&lt;xarray.Dataset&gt; Size: 409MB\nDimensions:      (time: 109, y: 712, x: 659)\nCoordinates:\n  * y            (y) float64 6kB 8.017e+06 8.017e+06 ... 7.982e+06 7.982e+06\n  * x            (x) float64 5kB 4.068e+05 4.069e+05 ... 4.397e+05 4.397e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 872B 2022-01-01T01:55:58.691030 ... 20...\nData variables:\n    green        (time, y, x) float32 205MB dask.array&lt;chunksize=(1, 712, 659), meta=np.ndarray&gt;\n    nir08        (time, y, x) float32 205MB dask.array&lt;chunksize=(1, 712, 659), meta=np.ndarray&gt;\n</pre> In\u00a0[20]: Copied! <pre># Calculate NDWI\nds[[\"ndwi\"]] = (ds.green - ds.nir08) / (ds.green + ds.nir08)\n\n# Plot a single timestep\nds.ndwi.isel(time=1).plot.imshow(vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\n</pre> # Calculate NDWI ds[[\"ndwi\"]] = (ds.green - ds.nir08) / (ds.green + ds.nir08)  # Plot a single timestep ds.ndwi.isel(time=1).plot.imshow(vmin=-0.5, vmax=0.5, cmap=\"RdBu\") Out[20]: <pre>&lt;matplotlib.image.AxesImage at 0x75ee70b4b410&gt;</pre> In\u00a0[21]: Copied! <pre>ds[\"tide_height\"] = tag_tides(\n    data=ds,\n    model=model,\n    directory=directory,\n)\n</pre> ds[\"tide_height\"] = tag_tides(     data=ds,     model=model,     directory=directory, ) <pre>Setting tide modelling location from dataset centroid: 122.27, -18.09\nModelling tides with EOT20\n</pre> <p>We can plot a histogram of the tide heights of our satellite images. This shows that we have decent coverage of the tide range between approximately -2.8 to 3.5 m Above Mean Sea Level (AMSL):</p> In\u00a0[22]: Copied! <pre>ds[\"tide_height\"].plot.hist(bins=10, figsize=(5, 3))\nplt.title(\"Histogram of tide heights in satellite timeseries\");\n</pre> ds[\"tide_height\"].plot.hist(bins=10, figsize=(5, 3)) plt.title(\"Histogram of tide heights in satellite timeseries\"); <p>It is also important to compare our satellite tide observations against the full range of astronomical tides at our location. This lets us become aware of any major biases in our data. For example, here we can see that our data is biased away from low tide observations. This means that our final intertidal maps will underestimate the lower extent of the intertidal zone.</p> In\u00a0[23]: Copied! <pre>tide_stats(\n    data=ds,\n    model=model,\n    directory=directory,\n);\n</pre> tide_stats(     data=ds,     model=model,     directory=directory, ); <pre>Using tide modelling location: 122.27, -18.09\nModelling tides with EOT20\nUsing tide modelling location: 122.27, -18.09\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.45 m (-4.72 to 4.73 m).\n\ud83d\udef0\ufe0f Observed tide range: 6.37 m (-2.73 to 3.64 m).\n\n\ud83d\udd34 67% of the modelled astronomical tide range was observed at this location.\n\ud83d\udfe1 The highest 12% (1.09 m) of the tide range was never observed.\n\ud83d\udd34 The lowest 21% (2.00 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: 0.65 m.\n\u2b06\ufe0f The mean observed tide height was 0.65 m higher than the mean modelled astronomical tide height.\n</pre> In\u00a0[24]: Copied! <pre># Calculate low and high tide height thresholds\nlowtide_cutoff = 0.2\nhightide_cutoff = 0.8\nlowtide_thresh, hightide_thresh = ds.tide_height.quantile([lowtide_cutoff, hightide_cutoff])\nprint(f\"Low tide threshold: {lowtide_thresh:.2f} metres AMSL\")\nprint(f\"High tide threshold: {hightide_thresh:.2f} metres AMSL\")\n</pre> # Calculate low and high tide height thresholds lowtide_cutoff = 0.2 hightide_cutoff = 0.8 lowtide_thresh, hightide_thresh = ds.tide_height.quantile([lowtide_cutoff, hightide_cutoff]) print(f\"Low tide threshold: {lowtide_thresh:.2f} metres AMSL\") print(f\"High tide threshold: {hightide_thresh:.2f} metres AMSL\") <pre>Low tide threshold: -1.01 metres AMSL\nHigh tide threshold: 2.48 metres AMSL\n</pre> <p>We can now use these thresholds to select just the subset of our data with tide heights lower and higher than our thresholds:</p> In\u00a0[25]: Copied! <pre># Extract subset of low and high tide images\nds_lowtide = ds.sel(time=ds.tide_height &lt;= lowtide_thresh)\nds_hightide = ds.sel(time=ds.tide_height &gt;= hightide_thresh)\n\n# Plot extracted images over all images\nds.tide_height.plot(marker=\"o\", linewidth=0, label=\"Other satellite images\")\nds_hightide.tide_height.plot(marker=\"o\", linewidth=0, label=\"High tide images\")\nds_lowtide.tide_height.plot(marker=\"o\", linewidth=0, label=\"Low tide images\")\nplt.axhline(lowtide_thresh, color=\"black\", linestyle=\"dashed\")\nplt.axhline(hightide_thresh, color=\"black\", linestyle=\"dashed\")\nplt.legend(bbox_to_anchor=(1.01, 0.6))\nplt.title(\"Low and high tide satellite images\");\n</pre> # Extract subset of low and high tide images ds_lowtide = ds.sel(time=ds.tide_height &lt;= lowtide_thresh) ds_hightide = ds.sel(time=ds.tide_height &gt;= hightide_thresh)  # Plot extracted images over all images ds.tide_height.plot(marker=\"o\", linewidth=0, label=\"Other satellite images\") ds_hightide.tide_height.plot(marker=\"o\", linewidth=0, label=\"High tide images\") ds_lowtide.tide_height.plot(marker=\"o\", linewidth=0, label=\"Low tide images\") plt.axhline(lowtide_thresh, color=\"black\", linestyle=\"dashed\") plt.axhline(hightide_thresh, color=\"black\", linestyle=\"dashed\") plt.legend(bbox_to_anchor=(1.01, 0.6)) plt.title(\"Low and high tide satellite images\"); In\u00a0[26]: Copied! <pre># Combine NDWI into single median composites\nndwi_lowtide_median = ds_lowtide.ndwi.median(dim=\"time\")\nndwi_hightide_median = ds_hightide.ndwi.median(dim=\"time\")\n\n# Process our data and load into memory\nndwi_lowtide_median.load()\nndwi_hightide_median.load();\n</pre> # Combine NDWI into single median composites ndwi_lowtide_median = ds_lowtide.ndwi.median(dim=\"time\") ndwi_hightide_median = ds_hightide.ndwi.median(dim=\"time\")  # Process our data and load into memory ndwi_lowtide_median.load() ndwi_hightide_median.load(); <p>Now that we have processed our median NDWI composites, we can plot them together for a direct comparison. We can see that the low tide NDWI composite contains additional exposed intertidal terrain along the coastline that becomes inundated at high tide:</p> In\u00a0[27]: Copied! <pre>fig, axes = plt.subplots(1, 2, figsize=(12, 5))\nndwi_lowtide_median.plot.imshow(ax=axes[0], vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\nndwi_hightide_median.plot.imshow(ax=axes[1], vmin=-0.5, vmax=0.5, cmap=\"RdBu\")\naxes[0].set_title(\"Low tide NDWI composite\")\naxes[1].set_title(\"High tide NDWI composite\");\n</pre> fig, axes = plt.subplots(1, 2, figsize=(12, 5)) ndwi_lowtide_median.plot.imshow(ax=axes[0], vmin=-0.5, vmax=0.5, cmap=\"RdBu\") ndwi_hightide_median.plot.imshow(ax=axes[1], vmin=-0.5, vmax=0.5, cmap=\"RdBu\") axes[0].set_title(\"Low tide NDWI composite\") axes[1].set_title(\"High tide NDWI composite\"); In\u00a0[28]: Copied! <pre># Classify our NDWI layers\nndwi_lowtide_bool = ndwi_lowtide_median &gt; 0.0\nndwi_hightide_bool = ndwi_hightide_median &gt; 0.0\n\n# Plot outputs\nfig, axes = plt.subplots(1, 2, figsize=(12, 5))\nndwi_lowtide_bool.plot.imshow(ax=axes[0])\nndwi_hightide_bool.plot.imshow(ax=axes[1])\naxes[0].set_title(\"Low tide classified NDWI\")\naxes[1].set_title(\"High tide classified NDWI\");\n</pre> # Classify our NDWI layers ndwi_lowtide_bool = ndwi_lowtide_median &gt; 0.0 ndwi_hightide_bool = ndwi_hightide_median &gt; 0.0  # Plot outputs fig, axes = plt.subplots(1, 2, figsize=(12, 5)) ndwi_lowtide_bool.plot.imshow(ax=axes[0]) ndwi_hightide_bool.plot.imshow(ax=axes[1]) axes[0].set_title(\"Low tide classified NDWI\") axes[1].set_title(\"High tide classified NDWI\"); <p>Now, we can identify pixels that are <code>True</code> (dry) in our low tide data, and <code>False</code> (wet) in our high tide data. Yellow pixels in our resulting map represent likely intertidal pixels that are exposed at low tide and inundated at high tide.</p> In\u00a0[29]: Copied! <pre>intertidal = ~ndwi_lowtide_bool &amp; ndwi_hightide_bool\nintertidal.plot.imshow(size=8)\n</pre> intertidal = ~ndwi_lowtide_bool &amp; ndwi_hightide_bool intertidal.plot.imshow(size=8) Out[29]: <pre>&lt;matplotlib.image.AxesImage at 0x75ee73f184d0&gt;</pre> In\u00a0[30]: Copied! <pre>intertidal.astype(\"int16\").odc.write_cog(\"intertidal_map.tif\", overwrite=True);\n</pre> intertidal.astype(\"int16\").odc.write_cog(\"intertidal_map.tif\", overwrite=True);"},{"location":"notebooks/Case_study_intertidal/#mapping-the-intertidal-zone","title":"Mapping the intertidal zone\u00b6","text":"<p>The intertidal zone (i.e. the land along the coast that is periodically inundated by the tide) support important ecological habitats (e.g. sandy beaches and shores, tidal flats and rocky shores and reefs), and provide many valuable benefits such as storm surge protection, carbon storage and natural resources for recreational and commercial use. However, intertidal zones are faced with increasing threats from coastal erosion, land reclamation (e.g. port construction), and sea level rise. Accurate mapping data describing the spatial extents of the intertidal zone are essential for managing these environments, and predicting when and where these threats will have the greatest impact. However, the intertidal zone is challenging and expensive to map at large scale using intensive manual survey methods - particularly across large coastal regions.</p> <p>Satellite Earth observation (EO) data is freely available for the entire planet, making satellite imagery a powerful and cost-effective tool for mapping the intertidal zone at regional, national scale or global scale. This case study will demonstrate a simple intertidal mapping workflow that combines free and open Landsat satellite data with tide modelling from <code>eo-tides</code>. The workflow includes:</p> <ol> <li>Loading a time-series of cloud-free satellite data from the cloud using <code>odc-stac</code></li> <li>Converting our satellite data to a remote sensing water index (NDWI)</li> <li>Modelling tides for each satellite image and inspecting how these observed tides match up to the full local astronomical tide range</li> <li>Filtering our satellite imagery to low and high tide observations</li> <li>Combining noisy individual images into clean low and high tide median NDWI composites</li> <li>Using these composites to extract the extent of the intertidal zone</li> </ol> <p>More information</p> <p>         For more information about the workflows described below, refer to Sagar et al. 2017, Sagar et al. 2018, and Bishop-Taylor et al. 2019.     </p>"},{"location":"notebooks/Case_study_intertidal/#getting-started","title":"Getting started\u00b6","text":"<p>Import any Python packages we need for the analysis:</p>"},{"location":"notebooks/Case_study_intertidal/#analysis-parameters","title":"Analysis parameters\u00b6","text":"<p>To make our analysis more reusable, we can define some important parameters up-front. The default will load Landsat 8 and 9 satellite data from 2022-23 over the city of Broome, Western Australia - a macrotidal region with extensive intertidal coastal habitats.</p> <p>Importantly, we need to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here). We also define the tide model we want to use the for analysis.</p> <p>Tip</p> <p>        With the exception of <code>directory</code> (which you should update to point to your own tide model directory), leave the defaults below unchanged the first time you run through this notebook.     </p>"},{"location":"notebooks/Case_study_intertidal/#load-satellite-data-using-odc-stac","title":"Load satellite data using odc-stac\u00b6","text":"<p>Now we can load a time-series of satellite data over our area of interest using the Open Data Cube's <code>odc-stac</code> package. This powerful package allows us to load open satellite data (e.g ESA Sentinel-2 or NASA/USGS Landsat) for any time period and location on the planet, and load our data into a multi-dimensional <code>xarray.Dataset</code> format dataset.</p> <p>In this example, we will load our data from the Microsoft Planetary Computer STAC catalogue, restrict our data to cloud-free images with less than 5% cloud (<code>eo:cloud_cover\": {\"lt\": 5}\"</code>), and load our data at low resolution (<code>resolution=50</code>) to improve load times, and only load data from the most recent Landsat 8 and 9 satellites (<code>\"platform\": {\"in\": [\"landsat-8\", \"landsat-9\"]}</code>).</p> <p>Tip</p> <p>         For a more detailed guide to using STAC metadata and <code>odc-stac</code> to find and load satellite data, refer to the odc-stac Python package documentation. <code>eo-tides</code> is compatible with satellite data loaded from any STAC API, for example Digital Earth Australia.     </p>"},{"location":"notebooks/Case_study_intertidal/#converting-satellite-data-to-ndwi-water-index","title":"Converting satellite data to NDWI water index\u00b6","text":"<p>To help us map the distribution of tidal inundation across our study area, we can convert our spectral bands to a remote sensing water index that enhances contrast between water and dry land. We will use the Normalised Difference Water Index (NDWI), which is particularly useful for intertidal mapping as it is less vulnerable to misclassifications caused by wet sand and mud after high tide:</p> <p>$$ \\text{NDWI} = \\frac{\\text{Green} - \\text{NIR}}{\\text{Green} + \\text{NIR}} $$</p> <p>In the image below, red pixels represent dry land pixels, while blue pixels represent water:</p>"},{"location":"notebooks/Case_study_intertidal/#modelling-tide-heights-for-each-satellite-image","title":"Modelling tide heights for each satellite image\u00b6","text":"<p>We can now use the <code>tag_tides</code> function to model tides for each image in our satellite timeseries:</p>"},{"location":"notebooks/Case_study_intertidal/#exploring-tide-biases","title":"Exploring tide biases\u00b6","text":""},{"location":"notebooks/Case_study_intertidal/#extracting-low-and-high-tide-images","title":"Extracting low and high tide images\u00b6","text":"<p>Now that we have satellite images and associated tide heights, we can filter our data to extract only images from specific tidal stages.</p> <p>In this example, we will focus on extracting low tide and high tide images. We can identify low and high tide images by calculating quantiles of tide heights across time, selecting images from the lowest and highest 20% of tide heights.</p> <p>Tip</p> <p>         Try modifying the <code>lowtide_cutoff</code> and <code>hightide_cutoff</code> tide cutoffs below to customise the tidal stages we will analyse.     </p>"},{"location":"notebooks/Case_study_intertidal/#creating-low-and-high-tide-ndwi-composites","title":"Creating low and high tide NDWI composites\u00b6","text":"<p>Individual satellite images can be affected by many sources of noise, including clouds, saltspray, whitewater and sunglint. These sources of noise can make it difficult to map coastal environments consistently across time and along the coastline.</p> <p>To produce consistent analysis outputs, it can be useful to combine multiple satellite images into a single, cleaner \"composite\" image. This can improve the signal-to-noise ratio of our data, and allow us to map coastal features and change more accurately (at the cost of lower temporal resolution).</p> <p>In this example, we will combine our low and high tide NDWI data into two clean, relatively noise-free low tide and high tide median composites. We use a median calculation for this analysis as medians are extremely robust to noisy data.</p> <p>Important</p> <p>         Note the use of <code>.load()</code> below. Up to this point, our entire analysis has been \"lazy\", which means we haven't loaded the majority of our satellite data - we have simply \"queued\" up our analysis to run in a single step. This makes it quick and easy to write code without having to wait for every step of our workflow to run every time, or ever worrying about running out of memory. Running <code>.load()</code> triggers our entire analysis to run, and then load our final outputs into memory for further use. For more information about lazy loading and processing, see Parallel processing with Dask.     </p> <p>Important</p> <p>         Be patient; this step may take several minutes to complete.     </p>"},{"location":"notebooks/Case_study_intertidal/#mapping-intertidal-extent","title":"Mapping intertidal extent\u00b6","text":"<p>We can now perform a simple comparison of our two outputs to identify intertidal pixels as any pixels that are dry in our low tide composite, but wet in our high tide composite.</p> <p>First, let's classify our NDWI outputs into binary dry (True or 1.0) vs. wet (False or 0.0) using a standard 0.0 NDWI threshold. In the images below, yellow pixels represent water, and purple pixels represent land:</p>"},{"location":"notebooks/Case_study_intertidal/#exporting-data","title":"Exporting data\u00b6","text":"<p>As a final step, we can export our classified intertidal map as a GeoTIFF raster that we can load into a GIS like QGIS or ArcGIS Pro:</p>"},{"location":"notebooks/Case_study_intertidal/#next-steps","title":"Next steps\u00b6","text":"<p>Now that you have completed running this example, here's some possible next steps:</p> <ul> <li>Download the exported <code>intertidal_map.tif</code> and load it into a GIS software (QGIS, ArcGIS Pro) to inspect the output classification.</li> <li>Return to Analysis parameters, and re-run the analysis for a different location (<code>bbox</code>) or time period (<code>start_date</code>, <code>end_date</code>).</li> <li>Try modifying Analysis parameters to select a different tide model (e.g. <code>model=\"GOT5.5\"</code> or <code>model=\"HAMTIDE11\"</code>).</li> <li>Return to Extracting low and high tide images, and change the percentage thresholds (<code>lowtide_cutoff</code>, <code>hightide_cutoff</code>) used to identify low and high tide images.</li> <li>Advanced: In this simple analysis, we filtered to cloud-free images by discarding entire images with more than 5% cloud. Rather than filtering cloud-free images, consider masking clouds at the pixel-level using cloud masking bands that are packaged with the data (e.g. <code>qa_pixel</code>).</li> <li>Advanced: NDWI is just one of many possible remote sensing water indices that can be used for coastal analysis. Update the workflow to use a different water index (e.g. MNDWI), ensuring that you load any new bands required for the index calculation.</li> </ul> <p>In addition, consider the following questions:</p> <ul> <li>What implications do the tide biases calculated in Exploring tide biases have for the outputs of this analysis?</li> <li>Are our outputs likely to fully map the entire intertidal zone? What areas of the intertidal zone are likely to be better or poorly mapped?</li> <li>If you experimented with running the analysis using a different tide model, how does this influence our results?</li> </ul>"},{"location":"notebooks/Model_tides/","title":"Modelling tides","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\n</pre> directory = \"../../tests/data/tide_models/\" <p>Important</p> <p>         The directory above is for demo purposes only.         Update the <code>directory</code> path to point to the location of your own tide model directory.     </p> <p>We can use the <code>eo_tides.utils.list_models</code> function to verify that we have tide model data available in this directory:</p> In\u00a0[2]: Copied! <pre>from eo_tides.utils import list_models\n\nlist_models(directory=directory, show_supported=False);\n</pre> from eo_tides.utils import list_models  list_models(directory=directory, show_supported=False); <pre>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \udb40\udc20\ud83c\udf0a  | Model                | Expected path                                                   \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n \u2705  \u2502 EOT20                \u2502 ../../tests/data/tide_models/EOT20/ocean_tides                  \n \u2705  \u2502 GOT5.5               \u2502 ../../tests/data/tide_models/GOT5.5/ocean_tides                 \n \u2705  \u2502 HAMTIDE11            \u2502 ../../tests/data/tide_models/hamtide                            \n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n\nSummary:\nAvailable models: 3/52\n</pre> In\u00a0[3]: Copied! <pre>import pandas as pd\n\nfrom eo_tides.model import model_tides\n\ntide_df = model_tides(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),\n    directory=directory,\n)\n\n# Print outputs\ntide_df.head()\n</pre> import pandas as pd  from eo_tides.model import model_tides  tide_df = model_tides(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),     directory=directory, )  # Print outputs tide_df.head() <pre>Modelling tides with EOT20\n</pre> Out[3]: tide_model tide_height time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 1.225622 2018-01-01 01:00:00 122.2186 -18.0008 EOT20 2.159491 2018-01-01 02:00:00 122.2186 -18.0008 EOT20 2.474313 2018-01-01 03:00:00 122.2186 -18.0008 EOT20 2.111740 2018-01-01 04:00:00 122.2186 -18.0008 EOT20 1.182326 <p>Tip</p> <p>         If you do not see an output after running this code (e.g. for example if you are running the code as a script in a terminal, VS Code, or another code editor instead of a Jupyter Notebook), you may need to run <code>print(tide_df.head())</code> instead.     </p> <p>The resulting <code>pandas.DataFrame</code> contains:</p> <ul> <li><code>time</code>, <code>x</code>, <code>y</code>: Our original input timesteps and coordinates</li> <li><code>tide_model</code>: a column listing the tide model used</li> <li><code>tide_height</code>: modelled tide heights representing tide height in metres relative to Mean Sea Level</li> </ul> <p>We can plot our modelled outputs to view how tides changed across the month. Looking at the y-axis, we can see that tides at this macrotidal region ranged from -4 metres up to a maximum of +4 metres relative to Mean Sea Level:</p> In\u00a0[4]: Copied! <pre>tide_df.droplevel([\"x\", \"y\"]).tide_height.plot();\n</pre> tide_df.droplevel([\"x\", \"y\"]).tide_height.plot(); In\u00a0[5]: Copied! <pre>tide_df_multiple = model_tides(\n    x=122.2186,\n    y=-18.0008,\n    model=[\"EOT20\", \"HAMTIDE11\", \"GOT5.5\"],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),\n    output_format=\"wide\",\n    directory=directory,\n)\n\n# Print outputs\ntide_df_multiple.head()\n</pre> tide_df_multiple = model_tides(     x=122.2186,     y=-18.0008,     model=[\"EOT20\", \"HAMTIDE11\", \"GOT5.5\"],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", freq=\"1h\"),     output_format=\"wide\",     directory=directory, )  # Print outputs tide_df_multiple.head() <pre>Modelling tides with EOT20, HAMTIDE11, GOT5.5 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 20.76it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[5]: tide_model EOT20 GOT5.5 HAMTIDE11 time x y 2018-01-01 00:00:00 122.2186 -18.0008 1.225622 1.298427 1.419364 2018-01-01 01:00:00 122.2186 -18.0008 2.159491 2.287205 2.298982 2018-01-01 02:00:00 122.2186 -18.0008 2.474313 2.618187 2.535022 2018-01-01 03:00:00 122.2186 -18.0008 2.111740 2.228044 2.072335 2018-01-01 04:00:00 122.2186 -18.0008 1.182326 1.241291 1.035950 <p>Plot our outputs to see all our models on a graph:</p> In\u00a0[6]: Copied! <pre># Print outputs\ntide_df_multiple.droplevel([\"x\", \"y\"]).plot(legend=True)\n</pre> # Print outputs tide_df_multiple.droplevel([\"x\", \"y\"]).plot(legend=True) Out[6]: <pre>&lt;Axes: xlabel='time'&gt;</pre> In\u00a0[7]: Copied! <pre>model_tides(\n    x=[122.21, 122.22],\n    y=[-18.20, -18.21],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    mode=\"one-to-many\",\n    directory=directory,\n)\n</pre> model_tides(     x=[122.21, 122.22],     y=[-18.20, -18.21],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     mode=\"one-to-many\",     directory=directory, ) <pre>Modelling tides with EOT20\n</pre> Out[7]: tide_model tide_height time x y 2018-01-01 122.21 -18.20 EOT20 1.227716 2018-01-31 122.21 -18.20 EOT20 0.368260 2018-01-01 122.22 -18.21 EOT20 1.227716 2018-01-31 122.22 -18.21 EOT20 0.368260 <p>However, another common use case is having a list of locations you want to use to model tides for, each with a single timestep. Using \"one-to-one\" mode, we can model tides for each pair of locations and times:</p> <pre><code>2 timesteps at 2 locations = 2 modelled tides\n</code></pre> <p>For example, you may have a <code>pandas.DataFrame</code> containing <code>x</code>, <code>y</code> and <code>time</code> values:</p> In\u00a0[8]: Copied! <pre>tide_df = pd.DataFrame({\n    \"time\": pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    \"x\": [122.21, 122.22],\n    \"y\": [-18.20, -18.21],\n})\ntide_df\n</pre> tide_df = pd.DataFrame({     \"time\": pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     \"x\": [122.21, 122.22],     \"y\": [-18.20, -18.21], }) tide_df Out[8]: time x y 0 2018-01-01 122.21 -18.20 1 2018-01-31 122.22 -18.21 <p>We can pass these values to <code>model_tides</code> directly, and run the function in \"one-to-one\" mode to return a tide height for each row:</p> In\u00a0[9]: Copied! <pre># Model tides and add back into dataframe\ntide_df[\"tide_height\"] = model_tides(\n    x=tide_df.x,\n    y=tide_df.y,\n    time=tide_df.time,\n    mode=\"one-to-one\",\n    directory=directory,\n).tide_height.to_numpy()\n\n# Print dataframe with added tide height data:\ntide_df.head()\n</pre> # Model tides and add back into dataframe tide_df[\"tide_height\"] = model_tides(     x=tide_df.x,     y=tide_df.y,     time=tide_df.time,     mode=\"one-to-one\",     directory=directory, ).tide_height.to_numpy()  # Print dataframe with added tide height data: tide_df.head() <pre>Modelling tides with EOT20\n</pre> Out[9]: time x y tide_height 0 2018-01-01 122.21 -18.20 1.227716 1 2018-01-31 122.22 -18.21 0.368260 In\u00a0[10]: Copied! <pre>model_tides(\n    x=[122.21, 122.22],\n    y=[-18.20, -18.21],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],\n    output_format=\"long\",\n    directory=directory,\n)\n</pre> model_tides(     x=[122.21, 122.22],     y=[-18.20, -18.21],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],     output_format=\"long\",     directory=directory, ) <pre>Modelling tides with EOT20, GOT5.5, HAMTIDE11 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 22.51it/s]\n</pre> Out[10]: tide_model tide_height time x y 2018-01-01 122.21 -18.20 EOT20 1.227716 2018-01-31 122.21 -18.20 EOT20 0.368260 2018-01-01 122.22 -18.21 EOT20 1.227716 2018-01-31 122.22 -18.21 EOT20 0.368260 2018-01-01 122.21 -18.20 GOT5.5 1.271818 2018-01-31 122.21 -18.20 GOT5.5 0.397214 2018-01-01 122.22 -18.21 GOT5.5 1.271818 2018-01-31 122.22 -18.21 GOT5.5 0.397214 2018-01-01 122.21 -18.20 HAMTIDE11 1.432426 2018-01-31 122.21 -18.20 HAMTIDE11 0.588091 2018-01-01 122.22 -18.21 HAMTIDE11 1.432426 2018-01-31 122.22 -18.21 HAMTIDE11 0.588091 <p>We can also run the function in \"wide\" format, which will return a new column for each tide model (e.g. <code>EOT20</code>, <code>GOT5.5</code>, <code>HAMTIDE11</code> etc):</p> In\u00a0[11]: Copied! <pre>model_tides(\n    x=[122.21, 122.22],\n    y=[-18.20, -18.21],\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),\n    model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],\n    output_format=\"wide\",\n    directory=directory,\n)\n</pre> model_tides(     x=[122.21, 122.22],     y=[-18.20, -18.21],     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-31\", periods=2),     model=[\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"],     output_format=\"wide\",     directory=directory, ) <pre>Modelling tides with EOT20, GOT5.5, HAMTIDE11 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 22.11it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[11]: tide_model EOT20 GOT5.5 HAMTIDE11 time x y 2018-01-01 122.21 -18.20 1.227716 1.271818 1.432426 122.22 -18.21 1.227716 1.271818 1.432426 2018-01-31 122.21 -18.20 0.368260 0.397214 0.588091 122.22 -18.21 0.368260 0.397214 0.588091 In\u00a0[12]: Copied! <pre>from eo_tides.model import model_phases\n\nmodel_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),\n    directory=directory,\n)\n</pre> from eo_tides.model import model_phases  model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),     directory=directory, ) <pre>Modelling tides with EOT20\nModelling tides with EOT20\n</pre> Out[12]: tide_model tide_phase time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 high-flow 2018-01-01 05:00:00 122.2186 -18.0008 EOT20 low-ebb 2018-01-01 10:00:00 122.2186 -18.0008 EOT20 low-flow 2018-01-01 15:00:00 122.2186 -18.0008 EOT20 high-ebb 2018-01-01 20:00:00 122.2186 -18.0008 EOT20 low-ebb <p>The resulting <code>pandas.DataFrame</code> contains:</p> <ul> <li><code>time</code>, <code>x</code>, <code>y</code>: Our original input timesteps and coordinates</li> <li><code>tide_model</code>: a column listing the tide model used</li> <li><code>tide_phase</code>: the modelled tidal phase (\"high-flow\", \"high-ebb\", \"low-ebb\", \"low-flow\").</li> </ul> <p><code>model_phases</code> accepts all parameters accepted by <code>model_tides</code>; e.g. <code>model</code> and <code>output_format</code>:</p> In\u00a0[13]: Copied! <pre>model_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),\n    model=[\"EOT20\", \"GOT5.5\"],\n    output_format=\"wide\",\n    directory=directory,\n)\n</pre> model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),     model=[\"EOT20\", \"GOT5.5\"],     output_format=\"wide\",     directory=directory, ) <pre>Modelling tides with EOT20, GOT5.5 in parallel (models: 2, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 16.72it/s]\n</pre> <pre>Modelling tides with EOT20, GOT5.5 in parallel (models: 2, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 2/2 [00:00&lt;00:00, 16.65it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[13]: tide_model EOT20 GOT5.5 time x y 2018-01-01 00:00:00 122.2186 -18.0008 high-flow high-flow 2018-01-01 05:00:00 122.2186 -18.0008 low-ebb low-ebb 2018-01-01 10:00:00 122.2186 -18.0008 low-flow low-flow 2018-01-01 15:00:00 122.2186 -18.0008 high-ebb high-ebb 2018-01-01 20:00:00 122.2186 -18.0008 low-ebb low-ebb <p>To change the default 15 minute time offset used to calculate tide phases, pass a custom value to <code>time_offset</code>:</p> In\u00a0[14]: Copied! <pre>model_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),\n    time_offset=\"30 min\",\n    directory=directory,\n)\n</pre> model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"5h\"),     time_offset=\"30 min\",     directory=directory, ) <pre>Modelling tides with EOT20\nModelling tides with EOT20\n</pre> Out[14]: tide_model tide_phase time x y 2018-01-01 00:00:00 122.2186 -18.0008 EOT20 high-flow 2018-01-01 05:00:00 122.2186 -18.0008 EOT20 low-ebb 2018-01-01 10:00:00 122.2186 -18.0008 EOT20 low-flow 2018-01-01 15:00:00 122.2186 -18.0008 EOT20 high-ebb 2018-01-01 20:00:00 122.2186 -18.0008 EOT20 low-ebb <p>Optionally, we can choose to return also tide heights by providing <code>return_tides=True</code>. This will include an additional <code>tide_height</code> column in our dataframe:</p> In\u00a0[15]: Copied! <pre>phase_df = model_phases(\n    x=122.2186,\n    y=-18.0008,\n    time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"30min\"),\n    return_tides=True,\n    directory=directory,\n)\n\n# Print outputs\nprint(phase_df.head())\n</pre> phase_df = model_phases(     x=122.2186,     y=-18.0008,     time=pd.date_range(start=\"2018-01-01\", end=\"2018-01-02\", freq=\"30min\"),     return_tides=True,     directory=directory, )  # Print outputs print(phase_df.head()) <pre>Modelling tides with EOT20\nModelling tides with EOT20\n                                      tide_model  tide_height tide_phase\ntime                x        y                                          \n2018-01-01 00:00:00 122.2186 -18.0008      EOT20     1.225622  high-flow\n2018-01-01 00:30:00 122.2186 -18.0008      EOT20     1.759447  high-flow\n2018-01-01 01:00:00 122.2186 -18.0008      EOT20     2.159491  high-flow\n2018-01-01 01:30:00 122.2186 -18.0008      EOT20     2.402078  high-flow\n2018-01-01 02:00:00 122.2186 -18.0008      EOT20     2.474313  high-flow\n</pre> <p>If we plot our <code>tide_height</code> and <code>tide_phase</code> data, we can see it follows a logical progression from <code>high-flow -&gt; high-ebb -&gt; low-ebb -&gt; low-flow -&gt; ...</code>, repeating with every tide cycle:</p> In\u00a0[16]: Copied! <pre># Plot tide heights\nax = phase_df.droplevel([\"x\", \"y\"]).tide_height.plot(color=\"black\")\n\n# Define plotting parameters for each phase\nplot_params = {\n    \"high-flow\": {\"marker\": \"^\", \"color\": \"tab:blue\"},\n    \"high-ebb\": {\"marker\": \"v\", \"color\": \"tab:blue\"},\n    \"low-flow\": {\"marker\": \"^\", \"color\": \"tab:orange\"},\n    \"low-ebb\": {\"marker\": \"v\", \"color\": \"tab:orange\"},\n}\n\n# Plot each phase\nfor phase, params in plot_params.items():\n    phase_df.droplevel([\"x\", \"y\"]).query(f\"tide_phase == '{phase}'\").tide_height.plot(\n        marker=params[\"marker\"],\n        linewidth=0.0,\n        color=params[\"color\"],\n        markersize=10,\n        label=phase,\n    )\nax.legend();\n</pre> # Plot tide heights ax = phase_df.droplevel([\"x\", \"y\"]).tide_height.plot(color=\"black\")  # Define plotting parameters for each phase plot_params = {     \"high-flow\": {\"marker\": \"^\", \"color\": \"tab:blue\"},     \"high-ebb\": {\"marker\": \"v\", \"color\": \"tab:blue\"},     \"low-flow\": {\"marker\": \"^\", \"color\": \"tab:orange\"},     \"low-ebb\": {\"marker\": \"v\", \"color\": \"tab:orange\"}, }  # Plot each phase for phase, params in plot_params.items():     phase_df.droplevel([\"x\", \"y\"]).query(f\"tide_phase == '{phase}'\").tide_height.plot(         marker=params[\"marker\"],         linewidth=0.0,         color=params[\"color\"],         markersize=10,         label=phase,     ) ax.legend();"},{"location":"notebooks/Model_tides/#modelling-tides","title":"Modelling tides\u00b6","text":"<p>This guide demonstrates how to use the <code>model_tides</code> and <code>model_phases</code> functions from the <code>eo_tides.model</code> module to model tide heights and phases at multiple coordinates or time steps, using one or more ocean tide models.</p> <p>The <code>model_tides</code> function supports tide modelling based on a wide range of ocean tide models using a single line of code, parallelising this modelling where possible and returning data in a standardised <code>pandas.Dataframe</code> format. The <code>model_tides</code> function can be used independently of Earth observation (EO) data, e.g. for any application where you need to generate a time series of tide heights. However, it also underpins the more complex EO-related functions demonstrated in Combining tides with satellite data.</p> <p>The <code>model_phases</code> function can be used to model the phase of the tide at any location and time. This can be used to classify tides into high and low tide observations, or determine whether the tide was rising (i.e. flow tide) or falling (i.e. ebb tide).</p> <p>Tip</p> <p>         The <code>model_tides</code> function is based on the <code>pyTMD.compute.tide_elevations</code> function from the <code>pyTMD</code> tide modelling package that underpins <code>eo-tides</code>. We highly recommend exploring the more advanced tide modelling functionality available in <code>pyTMD</code> for more custom tide modelling applications.     </p>"},{"location":"notebooks/Model_tides/#getting-started","title":"Getting started\u00b6","text":"<p>As a first step, we need to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here).</p> <p>We will pass this path to <code>eo-tides</code> functions using the <code>directory</code> parameter.</p>"},{"location":"notebooks/Model_tides/#using-model_tides","title":"Using model_tides\u00b6","text":"<p>In the example below, we use the <code>model_tides</code> function to model hourly tides for the city of Broome, Western Australia across January 2018.</p> <p>Tip</p> <p>         To learn more about the science of tide prediction, refer to the <code>pyTMD</code> Background documentation and Glossary.     </p>"},{"location":"notebooks/Model_tides/#multiple-models","title":"Multiple models\u00b6","text":"<p>By default, <code>model_tides</code> will model tides using the <code>EOT20</code> tide model \u2013 a leading open-source global ocean model with a permissive CC BY 4.0 licence:</p> <p>Hart-Davis Michael, Piccioni Gaia, Dettmering Denise, Schwatke Christian, Passaro Marcello, Seitz Florian (2021). EOT20 - A global Empirical Ocean Tide model from multi-mission satellite altimetry. SEANOE. https://doi.org/10.17882/79489</p> <p>However, we can easily model tides using multiple models by passing a list of models to the <code>model</code> parameter. <code>eo-tides</code> will process these in parallel where possible, and return the data into a single <code>pandas.DataFrame</code>. For example, we can model tides using the <code>EOT20</code>, <code>GOT5.5</code> and <code>HAMTIDE11</code> models:</p> <p>Note</p> <p>         Here we also set <code>output_format=\"wide\"</code>, which will place data from each model into a new column.         This can make it easier to plot our data. For more details, see below.     </p>"},{"location":"notebooks/Model_tides/#one-to-many-and-one-to-one-modes","title":"\"One-to-many\" and \"one-to-one\" modes\u00b6","text":"<p>By default, the <code>model_tides</code> function operates in \"one-to-many\" mode, which will model tides at every requested location, for every requested timestep. This is particularly useful for satellite Earth observation applications where we may want to model tides for every satellite acquisition through time, for a large set of satellite pixels.</p> <p>For example, if we provide two locations and two timesteps, the function will return four modelled tides:</p> <pre><code>2 locations * 2 timesteps = 4 modelled tides\n</code></pre>"},{"location":"notebooks/Model_tides/#wide-and-long-output-formats","title":"\"Wide\" and \"long\" output formats\u00b6","text":"<p>By default, modelled tides will be returned in \"long\" format, with multiple models stacked under a <code>tide_models</code> column and tide heights in the <code>tide_height</code> column:</p>"},{"location":"notebooks/Model_tides/#using-model_phases","title":"Using model_phases\u00b6","text":"<p>In addition to tide height, it can be useful to obtain information about the phase of the tide at each observation. For example, we may want to know whether tides were low or high, or whether water levels were rising (\"flow\" tide) or falling (\"ebb\" tide). Tide phase data can provide valuable contextual information for interpreting satellite imagery, particularly in tidal flat or mangrove forest environments where water may remain in the landscape for considerable time after the tidal peak.</p> <p>The <code>model_phases</code> function calculates ebb and low phases by modelling tides once for the requested timesteps, and again after shifting each time by a small time offset (by default, 15 minutes). If tides increased over this period, they are assigned as \"flow\"; if they decreased, they are assigned as \"ebb\". Tides are considered \"high\" if equal or greater than 0 metres tide height, otherwise \"low\".</p> <p>We can run <code>model_phases</code> by providing <code>x</code> and <code>y</code> coordinates and <code>time</code>:</p>"},{"location":"notebooks/Model_tides/#next-steps","title":"Next steps\u00b6","text":"<p>Now that we have demonstrated how to model tide heights and phases, we can learn how to combine modelled tides with satellite data for further analysis.</p>"},{"location":"notebooks/Satellite_data/","title":"Combining tides with satellite data","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\nmodel = \"EOT20\"\n</pre> directory = \"../../tests/data/tide_models/\" model = \"EOT20\" In\u00a0[2]: Copied! <pre>import odc.stac\nimport planetary_computer\nimport pystac_client\n\n# Connect to STAC catalog\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n# Set cloud access defaults\nodc.stac.configure_rio(\n    cloud_defaults=True,\n    aws={\"aws_unsigned\": True},\n)\n\n# Build a query and search the STAC catalog for all matching items\nbbox = [121.45, -18.50, 122.45, -17.50]\nquery = catalog.search(\n    bbox=bbox,\n    collections=[\"sentinel-2-l2a\"],\n    datetime=\"2024-06-01/2024-09-01\",\n    query={\"eo:cloud_cover\": {\"lt\": 5}},  # Filter to images with &lt;5% cloud\n)\n\n# Load data into xarray format\nds = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"red\", \"green\", \"blue\"],\n    crs=\"utm\",\n    resolution=200,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\n# Rescale data to be between 0 and 1 using ESA offset/scaling factors\nds = (ds - 1000) / 10000\n\n# Plot a sample image\nds.isel(time=0).odc.to_rgba(vmin=0.0, vmax=0.3).plot.imshow(aspect=1, size=8)\n</pre> import odc.stac import planetary_computer import pystac_client  # Connect to STAC catalog catalog = pystac_client.Client.open(     \"https://planetarycomputer.microsoft.com/api/stac/v1\",     modifier=planetary_computer.sign_inplace, )  # Set cloud access defaults odc.stac.configure_rio(     cloud_defaults=True,     aws={\"aws_unsigned\": True}, )  # Build a query and search the STAC catalog for all matching items bbox = [121.45, -18.50, 122.45, -17.50] query = catalog.search(     bbox=bbox,     collections=[\"sentinel-2-l2a\"],     datetime=\"2024-06-01/2024-09-01\",     query={\"eo:cloud_cover\": {\"lt\": 5}},  # Filter to images with &lt;5% cloud )  # Load data into xarray format ds = odc.stac.load(     items=list(query.items()),     bands=[\"red\", \"green\", \"blue\"],     crs=\"utm\",     resolution=200,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  # Rescale data to be between 0 and 1 using ESA offset/scaling factors ds = (ds - 1000) / 10000  # Plot a sample image ds.isel(time=0).odc.to_rgba(vmin=0.0, vmax=0.3).plot.imshow(aspect=1, size=8) Out[2]: <pre>&lt;matplotlib.image.AxesImage at 0x7fb2c014e200&gt;</pre> <pre>/env/lib/python3.10/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n</pre> In\u00a0[3]: Copied! <pre>from eo_tides.eo import tag_tides\n\ntides_da = tag_tides(\n    data=ds,\n    model=model,\n    directory=directory,\n)\n\n# Print modelled tides\ntides_da\n</pre> from eo_tides.eo import tag_tides  tides_da = tag_tides(     data=ds,     model=model,     directory=directory, )  # Print modelled tides tides_da <pre>Setting tide modelling location from dataset centroid: 121.95, -18.00\nModelling tides with EOT20\n</pre> Out[3]: <pre>&lt;xarray.DataArray 'tide_height' (time: 18)&gt; Size: 72B\narray([-0.9524104 ,  3.3281734 ,  0.208829  , -0.56381875,  2.562395  ,\n        0.12576336, -1.1694502 ,  2.794369  , -0.42654848, -0.84082526,\n        2.6538763 , -1.0488869 , -0.637552  , -0.72000617, -0.64087266,\n        3.0885904 , -1.5969971 ,  0.43049794], dtype=float32)\nCoordinates:\n  * time        (time) datetime64[ns] 144B 2024-06-01T02:04:49.024000 ... 202...\n    tide_model  &lt;U5 20B 'EOT20'</pre>xarray.DataArray'tide_height'<ul><li>time: 18</li></ul><ul><li>-0.9524 3.328 0.2088 -0.5638 2.562 ... -0.6409 3.089 -1.597 0.4305<pre>array([-0.9524104 ,  3.3281734 ,  0.208829  , -0.56381875,  2.562395  ,\n        0.12576336, -1.1694502 ,  2.794369  , -0.42654848, -0.84082526,\n        2.6538763 , -1.0488869 , -0.637552  , -0.72000617, -0.64087266,\n        3.0885904 , -1.5969971 ,  0.43049794], dtype=float32)</pre></li><li>Coordinates: (2)<ul><li>time(time)datetime64[ns]2024-06-01T02:04:49.024000 ... 2...<pre>array(['2024-06-01T02:04:49.024000000', '2024-06-06T02:04:51.024000000',\n       '2024-06-11T02:04:49.024000000', '2024-06-16T02:04:51.024000000',\n       '2024-06-21T02:04:49.024000000', '2024-06-26T02:04:51.024000000',\n       '2024-07-01T02:04:49.024000000', '2024-07-06T02:04:51.024000000',\n       '2024-07-11T02:04:49.024000000', '2024-07-16T02:04:51.024000000',\n       '2024-07-21T02:04:49.024000000', '2024-07-26T02:04:51.024000000',\n       '2024-07-31T02:04:49.024000000', '2024-08-10T02:04:49.024000000',\n       '2024-08-15T02:04:51.024000000', '2024-08-20T02:04:49.024000000',\n       '2024-08-25T02:04:41.024000000', '2024-08-30T02:04:49.024000000'],\n      dtype='datetime64[ns]')</pre></li><li>tide_model()&lt;U5'EOT20'<pre>array('EOT20', dtype='&lt;U5')</pre></li></ul></li><li>Indexes: (1)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2024-06-01 02:04:49.024000', '2024-06-06 02:04:51.024000',\n               '2024-06-11 02:04:49.024000', '2024-06-16 02:04:51.024000',\n               '2024-06-21 02:04:49.024000', '2024-06-26 02:04:51.024000',\n               '2024-07-01 02:04:49.024000', '2024-07-06 02:04:51.024000',\n               '2024-07-11 02:04:49.024000', '2024-07-16 02:04:51.024000',\n               '2024-07-21 02:04:49.024000', '2024-07-26 02:04:51.024000',\n               '2024-07-31 02:04:49.024000', '2024-08-10 02:04:49.024000',\n               '2024-08-15 02:04:51.024000', '2024-08-20 02:04:49.024000',\n               '2024-08-25 02:04:41.024000', '2024-08-30 02:04:49.024000'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>We can easily combine these modelled tides with our original satellite data for further analysis. The code below adds our modelled tides as a new <code>tide_height</code> variable under Data variables.</p> In\u00a0[4]: Copied! <pre>ds[\"tide_height\"] = tides_da\nds\n</pre> ds[\"tide_height\"] = tides_da ds Out[4]: <pre>&lt;xarray.Dataset&gt; Size: 64MB\nDimensions:      (y: 558, x: 533, time: 18)\nCoordinates:\n  * y            (y) float64 4kB 8.065e+06 8.065e+06 ... 7.954e+06 7.954e+06\n  * x            (x) float64 4kB 3.355e+05 3.357e+05 ... 4.417e+05 4.419e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 144B 2024-06-01T02:04:49.024000 ... 20...\n    tide_model   &lt;U5 20B 'EOT20'\nData variables:\n    red          (time, y, x) float32 21MB dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;\n    green        (time, y, x) float32 21MB dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;\n    blue         (time, y, x) float32 21MB dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;\n    tide_height  (time) float32 72B -0.9524 3.328 0.2088 ... 3.089 -1.597 0.4305</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 558</li><li>x: 533</li><li>time: 18</li></ul></li><li>Coordinates: (5)<ul><li>y(y)float648.065e+06 8.065e+06 ... 7.954e+06units :metreresolution :-200.0crs :EPSG:32751<pre>array([8065100., 8064900., 8064700., ..., 7954100., 7953900., 7953700.])</pre></li><li>x(x)float643.355e+05 3.357e+05 ... 4.419e+05units :metreresolution :200.0crs :EPSG:32751<pre>array([335500., 335700., 335900., ..., 441500., 441700., 441900.])</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996GeoTransform :335400 200 0 8065200 0 -200<pre>array(32751, dtype=int32)</pre></li><li>time(time)datetime64[ns]2024-06-01T02:04:49.024000 ... 2...<pre>array(['2024-06-01T02:04:49.024000000', '2024-06-06T02:04:51.024000000',\n       '2024-06-11T02:04:49.024000000', '2024-06-16T02:04:51.024000000',\n       '2024-06-21T02:04:49.024000000', '2024-06-26T02:04:51.024000000',\n       '2024-07-01T02:04:49.024000000', '2024-07-06T02:04:51.024000000',\n       '2024-07-11T02:04:49.024000000', '2024-07-16T02:04:51.024000000',\n       '2024-07-21T02:04:49.024000000', '2024-07-26T02:04:51.024000000',\n       '2024-07-31T02:04:49.024000000', '2024-08-10T02:04:49.024000000',\n       '2024-08-15T02:04:51.024000000', '2024-08-20T02:04:49.024000000',\n       '2024-08-25T02:04:41.024000000', '2024-08-30T02:04:49.024000000'],\n      dtype='datetime64[ns]')</pre></li><li>tide_model()&lt;U5'EOT20'<pre>array('EOT20', dtype='&lt;U5')</pre></li></ul></li><li>Data variables: (4)<ul><li>red(time, y, x)float32dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;  Array   Chunk   Bytes   20.42 MiB   1.13 MiB   Shape   (18, 558, 533)   (1, 558, 533)   Dask graph   18 chunks in 5 graph layers   Data type   float32 numpy.ndarray  533 558 18 </li><li>green(time, y, x)float32dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;  Array   Chunk   Bytes   20.42 MiB   1.13 MiB   Shape   (18, 558, 533)   (1, 558, 533)   Dask graph   18 chunks in 5 graph layers   Data type   float32 numpy.ndarray  533 558 18 </li><li>blue(time, y, x)float32dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;  Array   Chunk   Bytes   20.42 MiB   1.13 MiB   Shape   (18, 558, 533)   (1, 558, 533)   Dask graph   18 chunks in 5 graph layers   Data type   float32 numpy.ndarray  533 558 18 </li><li>tide_height(time)float32-0.9524 3.328 ... -1.597 0.4305<pre>array([-0.9524104 ,  3.3281734 ,  0.208829  , -0.56381875,  2.562395  ,\n        0.12576336, -1.1694502 ,  2.794369  , -0.42654848, -0.84082526,\n        2.6538763 , -1.0488869 , -0.637552  , -0.72000617, -0.64087266,\n        3.0885904 , -1.5969971 ,  0.43049794], dtype=float32)</pre></li></ul></li><li>Indexes: (3)<ul><li>yPandasIndex<pre>PandasIndex(Index([8065100.0, 8064900.0, 8064700.0, 8064500.0, 8064300.0, 8064100.0,\n       8063900.0, 8063700.0, 8063500.0, 8063300.0,\n       ...\n       7955500.0, 7955300.0, 7955100.0, 7954900.0, 7954700.0, 7954500.0,\n       7954300.0, 7954100.0, 7953900.0, 7953700.0],\n      dtype='float64', name='y', length=558))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([335500.0, 335700.0, 335900.0, 336100.0, 336300.0, 336500.0, 336700.0,\n       336900.0, 337100.0, 337300.0,\n       ...\n       440100.0, 440300.0, 440500.0, 440700.0, 440900.0, 441100.0, 441300.0,\n       441500.0, 441700.0, 441900.0],\n      dtype='float64', name='x', length=533))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2024-06-01 02:04:49.024000', '2024-06-06 02:04:51.024000',\n               '2024-06-11 02:04:49.024000', '2024-06-16 02:04:51.024000',\n               '2024-06-21 02:04:49.024000', '2024-06-26 02:04:51.024000',\n               '2024-07-01 02:04:49.024000', '2024-07-06 02:04:51.024000',\n               '2024-07-11 02:04:49.024000', '2024-07-16 02:04:51.024000',\n               '2024-07-21 02:04:49.024000', '2024-07-26 02:04:51.024000',\n               '2024-07-31 02:04:49.024000', '2024-08-10 02:04:49.024000',\n               '2024-08-15 02:04:51.024000', '2024-08-20 02:04:49.024000',\n               '2024-08-25 02:04:41.024000', '2024-08-30 02:04:49.024000'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>Tip</p> <p>         You could also model tides and insert them into <code>ds</code> in a single step via: <code>ds[\"tide_height\"] = tag_tides(ds, ...)</code> </p> <p>We can plot this new <code>tide_height</code> variable over time to inspect the tide heights observed by the satellites in our time series:</p> In\u00a0[5]: Copied! <pre>ds.tide_height.plot()\n</pre> ds.tide_height.plot() Out[5]: <pre>[&lt;matplotlib.lines.Line2D at 0x7fb2a0796bf0&gt;]</pre> In\u00a0[6]: Copied! <pre># Sort by tide and plot the first and last image\nds_sorted = ds.sortby(\"tide_height\")\nds_sorted.isel(time=[0, -1]).odc.to_rgba(vmin=0, vmax=0.3).plot.imshow(col=\"time\", size=8)\n</pre> # Sort by tide and plot the first and last image ds_sorted = ds.sortby(\"tide_height\") ds_sorted.isel(time=[0, -1]).odc.to_rgba(vmin=0, vmax=0.3).plot.imshow(col=\"time\", size=8) <pre>/env/lib/python3.10/site-packages/odc/geo/_rgba.py:56: RuntimeWarning: invalid value encountered in cast\n  return x.astype(\"uint8\")\n/env/lib/python3.10/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n</pre> Out[6]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7fb2a06316c0&gt;</pre> <p><code>pixel_tides</code> can be run the same way as <code>tag_tides</code>, passing our satellite dataset <code>ds</code> as an input:</p> In\u00a0[7]: Copied! <pre>from eo_tides.eo import pixel_tides\n\n# Model tides spatially\ntides_lowres = pixel_tides(\n    data=ds,\n    resample=False,\n    model=model,\n    directory=directory,\n)\n\n# Inspect output\ntides_lowres\n</pre> from eo_tides.eo import pixel_tides  # Model tides spatially tides_lowres = pixel_tides(     data=ds,     resample=False,     model=model,     directory=directory, )  # Inspect output tides_lowres <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\n</pre> Out[7]: <pre>&lt;xarray.DataArray 'tide_height' (time: 18, y: 28, x: 27)&gt; Size: 54kB\narray([[[-0.7362808 , -0.7471555 , -0.7576386 , ..., -0.8152949 ,\n         -0.6573758 , -0.6573758 ],\n        [-0.7444582 , -0.7551327 , -0.7654623 , ..., -0.8152949 ,\n         -0.8152949 , -0.8152949 ],\n        [-0.75263894, -0.76311225, -0.77328825, ..., -0.8648062 ,\n         -0.8648062 , -0.8648062 ],\n        ...,\n        [-0.96399516, -0.9707319 , -0.9770214 , ..., -0.97764623,\n         -0.97764623, -0.96796334],\n        [-0.9731417 , -0.97980195, -0.985913  , ..., -0.97764623,\n         -0.97764623, -0.97764623],\n        [-0.9822894 , -0.9888731 , -0.9948081 , ..., -0.97764623,\n         -0.97764623, -0.97764623]],\n\n       [[ 2.604429  ,  2.6368601 ,  2.6686993 , ...,  2.9544168 ,\n          2.8497264 ,  2.8497264 ],\n        [ 2.6289322 ,  2.660859  ,  2.6924207 , ...,  2.9544168 ,\n          2.9544168 ,  2.9544168 ],\n        [ 2.6534436 ,  2.6848621 ,  2.7161462 , ...,  3.0271842 ,\n          3.0271842 ,  3.0271842 ],\n...\n        [-1.6290736 , -1.6375278 , -1.6452484 , ..., -1.8998238 ,\n         -1.8998238 , -1.9482391 ],\n        [-1.6552702 , -1.6639447 , -1.6722901 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ],\n        [-1.6814624 , -1.6903573 , -1.6993189 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ]],\n\n       [[ 0.30038768,  0.30576816,  0.31126216, ...,  0.4517303 ,\n          0.5425337 ,  0.5425337 ],\n        [ 0.30484238,  0.3101346 ,  0.31552827, ...,  0.4517303 ,\n          0.4517303 ,  0.4517303 ],\n        [ 0.3092985 ,  0.31450257,  0.3197959 , ...,  0.43224597,\n          0.43224597,  0.43224597],\n        ...,\n        [ 0.41501197,  0.41987243,  0.4240904 , ...,  0.49932253,\n          0.49932253,  0.51389307],\n        [ 0.4201587 ,  0.42513692,  0.4295195 , ...,  0.49932253,\n          0.49932253,  0.49932253],\n        [ 0.42530313,  0.43039918,  0.43494555, ...,  0.49932253,\n          0.49932253,  0.49932253]]], dtype=float32)\nCoordinates:\n  * time         (time) datetime64[ns] 144B 2024-06-01T02:04:49.024000 ... 20...\n  * x            (x) float64 216B 3.225e+05 3.275e+05 ... 4.475e+05 4.525e+05\n  * y            (y) float64 224B 8.078e+06 8.072e+06 ... 7.948e+06 7.942e+06\n    tide_model   &lt;U5 20B 'EOT20'\n    spatial_ref  int32 4B 32751</pre>xarray.DataArray'tide_height'<ul><li>time: 18</li><li>y: 28</li><li>x: 27</li></ul><ul><li>-0.7363 -0.7472 -0.7576 -0.7681 ... 0.4993 0.4993 0.4993 0.4993<pre>array([[[-0.7362808 , -0.7471555 , -0.7576386 , ..., -0.8152949 ,\n         -0.6573758 , -0.6573758 ],\n        [-0.7444582 , -0.7551327 , -0.7654623 , ..., -0.8152949 ,\n         -0.8152949 , -0.8152949 ],\n        [-0.75263894, -0.76311225, -0.77328825, ..., -0.8648062 ,\n         -0.8648062 , -0.8648062 ],\n        ...,\n        [-0.96399516, -0.9707319 , -0.9770214 , ..., -0.97764623,\n         -0.97764623, -0.96796334],\n        [-0.9731417 , -0.97980195, -0.985913  , ..., -0.97764623,\n         -0.97764623, -0.97764623],\n        [-0.9822894 , -0.9888731 , -0.9948081 , ..., -0.97764623,\n         -0.97764623, -0.97764623]],\n\n       [[ 2.604429  ,  2.6368601 ,  2.6686993 , ...,  2.9544168 ,\n          2.8497264 ,  2.8497264 ],\n        [ 2.6289322 ,  2.660859  ,  2.6924207 , ...,  2.9544168 ,\n          2.9544168 ,  2.9544168 ],\n        [ 2.6534436 ,  2.6848621 ,  2.7161462 , ...,  3.0271842 ,\n          3.0271842 ,  3.0271842 ],\n...\n        [-1.6290736 , -1.6375278 , -1.6452484 , ..., -1.8998238 ,\n         -1.8998238 , -1.9482391 ],\n        [-1.6552702 , -1.6639447 , -1.6722901 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ],\n        [-1.6814624 , -1.6903573 , -1.6993189 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ]],\n\n       [[ 0.30038768,  0.30576816,  0.31126216, ...,  0.4517303 ,\n          0.5425337 ,  0.5425337 ],\n        [ 0.30484238,  0.3101346 ,  0.31552827, ...,  0.4517303 ,\n          0.4517303 ,  0.4517303 ],\n        [ 0.3092985 ,  0.31450257,  0.3197959 , ...,  0.43224597,\n          0.43224597,  0.43224597],\n        ...,\n        [ 0.41501197,  0.41987243,  0.4240904 , ...,  0.49932253,\n          0.49932253,  0.51389307],\n        [ 0.4201587 ,  0.42513692,  0.4295195 , ...,  0.49932253,\n          0.49932253,  0.49932253],\n        [ 0.42530313,  0.43039918,  0.43494555, ...,  0.49932253,\n          0.49932253,  0.49932253]]], dtype=float32)</pre></li><li>Coordinates: (5)<ul><li>time(time)datetime64[ns]2024-06-01T02:04:49.024000 ... 2...<pre>array(['2024-06-01T02:04:49.024000000', '2024-06-06T02:04:51.024000000',\n       '2024-06-11T02:04:49.024000000', '2024-06-16T02:04:51.024000000',\n       '2024-06-21T02:04:49.024000000', '2024-06-26T02:04:51.024000000',\n       '2024-07-01T02:04:49.024000000', '2024-07-06T02:04:51.024000000',\n       '2024-07-11T02:04:49.024000000', '2024-07-16T02:04:51.024000000',\n       '2024-07-21T02:04:49.024000000', '2024-07-26T02:04:51.024000000',\n       '2024-07-31T02:04:49.024000000', '2024-08-10T02:04:49.024000000',\n       '2024-08-15T02:04:51.024000000', '2024-08-20T02:04:49.024000000',\n       '2024-08-25T02:04:41.024000000', '2024-08-30T02:04:49.024000000'],\n      dtype='datetime64[ns]')</pre></li><li>x(x)float643.225e+05 3.275e+05 ... 4.525e+05<pre>array([322500., 327500., 332500., 337500., 342500., 347500., 352500., 357500.,\n       362500., 367500., 372500., 377500., 382500., 387500., 392500., 397500.,\n       402500., 407500., 412500., 417500., 422500., 427500., 432500., 437500.,\n       442500., 447500., 452500.])</pre></li><li>y(y)float648.078e+06 8.072e+06 ... 7.942e+06<pre>array([8077500., 8072500., 8067500., 8062500., 8057500., 8052500., 8047500.,\n       8042500., 8037500., 8032500., 8027500., 8022500., 8017500., 8012500.,\n       8007500., 8002500., 7997500., 7992500., 7987500., 7982500., 7977500.,\n       7972500., 7967500., 7962500., 7957500., 7952500., 7947500., 7942500.])</pre></li><li>tide_model()&lt;U5'EOT20'<pre>array('EOT20', dtype='&lt;U5')</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996<pre>array(32751, dtype=int32)</pre></li></ul></li><li>Indexes: (3)<ul><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2024-06-01 02:04:49.024000', '2024-06-06 02:04:51.024000',\n               '2024-06-11 02:04:49.024000', '2024-06-16 02:04:51.024000',\n               '2024-06-21 02:04:49.024000', '2024-06-26 02:04:51.024000',\n               '2024-07-01 02:04:49.024000', '2024-07-06 02:04:51.024000',\n               '2024-07-11 02:04:49.024000', '2024-07-16 02:04:51.024000',\n               '2024-07-21 02:04:49.024000', '2024-07-26 02:04:51.024000',\n               '2024-07-31 02:04:49.024000', '2024-08-10 02:04:49.024000',\n               '2024-08-15 02:04:51.024000', '2024-08-20 02:04:49.024000',\n               '2024-08-25 02:04:41.024000', '2024-08-30 02:04:49.024000'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([322500.0, 327500.0, 332500.0, 337500.0, 342500.0, 347500.0, 352500.0,\n       357500.0, 362500.0, 367500.0, 372500.0, 377500.0, 382500.0, 387500.0,\n       392500.0, 397500.0, 402500.0, 407500.0, 412500.0, 417500.0, 422500.0,\n       427500.0, 432500.0, 437500.0, 442500.0, 447500.0, 452500.0],\n      dtype='float64', name='x'))</pre></li><li>yPandasIndex<pre>PandasIndex(Index([8077500.0, 8072500.0, 8067500.0, 8062500.0, 8057500.0, 8052500.0,\n       8047500.0, 8042500.0, 8037500.0, 8032500.0, 8027500.0, 8022500.0,\n       8017500.0, 8012500.0, 8007500.0, 8002500.0, 7997500.0, 7992500.0,\n       7987500.0, 7982500.0, 7977500.0, 7972500.0, 7967500.0, 7962500.0,\n       7957500.0, 7952500.0, 7947500.0, 7942500.0],\n      dtype='float64', name='y'))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>If we plot the resulting data, we can see that we now have two-dimensional tide surfaces for each timestep in our data (instead of the single tide height per timestamp returned by the <code>tag_tides</code> function).</p> <p>Red below indicates low tide pixels, while blue indicates high tide pixels. If you look closely, you may see some spatial variability in tide heights within each timestep, with slight variations in tide heights along the north-west side of the study area:</p> In\u00a0[8]: Copied! <pre># Plot the first four timesteps in our data\ntides_lowres.isel(time=[0, 1, 2, 3]).plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\")\n</pre> # Plot the first four timesteps in our data tides_lowres.isel(time=[0, 1, 2, 3]).plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\") Out[8]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7fb2a0794a60&gt;</pre> In\u00a0[9]: Copied! <pre># Model tides spatially\ntides_lowres = pixel_tides(\n    data=ds,\n    resample=False,\n    extrapolate=False,\n    model=model,\n    directory=directory,\n)\n\n# Plot the first four timesteps in our data\ntides_lowres.isel(time=[0, 1, 2, 3]).plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\")\n</pre> # Model tides spatially tides_lowres = pixel_tides(     data=ds,     resample=False,     extrapolate=False,     model=model,     directory=directory, )  # Plot the first four timesteps in our data tides_lowres.isel(time=[0, 1, 2, 3]).plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\n</pre> Out[9]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7fb29c73bf10&gt;</pre> In\u00a0[10]: Copied! <pre># Model tides spatially\ntides_highres = pixel_tides(\n    data=ds,\n    resample=True,\n    model=model,\n    directory=directory,\n)\n\n# Plot the first four timesteps in our data\ntides_highres.isel(time=[0, 1, 2, 3]).plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\")\n</pre> # Model tides spatially tides_highres = pixel_tides(     data=ds,     resample=True,     model=model,     directory=directory, )  # Plot the first four timesteps in our data tides_highres.isel(time=[0, 1, 2, 3]).plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReprojecting tides into original resolution\n</pre> Out[10]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7fb29c531480&gt;</pre> <p><code>tides_highres</code> will have exactly the same dimensions as <code>ds</code>, with a unique tide height for every satellite pixel:</p> In\u00a0[11]: Copied! <pre>print(f\"x: {len(ds.x)}, y: {len(ds.y)}, time: {len(ds.time)}\")\n</pre> print(f\"x: {len(ds.x)}, y: {len(ds.y)}, time: {len(ds.time)}\") <pre>x: 533, y: 558, time: 18\n</pre> In\u00a0[12]: Copied! <pre>print(f\"x: {len(tides_highres.x)}, y: {len(tides_highres.y)}, time: {len(tides_highres.time)}\")\n</pre> print(f\"x: {len(tides_highres.x)}, y: {len(tides_highres.y)}, time: {len(tides_highres.time)}\") <pre>x: 533, y: 558, time: 18\n</pre> <p>Because of this, our stack of tides can be added as an additional 3D variable in our dataset:</p> In\u00a0[13]: Copied! <pre>ds[\"tide_height\"] = tides_highres\nds\n</pre> ds[\"tide_height\"] = tides_highres ds Out[13]: <pre>&lt;xarray.Dataset&gt; Size: 86MB\nDimensions:      (y: 558, x: 533, time: 18)\nCoordinates:\n  * y            (y) float64 4kB 8.065e+06 8.065e+06 ... 7.954e+06 7.954e+06\n  * x            (x) float64 4kB 3.355e+05 3.357e+05 ... 4.417e+05 4.419e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 144B 2024-06-01T02:04:49.024000 ... 20...\n    tide_model   &lt;U5 20B 'EOT20'\nData variables:\n    red          (time, y, x) float32 21MB dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;\n    green        (time, y, x) float32 21MB dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;\n    blue         (time, y, x) float32 21MB dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;\n    tide_height  (time, y, x) float32 21MB -0.7831 -0.7835 ... 0.4993 0.4993</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 558</li><li>x: 533</li><li>time: 18</li></ul></li><li>Coordinates: (5)<ul><li>y(y)float648.065e+06 8.065e+06 ... 7.954e+06units :metreresolution :-200.0crs :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]<pre>array([8065100., 8064900., 8064700., ..., 7954100., 7953900., 7953700.])</pre></li><li>x(x)float643.355e+05 3.357e+05 ... 4.419e+05units :metreresolution :200.0crs :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]<pre>array([335500., 335700., 335900., ..., 441500., 441700., 441900.])</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996GeoTransform :335400 200 0 8065200 0 -200<pre>array(32751, dtype=int32)</pre></li><li>time(time)datetime64[ns]2024-06-01T02:04:49.024000 ... 2...<pre>array(['2024-06-01T02:04:49.024000000', '2024-06-06T02:04:51.024000000',\n       '2024-06-11T02:04:49.024000000', '2024-06-16T02:04:51.024000000',\n       '2024-06-21T02:04:49.024000000', '2024-06-26T02:04:51.024000000',\n       '2024-07-01T02:04:49.024000000', '2024-07-06T02:04:51.024000000',\n       '2024-07-11T02:04:49.024000000', '2024-07-16T02:04:51.024000000',\n       '2024-07-21T02:04:49.024000000', '2024-07-26T02:04:51.024000000',\n       '2024-07-31T02:04:49.024000000', '2024-08-10T02:04:49.024000000',\n       '2024-08-15T02:04:51.024000000', '2024-08-20T02:04:49.024000000',\n       '2024-08-25T02:04:41.024000000', '2024-08-30T02:04:49.024000000'],\n      dtype='datetime64[ns]')</pre></li><li>tide_model()&lt;U5'EOT20'<pre>array('EOT20', dtype='&lt;U5')</pre></li></ul></li><li>Data variables: (4)<ul><li>red(time, y, x)float32dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;  Array   Chunk   Bytes   20.42 MiB   1.13 MiB   Shape   (18, 558, 533)   (1, 558, 533)   Dask graph   18 chunks in 5 graph layers   Data type   float32 numpy.ndarray  533 558 18 </li><li>green(time, y, x)float32dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;  Array   Chunk   Bytes   20.42 MiB   1.13 MiB   Shape   (18, 558, 533)   (1, 558, 533)   Dask graph   18 chunks in 5 graph layers   Data type   float32 numpy.ndarray  533 558 18 </li><li>blue(time, y, x)float32dask.array&lt;chunksize=(1, 558, 533), meta=np.ndarray&gt;  Array   Chunk   Bytes   20.42 MiB   1.13 MiB   Shape   (18, 558, 533)   (1, 558, 533)   Dask graph   18 chunks in 5 graph layers   Data type   float32 numpy.ndarray  533 558 18 </li><li>tide_height(time, y, x)float32-0.7831 -0.7835 ... 0.4993 0.4993<pre>array([[[-0.7831177 , -0.7835217 , -0.7839257 , ..., -0.8648062 ,\n         -0.8648062 , -0.8648062 ],\n        [-0.78342825, -0.783832  , -0.7842358 , ..., -0.8648062 ,\n         -0.8648062 , -0.8648062 ],\n        [-0.7837388 , -0.7841423 , -0.78454584, ..., -0.8648062 ,\n         -0.8648062 , -0.8648062 ],\n        ...,\n        [-0.9778991 , -0.97814953, -0.97840005, ..., -0.97764623,\n         -0.97764623, -0.97764623],\n        [-0.97825277, -0.9785028 , -0.9787529 , ..., -0.97764623,\n         -0.97764623, -0.97764623],\n        [-0.97860646, -0.9788561 , -0.9791058 , ..., -0.97764623,\n         -0.97764623, -0.97764623]],\n\n       [[ 2.7461238 ,  2.747369  ,  2.748614  , ...,  3.0271842 ,\n          3.0271842 ,  3.0271842 ],\n        [ 2.7470584 ,  2.748303  ,  2.7495477 , ...,  3.0271842 ,\n          3.0271842 ,  3.0271842 ],\n        [ 2.7479928 ,  2.7492368 ,  2.7504811 , ...,  3.0271842 ,\n          3.0271842 ,  3.0271842 ],\n...\n        [-1.6422844 , -1.642588  , -1.6428916 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ],\n        [-1.6432214 , -1.6435248 , -1.6438282 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ],\n        [-1.6441582 , -1.6444615 , -1.6447648 , ..., -1.8998238 ,\n         -1.8998238 , -1.8998238 ]],\n\n       [[ 0.3249231 ,  0.3251329 ,  0.32534268, ...,  0.43224597,\n          0.43224597,  0.43224597],\n        [ 0.32508585,  0.32529548,  0.3255051 , ...,  0.43224597,\n          0.43224597,  0.43224597],\n        [ 0.32524857,  0.32545805,  0.32566753, ...,  0.43224597,\n          0.43224597,  0.43224597],\n        ...,\n        [ 0.4249595 ,  0.42512137,  0.42528322, ...,  0.49932253,\n          0.49932253,  0.49932253],\n        [ 0.4251559 ,  0.42531788,  0.42547983, ...,  0.49932253,\n          0.49932253,  0.49932253],\n        [ 0.4253523 ,  0.42551437,  0.42567644, ...,  0.49932253,\n          0.49932253,  0.49932253]]], dtype=float32)</pre></li></ul></li><li>Indexes: (3)<ul><li>yPandasIndex<pre>PandasIndex(Index([8065100.0, 8064900.0, 8064700.0, 8064500.0, 8064300.0, 8064100.0,\n       8063900.0, 8063700.0, 8063500.0, 8063300.0,\n       ...\n       7955500.0, 7955300.0, 7955100.0, 7954900.0, 7954700.0, 7954500.0,\n       7954300.0, 7954100.0, 7953900.0, 7953700.0],\n      dtype='float64', name='y', length=558))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([335500.0, 335700.0, 335900.0, 336100.0, 336300.0, 336500.0, 336700.0,\n       336900.0, 337100.0, 337300.0,\n       ...\n       440100.0, 440300.0, 440500.0, 440700.0, 440900.0, 441100.0, 441300.0,\n       441500.0, 441700.0, 441900.0],\n      dtype='float64', name='x', length=533))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2024-06-01 02:04:49.024000', '2024-06-06 02:04:51.024000',\n               '2024-06-11 02:04:49.024000', '2024-06-16 02:04:51.024000',\n               '2024-06-21 02:04:49.024000', '2024-06-26 02:04:51.024000',\n               '2024-07-01 02:04:49.024000', '2024-07-06 02:04:51.024000',\n               '2024-07-11 02:04:49.024000', '2024-07-16 02:04:51.024000',\n               '2024-07-21 02:04:49.024000', '2024-07-26 02:04:51.024000',\n               '2024-07-31 02:04:49.024000', '2024-08-10 02:04:49.024000',\n               '2024-08-15 02:04:51.024000', '2024-08-20 02:04:49.024000',\n               '2024-08-25 02:04:41.024000', '2024-08-30 02:04:49.024000'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[14]: Copied! <pre># Model tides spatially\ntides_highres_quantiles = pixel_tides(\n    data=ds,\n    calculate_quantiles=(0, 0.5, 1),\n    model=model,\n    directory=directory,\n)\n\n# Plot tide height quantiles\ntides_highres_quantiles.plot.imshow(col=\"quantile\", vmin=-3, vmax=3, cmap=\"RdBu\")\n</pre> # Model tides spatially tides_highres_quantiles = pixel_tides(     data=ds,     calculate_quantiles=(0, 0.5, 1),     model=model,     directory=directory, )  # Plot tide height quantiles tides_highres_quantiles.plot.imshow(col=\"quantile\", vmin=-3, vmax=3, cmap=\"RdBu\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nComputing tide quantiles\nReprojecting tides into original resolution\n</pre> Out[14]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7fb29c2e84c0&gt;</pre> In\u00a0[15]: Copied! <pre>import pandas as pd\n\ncustom_times = pd.date_range(\n    start=\"2022-01-01\",\n    end=\"2022-01-02\",\n    freq=\"6h\",\n)\n\n# Model tides spatially\ntides_highres = pixel_tides(\n    data=ds,\n    time=custom_times,\n    model=model,\n    directory=directory,\n)\n\n# Plot custom timesteps\ntides_highres.plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\")\n</pre> import pandas as pd  custom_times = pd.date_range(     start=\"2022-01-01\",     end=\"2022-01-02\",     freq=\"6h\", )  # Model tides spatially tides_highres = pixel_tides(     data=ds,     time=custom_times,     model=model,     directory=directory, )  # Plot custom timesteps tides_highres.plot.imshow(col=\"time\", vmin=-3, vmax=3, cmap=\"RdBu\") <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReprojecting tides into original resolution\n</pre> Out[15]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x7fb29c2bec20&gt;</pre>"},{"location":"notebooks/Satellite_data/#combining-tides-with-satellite-data","title":"Combining tides with satellite data\u00b6","text":"<p>This guide demonstrates how to combine tide modelling with satellite Earth observation (EO) data using the <code>tag_tides</code> and <code>pixel_tides</code> functions from <code>eo_tides.eo</code>.</p> <p>Both these functions allow you to model the height of the tide at the exact moment of satellite image acquisition. This can then allow you to analyse satellite EO data by tidal conditions - for example, filter your data to satellite imagery collected during specific tidal stages (e.g. low or high tide).</p> <p>Although both functions perform a similar function, they differ in complexity and performance. <code>tag_tides</code> assigns a single tide height to each timestep/satellite image, which is fast and efficient, and suitable for small-scale applications where tides are unlikely to vary across your study area. In contrast, <code>pixel_tide</code> models tides both through time and spatially, returning a tide height for every satellite pixel. This can be critical for producing seamless coastal EO datasets at large scale - however comes at the cost of performance. </p> <p>Table 1. Comparison of <code>tag_tides</code> and <code>pixel_tides</code></p> <code>tag_tides</code> <code>pixel_tides</code> Assigns a single tide height to each timestep/satellite image Assigns a tide height to every individual pixel through time to capture spatial tide dynamics \ud83d\udd0e Ideal for local or site-scale analysis \ud83c\udf0f Ideal for regional to global-scale coastal product generation \u2705 Fast, low memory use \u274c Slower, higher memory use \u274c Single tide height per image can produce artefacts in complex tidal regions \u2705 Produce spatially seamless results across large extents by applying analyses at the pixel level"},{"location":"notebooks/Satellite_data/#getting-started","title":"Getting started\u00b6","text":"<p>As in the previous example, our first step is to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here).</p> <p>We can also define the tide model we want to use the for analysis; for example, the default model \"EOT20\".</p>"},{"location":"notebooks/Satellite_data/#load-satellite-data-using-odc-stac","title":"Load satellite data using odc-stac\u00b6","text":"<p>Now we can load a time-series of satellite data over our area of interest using the Open Data Cube's <code>odc-stac</code> package. This powerful package allows us to load open satellite data (e.g ESA Sentinel-2 or NASA/USGS Landsat) for any time period and location on the planet, and load our data into a multi-dimensional <code>xarray.Dataset</code> format dataset.</p> <p>In this example, we will load Sentinel-2 satellite data from 2024 over the city of Broome, Western Australia - a macrotidal region with extensive intertidal coastal habitats. We will load this data from the Microsoft Planetary Computer STAC catalogue.</p> <p>Tip</p> <p>         For a more detailed guide to using STAC metadata and <code>odc-stac</code> to find and load satellite data, refer to the odc-stac Python package documentation. <code>eo-tides</code> is compatible with satellite data loaded from any STAC API, for example Digital Earth Australia.     </p>"},{"location":"notebooks/Satellite_data/#using-tag_tides","title":"Using tag_tides\u00b6","text":"<p>We can pass our satellite dataset <code>ds</code> to the <code>tag_tides</code> function to model a tide for each timestep in our dataset. This can help sort and filter images by tide height, allowing us to learn more about how coastal environments respond to the effect of changing tides.</p> <p>The <code>tag_tides</code> function uses the time and date of acquisition and the geographic centroid of each satellite observation as inputs for the selected tide model (EOT20 by default). It returns an <code>xarray.DataArray</code> called <code>tide_height</code>, with a modelled tide for every timestep in our satellite dataset:</p>"},{"location":"notebooks/Satellite_data/#selecting-and-analysing-satellite-data-by-tide","title":"Selecting and analysing satellite data by tide\u00b6","text":"<p>Having <code>tide_height</code> as a variable allows us to select and analyse our satellite data using information about tides. For example, we could sort by <code>tide_height</code>, then plot the lowest and highest tide images in our time series:</p>"},{"location":"notebooks/Satellite_data/#using-pixel_tides","title":"Using pixel_tides\u00b6","text":"<p>The previous examples show how to model a single tide height for each satellite image using the centroid of the image as a tide modelling location. However, in reality tides vary spatially \u2013 potentially by several metres in areas of complex tidal dynamics. This means that an individual satellite image can capture a range of tide conditions.</p> <p>We can use the <code>pixel_tides</code> function to capture this spatial variability in tide heights. For efficient processing, this function first models tides into a low resolution grid surrounding each satellite image in our time series. This lower resolution data includes a buffer around the extent of our satellite data so that tides can be modelled seamlessly across analysis boundaries.</p>"},{"location":"notebooks/Satellite_data/#extrapolation","title":"Extrapolation\u00b6","text":"<p>You may notice that modelled tides cover the entire 2D spatial extent of our images, even though the eastern side of our study area is land. This is because by default, <code>eo-tides</code> will extrapolate tide values into every pixel using nearest neighbour interpolation. This ensures every coastal pixel is allocated a tide height, but can produce inaccurate results the further a pixel is located from the ocean.</p> <p>To turn off extrapolation, pass <code>extrapolate=False</code>:</p>"},{"location":"notebooks/Satellite_data/#reprojecting-into-original-high-resolution-spatial-grid","title":"Reprojecting into original high-resolution spatial grid\u00b6","text":"<p>By setting <code>resample=True</code>, we can use interpolation to re-project our low resolution tide data back into the resolution of our satellite image, resulting in an individual tide height for every pixel in our dataset through time and space:</p>"},{"location":"notebooks/Satellite_data/#calculating-tide-height-minmaxmedianquantiles-for-each-pixel","title":"Calculating tide height min/max/median/quantiles for each pixel\u00b6","text":"<p>Min, max or any specific quantile of all tide heights observed over a region can be calculated for each pixel by passing in a list of quantiles/percentiles using the <code>calculate_quantiles</code> parameter.</p> <p>This calculation is performed on the low resolution modelled tide data before reprojecting to higher resolution, so should be faster than calculating min/max/median tide at high resolution:</p>"},{"location":"notebooks/Satellite_data/#modelling-custom-times","title":"Modelling custom times\u00b6","text":"<p>Instead of using times contained in the <code>time</code> dimension of our dataset, we can also calculate pixel-based tides for a custom set of times:</p>"},{"location":"notebooks/Satellite_data/#next-steps","title":"Next steps\u00b6","text":"<p>Now that we have learnt to combine tide modelling with satellite data, we can learn how to calculate statistics describing local tide dynamics, as well as biases caused by interactions between tidal processes and satellite orbits.</p>"},{"location":"notebooks/Tide_statistics/","title":"Calculating tide statistics and satellite biases","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\nmodel = \"EOT20\"\n</pre> directory = \"../../tests/data/tide_models/\" model = \"EOT20\" In\u00a0[2]: Copied! <pre>import odc.stac\nimport planetary_computer\nimport pystac_client\n\n# Connect to STAC catalog\ncatalog = pystac_client.Client.open(\n    \"https://planetarycomputer.microsoft.com/api/stac/v1\",\n    modifier=planetary_computer.sign_inplace,\n)\n\n# Set cloud access defaults\nodc.stac.configure_rio(\n    cloud_defaults=True,\n    aws={\"aws_unsigned\": True},\n)\n\n# Build a query and search the STAC catalog for all matching items\nbbox = [122.160, -18.05, 122.260, -17.95]\nquery = catalog.search(\n    bbox=bbox,\n    collections=[\"sentinel-2-l2a\"],\n    datetime=\"2021/2023\",\n    query={\"eo:cloud_cover\": {\"lt\": 10}},  # Filter to images with &lt;10% cloud\n)\n\n# Load data into xarray format\nds_s2 = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"red\"],\n    crs=\"utm\",\n    resolution=100,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\n# Inspect output\nds_s2\n</pre> import odc.stac import planetary_computer import pystac_client  # Connect to STAC catalog catalog = pystac_client.Client.open(     \"https://planetarycomputer.microsoft.com/api/stac/v1\",     modifier=planetary_computer.sign_inplace, )  # Set cloud access defaults odc.stac.configure_rio(     cloud_defaults=True,     aws={\"aws_unsigned\": True}, )  # Build a query and search the STAC catalog for all matching items bbox = [122.160, -18.05, 122.260, -17.95] query = catalog.search(     bbox=bbox,     collections=[\"sentinel-2-l2a\"],     datetime=\"2021/2023\",     query={\"eo:cloud_cover\": {\"lt\": 10}},  # Filter to images with &lt;10% cloud )  # Load data into xarray format ds_s2 = odc.stac.load(     items=list(query.items()),     bands=[\"red\"],     crs=\"utm\",     resolution=100,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  # Inspect output ds_s2 Out[2]: <pre>&lt;xarray.Dataset&gt; Size: 6MB\nDimensions:      (y: 112, x: 107, time: 117)\nCoordinates:\n  * y            (y) float64 896B 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x            (x) float64 856B 4.11e+05 4.112e+05 ... 4.216e+05 4.216e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 936B 2021-01-03T02:04:51.024000 ... 20...\nData variables:\n    red          (time, y, x) float32 6MB dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 112</li><li>x: 107</li><li>time: 117</li></ul></li><li>Coordinates: (4)<ul><li>y(y)float648.015e+06 8.015e+06 ... 8.004e+06units :metreresolution :-100.0crs :EPSG:32751<pre>array([8015150., 8015050., 8014950., 8014850., 8014750., 8014650., 8014550.,\n       8014450., 8014350., 8014250., 8014150., 8014050., 8013950., 8013850.,\n       8013750., 8013650., 8013550., 8013450., 8013350., 8013250., 8013150.,\n       8013050., 8012950., 8012850., 8012750., 8012650., 8012550., 8012450.,\n       8012350., 8012250., 8012150., 8012050., 8011950., 8011850., 8011750.,\n       8011650., 8011550., 8011450., 8011350., 8011250., 8011150., 8011050.,\n       8010950., 8010850., 8010750., 8010650., 8010550., 8010450., 8010350.,\n       8010250., 8010150., 8010050., 8009950., 8009850., 8009750., 8009650.,\n       8009550., 8009450., 8009350., 8009250., 8009150., 8009050., 8008950.,\n       8008850., 8008750., 8008650., 8008550., 8008450., 8008350., 8008250.,\n       8008150., 8008050., 8007950., 8007850., 8007750., 8007650., 8007550.,\n       8007450., 8007350., 8007250., 8007150., 8007050., 8006950., 8006850.,\n       8006750., 8006650., 8006550., 8006450., 8006350., 8006250., 8006150.,\n       8006050., 8005950., 8005850., 8005750., 8005650., 8005550., 8005450.,\n       8005350., 8005250., 8005150., 8005050., 8004950., 8004850., 8004750.,\n       8004650., 8004550., 8004450., 8004350., 8004250., 8004150., 8004050.])</pre></li><li>x(x)float644.11e+05 4.112e+05 ... 4.216e+05units :metreresolution :100.0crs :EPSG:32751<pre>array([411050., 411150., 411250., 411350., 411450., 411550., 411650., 411750.,\n       411850., 411950., 412050., 412150., 412250., 412350., 412450., 412550.,\n       412650., 412750., 412850., 412950., 413050., 413150., 413250., 413350.,\n       413450., 413550., 413650., 413750., 413850., 413950., 414050., 414150.,\n       414250., 414350., 414450., 414550., 414650., 414750., 414850., 414950.,\n       415050., 415150., 415250., 415350., 415450., 415550., 415650., 415750.,\n       415850., 415950., 416050., 416150., 416250., 416350., 416450., 416550.,\n       416650., 416750., 416850., 416950., 417050., 417150., 417250., 417350.,\n       417450., 417550., 417650., 417750., 417850., 417950., 418050., 418150.,\n       418250., 418350., 418450., 418550., 418650., 418750., 418850., 418950.,\n       419050., 419150., 419250., 419350., 419450., 419550., 419650., 419750.,\n       419850., 419950., 420050., 420150., 420250., 420350., 420450., 420550.,\n       420650., 420750., 420850., 420950., 421050., 421150., 421250., 421350.,\n       421450., 421550., 421650.])</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996GeoTransform :411000 100 0 8015200 0 -100<pre>array(32751, dtype=int32)</pre></li><li>time(time)datetime64[ns]2021-01-03T02:04:51.024000 ... 2...<pre>array(['2021-01-03T02:04:51.024000000', '2021-01-13T02:04:51.024000000',\n       '2021-02-27T02:04:49.024000000', '2021-03-24T02:04:41.024000000',\n       '2021-03-29T02:04:49.024000000', '2021-04-08T02:04:39.024000000',\n       '2021-04-23T02:04:41.024000000', '2021-04-28T02:04:39.024000000',\n       '2021-05-03T02:04:41.024000000', '2021-05-08T02:04:39.024000000',\n       '2021-05-13T02:04:51.024000000', '2021-05-18T02:04:49.024000000',\n       '2021-05-23T02:04:51.024000000', '2021-05-28T02:04:49.024000000',\n       '2021-06-07T02:04:49.024000000', '2021-06-12T02:04:51.024000000',\n       '2021-06-27T02:04:49.024000000', '2021-07-02T02:04:51.024000000',\n       '2021-07-07T02:04:49.024000000', '2021-07-12T02:04:51.024000000',\n       '2021-07-17T02:04:49.024000000', '2021-08-01T02:04:51.024000000',\n       '2021-08-06T02:04:49.024000000', '2021-08-11T02:04:51.024000000',\n       '2021-08-16T02:04:49.024000000', '2021-08-21T02:04:51.024000000',\n       '2021-08-26T02:04:49.024000000', '2021-08-31T02:04:51.024000000',\n       '2021-09-05T02:04:39.024000000', '2021-09-10T02:04:51.024000000',\n       '2021-09-15T02:04:39.024000000', '2021-09-20T02:04:51.024000000',\n       '2021-09-25T02:04:49.024000000', '2021-10-05T02:04:49.024000000',\n       '2021-10-10T02:04:51.024000000', '2021-11-14T02:04:49.024000000',\n       '2021-11-19T02:04:51.024000000', '2021-11-24T02:04:39.024000000',\n       '2021-12-09T02:04:41.024000000', '2022-02-12T02:04:39.024000000',\n       '2022-02-17T02:04:51.024000000', '2022-03-29T02:04:51.024000000',\n       '2022-04-03T02:04:39.024000000', '2022-04-08T02:04:51.024000000',\n       '2022-04-18T02:04:51.024000000', '2022-05-03T02:04:39.024000000',\n       '2022-05-08T02:04:51.024000000', '2022-05-18T02:04:51.024000000',\n       '2022-05-23T02:04:49.024000000', '2022-05-28T02:04:51.024000000',\n       '2022-06-07T02:04:51.024000000', '2022-06-12T02:04:49.024000000',\n       '2022-06-17T02:05:01.024000000', '2022-06-22T02:04:49.024000000',\n       '2022-06-27T02:05:01.024000000', '2022-07-02T02:04:49.024000000',\n       '2022-07-07T02:05:01.024000000', '2022-07-12T02:04:49.024000000',\n       '2022-07-17T02:05:01.024000000', '2022-07-22T02:04:49.024000000',\n       '2022-07-27T02:05:01.024000000', '2022-08-01T02:04:49.024000000',\n       '2022-08-06T02:05:01.024000000', '2022-08-16T02:05:01.024000000',\n       '2022-08-21T02:04:49.024000000', '2022-08-26T02:05:01.024000000',\n       '2022-09-15T02:05:01.024000000', '2022-09-20T02:04:49.024000000',\n       '2022-09-25T02:04:51.024000000', '2022-10-05T02:04:51.024000000',\n       '2022-10-10T02:04:49.024000000', '2022-10-15T02:04:51.024000000',\n       '2022-10-25T02:04:51.024000000', '2022-11-04T02:04:51.024000000',\n       '2022-11-09T02:04:49.024000000', '2022-11-14T02:04:51.024000000',\n       '2022-12-04T02:04:51.024000000', '2022-12-09T02:04:39.024000000',\n       '2022-12-14T02:04:51.024000000', '2023-02-17T02:04:49.024000000',\n       '2023-03-14T02:04:41.024000000', '2023-03-19T02:04:49.024000000',\n       '2023-04-18T02:04:49.024000000', '2023-04-23T02:04:41.024000000',\n       '2023-05-08T02:04:49.024000000', '2023-05-13T02:04:41.024000000',\n       '2023-05-18T02:04:49.024000000', '2023-05-23T02:04:51.024000000',\n       '2023-06-02T02:04:51.024000000', '2023-06-22T02:04:51.024000000',\n       '2023-07-07T02:04:49.024000000', '2023-07-17T02:04:49.024000000',\n       '2023-07-22T02:04:51.024000000', '2023-07-27T02:04:49.024000000',\n       '2023-08-01T02:04:51.024000000', '2023-08-06T02:04:49.024000000',\n       '2023-08-11T02:04:51.024000000', '2023-08-16T02:04:49.024000000',\n       '2023-08-21T02:04:51.024000000', '2023-08-26T02:04:49.024000000',\n       '2023-08-31T02:04:51.024000000', '2023-09-05T02:04:49.024000000',\n       '2023-09-15T02:04:49.024000000', '2023-09-25T02:04:49.024000000',\n       '2023-09-30T02:04:51.024000000', '2023-10-05T02:04:49.024000000',\n       '2023-10-10T02:04:41.024000000', '2023-10-15T02:04:49.024000000',\n       '2023-10-20T02:04:41.024000000', '2023-10-25T02:04:49.024000000',\n       '2023-10-30T02:04:41.024000000', '2023-11-09T02:04:41.024000000',\n       '2023-11-14T02:04:49.024000000', '2023-11-29T02:04:41.024000000',\n       '2023-12-19T02:04:41.024000000', '2023-12-24T02:04:49.024000000',\n       '2023-12-29T02:04:41.024000000'], dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (1)<ul><li>red(time, y, x)float32dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;  Array   Chunk   Bytes   5.35 MiB   46.81 kiB   Shape   (117, 112, 107)   (1, 112, 107)   Dask graph   117 chunks in 3 graph layers   Data type   float32 numpy.ndarray  107 112 117 </li></ul></li><li>Indexes: (3)<ul><li>yPandasIndex<pre>PandasIndex(Index([8015150.0, 8015050.0, 8014950.0, 8014850.0, 8014750.0, 8014650.0,\n       8014550.0, 8014450.0, 8014350.0, 8014250.0,\n       ...\n       8004950.0, 8004850.0, 8004750.0, 8004650.0, 8004550.0, 8004450.0,\n       8004350.0, 8004250.0, 8004150.0, 8004050.0],\n      dtype='float64', name='y', length=112))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([411050.0, 411150.0, 411250.0, 411350.0, 411450.0, 411550.0, 411650.0,\n       411750.0, 411850.0, 411950.0,\n       ...\n       420750.0, 420850.0, 420950.0, 421050.0, 421150.0, 421250.0, 421350.0,\n       421450.0, 421550.0, 421650.0],\n      dtype='float64', name='x', length=107))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2021-01-03 02:04:51.024000', '2021-01-13 02:04:51.024000',\n               '2021-02-27 02:04:49.024000', '2021-03-24 02:04:41.024000',\n               '2021-03-29 02:04:49.024000', '2021-04-08 02:04:39.024000',\n               '2021-04-23 02:04:41.024000', '2021-04-28 02:04:39.024000',\n               '2021-05-03 02:04:41.024000', '2021-05-08 02:04:39.024000',\n               ...\n               '2023-10-15 02:04:49.024000', '2023-10-20 02:04:41.024000',\n               '2023-10-25 02:04:49.024000', '2023-10-30 02:04:41.024000',\n               '2023-11-09 02:04:41.024000', '2023-11-14 02:04:49.024000',\n               '2023-11-29 02:04:41.024000', '2023-12-19 02:04:41.024000',\n               '2023-12-24 02:04:49.024000', '2023-12-29 02:04:41.024000'],\n              dtype='datetime64[ns]', name='time', length=117, freq=None))</pre></li></ul></li><li>Attributes: (0)</li></ul> In\u00a0[3]: Copied! <pre>from eo_tides.stats import tide_stats\n\nstatistics_df = tide_stats(\n    data=ds_s2,\n    model=model,\n    directory=directory,\n)\n</pre> from eo_tides.stats import tide_stats  statistics_df = tide_stats(     data=ds_s2,     model=model,     directory=directory, ) <pre>Using tide modelling location: 122.21, -18.00\nModelling tides with EOT20\nUsing tide modelling location: 122.21, -18.00\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.36 m (-4.64 to 4.73 m).\n\ud83d\udef0\ufe0f Observed tide range: 6.31 m (-2.36 to 3.95 m).\n\n\ud83d\udd34 67% of the modelled astronomical tide range was observed at this location.\n\ud83d\udfe2 The highest 8% (0.78 m) of the tide range was never observed.\n\ud83d\udd34 The lowest 24% (2.27 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: 0.95 m.\n\u2b06\ufe0f The mean observed tide height was 0.95 m higher than the mean modelled astronomical tide height.\n</pre> <p>As we can see in the graph, Sentinel-2 captured a biased proportion of the tide range at this location: only observing ~68% of the tide range, and never observing the lowest 24% of tides.</p> <p>The <code>tide_stats</code> function also outputs a <code>pandas.Series</code> object containing statistics for the results above, including:</p> <ul> <li><code>mot</code>: mean tide height observed by the satellite (metres)</li> <li><code>mat</code>: mean modelled astronomical tide height (metres)</li> <li><code>hot</code>: maximum tide height observed by the satellite (metres)</li> <li><code>hat</code>: maximum tide height from modelled astronomical tidal range (metres)</li> <li><code>lot</code>: minimum tide height observed by the satellite (metres)</li> <li><code>lat</code>: minimum tide height from modelled astronomical tidal range (metres)</li> <li><code>otr</code>: tidal range observed by the satellite (metres)</li> <li><code>tr</code>: modelled astronomical tide range (metres)</li> <li><code>spread</code>: proportion of the full modelled tidal range observed by the satellite</li> <li><code>offset_low</code>: proportion of the lowest tides never observed by the satellite</li> <li><code>offset_high</code>: proportion of the highest tides never observed by the satellite</li> <li><code>y</code>: latitude used for modelling tide heights</li> <li><code>x</code>: longitude used for modelling tide heights</li> </ul> In\u00a0[4]: Copied! <pre>statistics_df\n</pre> statistics_df Out[4]: <pre>mot              0.951000\nmat             -0.000000\nhot              3.950000\nhat              4.728000\nlot             -2.361000\nlat             -4.636000\notr              6.311000\ntr               9.364000\nspread           0.674000\noffset_low       0.243000\noffset_high      0.083000\nx              122.209999\ny              -18.000000\ndtype: float32</pre> In\u00a0[5]: Copied! <pre># Build a query and search the STAC catalog for all matching items\nbbox = [122.160, -18.05, 122.260, -17.95]\nquery = catalog.search(\n    bbox=bbox,\n    collections=[\"sentinel-1-rtc\"],\n    datetime=\"2021/2023\",\n)\n\n# Load data into xarray format\nds_s1 = odc.stac.load(\n    items=list(query.items()),\n    bands=[\"vv\"],\n    crs=\"utm\",\n    resolution=100,\n    groupby=\"solar_day\",\n    bbox=bbox,\n    fail_on_error=False,\n    chunks={},\n)\n\n# Inspect output\nds_s1\n</pre> # Build a query and search the STAC catalog for all matching items bbox = [122.160, -18.05, 122.260, -17.95] query = catalog.search(     bbox=bbox,     collections=[\"sentinel-1-rtc\"],     datetime=\"2021/2023\", )  # Load data into xarray format ds_s1 = odc.stac.load(     items=list(query.items()),     bands=[\"vv\"],     crs=\"utm\",     resolution=100,     groupby=\"solar_day\",     bbox=bbox,     fail_on_error=False,     chunks={}, )  # Inspect output ds_s1 Out[5]: <pre>&lt;xarray.Dataset&gt; Size: 4MB\nDimensions:      (y: 112, x: 107, time: 89)\nCoordinates:\n  * y            (y) float64 896B 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x            (x) float64 856B 4.11e+05 4.112e+05 ... 4.216e+05 4.216e+05\n    spatial_ref  int32 4B 32751\n  * time         (time) datetime64[ns] 712B 2021-01-07T21:23:20.996123 ... 20...\nData variables:\n    vv           (time, y, x) float32 4MB dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 112</li><li>x: 107</li><li>time: 89</li></ul></li><li>Coordinates: (4)<ul><li>y(y)float648.015e+06 8.015e+06 ... 8.004e+06units :metreresolution :-100.0crs :EPSG:32751<pre>array([8015150., 8015050., 8014950., 8014850., 8014750., 8014650., 8014550.,\n       8014450., 8014350., 8014250., 8014150., 8014050., 8013950., 8013850.,\n       8013750., 8013650., 8013550., 8013450., 8013350., 8013250., 8013150.,\n       8013050., 8012950., 8012850., 8012750., 8012650., 8012550., 8012450.,\n       8012350., 8012250., 8012150., 8012050., 8011950., 8011850., 8011750.,\n       8011650., 8011550., 8011450., 8011350., 8011250., 8011150., 8011050.,\n       8010950., 8010850., 8010750., 8010650., 8010550., 8010450., 8010350.,\n       8010250., 8010150., 8010050., 8009950., 8009850., 8009750., 8009650.,\n       8009550., 8009450., 8009350., 8009250., 8009150., 8009050., 8008950.,\n       8008850., 8008750., 8008650., 8008550., 8008450., 8008350., 8008250.,\n       8008150., 8008050., 8007950., 8007850., 8007750., 8007650., 8007550.,\n       8007450., 8007350., 8007250., 8007150., 8007050., 8006950., 8006850.,\n       8006750., 8006650., 8006550., 8006450., 8006350., 8006250., 8006150.,\n       8006050., 8005950., 8005850., 8005750., 8005650., 8005550., 8005450.,\n       8005350., 8005250., 8005150., 8005050., 8004950., 8004850., 8004750.,\n       8004650., 8004550., 8004450., 8004350., 8004250., 8004150., 8004050.])</pre></li><li>x(x)float644.11e+05 4.112e+05 ... 4.216e+05units :metreresolution :100.0crs :EPSG:32751<pre>array([411050., 411150., 411250., 411350., 411450., 411550., 411650., 411750.,\n       411850., 411950., 412050., 412150., 412250., 412350., 412450., 412550.,\n       412650., 412750., 412850., 412950., 413050., 413150., 413250., 413350.,\n       413450., 413550., 413650., 413750., 413850., 413950., 414050., 414150.,\n       414250., 414350., 414450., 414550., 414650., 414750., 414850., 414950.,\n       415050., 415150., 415250., 415350., 415450., 415550., 415650., 415750.,\n       415850., 415950., 416050., 416150., 416250., 416350., 416450., 416550.,\n       416650., 416750., 416850., 416950., 417050., 417150., 417250., 417350.,\n       417450., 417550., 417650., 417750., 417850., 417950., 418050., 418150.,\n       418250., 418350., 418450., 418550., 418650., 418750., 418850., 418950.,\n       419050., 419150., 419250., 419350., 419450., 419550., 419650., 419750.,\n       419850., 419950., 420050., 420150., 420250., 420350., 420450., 420550.,\n       420650., 420750., 420850., 420950., 421050., 421150., 421250., 421350.,\n       421450., 421550., 421650.])</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996GeoTransform :411000 100 0 8015200 0 -100<pre>array(32751, dtype=int32)</pre></li><li>time(time)datetime64[ns]2021-01-07T21:23:20.996123 ... 2...<pre>array(['2021-01-07T21:23:20.996123000', '2021-01-19T21:23:20.473169000',\n       '2021-01-31T21:23:20.196503000', '2021-02-12T21:23:19.836775000',\n       '2021-02-24T21:23:19.601017000', '2021-03-08T21:23:19.602797000',\n       '2021-03-20T21:23:19.674809000', '2021-04-01T21:23:19.893731000',\n       '2021-04-13T21:23:20.403862000', '2021-04-25T21:23:20.921708000',\n       '2021-05-07T21:23:21.492194000', '2021-05-19T21:23:21.893728000',\n       '2021-05-31T21:23:22.797787000', '2021-06-12T21:23:23.655950000',\n       '2021-06-24T21:23:24.231551000', '2021-07-06T21:23:24.942072000',\n       '2021-07-18T21:23:25.763768000', '2021-07-30T21:23:26.408363000',\n       '2021-08-11T21:23:27.038867000', '2021-08-23T21:23:27.750853000',\n       '2021-09-04T21:23:28.256943000', '2021-09-16T21:23:28.746247000',\n       '2021-09-28T21:23:29.151429000', '2021-10-10T21:23:29.278010000',\n       '2021-10-22T21:23:29.424858000', '2021-11-03T21:23:29.061659000',\n       '2021-11-15T21:23:29.029518000', '2021-11-27T21:23:28.563712000',\n       '2021-12-09T21:23:27.968356000', '2021-12-21T21:23:27.381261000',\n       '2022-01-02T21:23:26.838459000', '2022-01-14T21:23:26.460592000',\n       '2022-01-26T21:23:25.886410000', '2022-02-07T21:23:25.463107000',\n       '2022-02-19T21:23:25.341123000', '2022-03-03T21:23:24.996490000',\n       '2022-03-15T21:23:25.147531000', '2022-03-27T21:23:25.642568000',\n       '2022-04-08T21:23:25.753533000', '2022-04-20T21:23:26.253255000',\n       '2022-05-02T21:23:26.646692000', '2022-05-14T21:23:27.666256000',\n       '2022-05-26T21:23:28.225997000', '2022-06-07T21:23:29.577109000',\n       '2022-06-19T21:23:30.159718000', '2022-07-01T21:23:30.862849000',\n       '2022-07-13T21:23:31.428153000', '2022-07-25T21:23:32.322929000',\n       '2022-08-06T21:23:33.187268000', '2022-08-18T21:23:33.835977000',\n       '2022-08-30T21:23:34.218580000', '2022-09-11T21:23:35.053460000',\n       '2022-09-23T21:23:34.485698000', '2022-10-05T21:23:35.018588000',\n       '2022-10-17T21:23:35.413134000', '2022-10-29T21:23:35.349759000',\n       '2022-11-10T21:23:34.758052000', '2022-11-22T21:23:35.125117000',\n       '2022-12-04T21:23:34.351981000', '2022-12-16T21:23:33.526234000',\n       '2022-12-28T21:23:32.878238000', '2023-01-09T21:23:32.138705000',\n       '2023-01-21T21:23:31.894599000', '2023-02-02T21:23:31.576389000',\n       '2023-02-14T21:23:31.004941000', '2023-02-26T21:23:31.171277000',\n       '2023-03-10T21:23:30.948384000', '2023-03-22T21:23:30.854808000',\n       '2023-04-03T21:23:31.466830000', '2023-04-15T21:23:31.961185000',\n       '2023-04-27T21:23:32.309715000', '2023-05-09T21:23:32.869660000',\n       '2023-05-21T21:23:33.657412000', '2023-06-02T21:23:34.135200000',\n       '2023-06-14T21:23:34.746639000', '2023-06-26T21:23:34.964707000',\n       '2023-07-08T21:23:36.380830000', '2023-07-20T21:23:36.899224000',\n       '2023-08-01T21:23:37.410247000', '2023-08-13T21:23:38.094672000',\n       '2023-08-25T21:23:39.036028000', '2023-09-06T21:23:39.571825000',\n       '2023-09-18T21:23:40.116043000', '2023-10-12T21:23:39.942891000',\n       '2023-10-24T21:23:40.292227000', '2023-11-17T21:23:39.825436000',\n       '2023-11-29T21:23:38.857474000', '2023-12-11T21:23:38.954516000',\n       '2023-12-23T21:23:37.936220000'], dtype='datetime64[ns]')</pre></li></ul></li><li>Data variables: (1)<ul><li>vv(time, y, x)float32dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;nodata :-32768  Array   Chunk   Bytes   4.07 MiB   46.81 kiB   Shape   (89, 112, 107)   (1, 112, 107)   Dask graph   89 chunks in 3 graph layers   Data type   float32 numpy.ndarray  107 112 89 </li></ul></li><li>Indexes: (3)<ul><li>yPandasIndex<pre>PandasIndex(Index([8015150.0, 8015050.0, 8014950.0, 8014850.0, 8014750.0, 8014650.0,\n       8014550.0, 8014450.0, 8014350.0, 8014250.0,\n       ...\n       8004950.0, 8004850.0, 8004750.0, 8004650.0, 8004550.0, 8004450.0,\n       8004350.0, 8004250.0, 8004150.0, 8004050.0],\n      dtype='float64', name='y', length=112))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([411050.0, 411150.0, 411250.0, 411350.0, 411450.0, 411550.0, 411650.0,\n       411750.0, 411850.0, 411950.0,\n       ...\n       420750.0, 420850.0, 420950.0, 421050.0, 421150.0, 421250.0, 421350.0,\n       421450.0, 421550.0, 421650.0],\n      dtype='float64', name='x', length=107))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2021-01-07 21:23:20.996123', '2021-01-19 21:23:20.473169',\n               '2021-01-31 21:23:20.196503', '2021-02-12 21:23:19.836775',\n               '2021-02-24 21:23:19.601017', '2021-03-08 21:23:19.602797',\n               '2021-03-20 21:23:19.674809', '2021-04-01 21:23:19.893731',\n               '2021-04-13 21:23:20.403862', '2021-04-25 21:23:20.921708',\n               '2021-05-07 21:23:21.492194', '2021-05-19 21:23:21.893728',\n               '2021-05-31 21:23:22.797787', '2021-06-12 21:23:23.655950',\n               '2021-06-24 21:23:24.231551', '2021-07-06 21:23:24.942072',\n               '2021-07-18 21:23:25.763768', '2021-07-30 21:23:26.408363',\n               '2021-08-11 21:23:27.038867', '2021-08-23 21:23:27.750853',\n               '2021-09-04 21:23:28.256943', '2021-09-16 21:23:28.746247',\n               '2021-09-28 21:23:29.151429', '2021-10-10 21:23:29.278010',\n               '2021-10-22 21:23:29.424858', '2021-11-03 21:23:29.061659',\n               '2021-11-15 21:23:29.029518', '2021-11-27 21:23:28.563712',\n               '2021-12-09 21:23:27.968356', '2021-12-21 21:23:27.381261',\n               '2022-01-02 21:23:26.838459', '2022-01-14 21:23:26.460592',\n               '2022-01-26 21:23:25.886410', '2022-02-07 21:23:25.463107',\n               '2022-02-19 21:23:25.341123', '2022-03-03 21:23:24.996490',\n               '2022-03-15 21:23:25.147531', '2022-03-27 21:23:25.642568',\n               '2022-04-08 21:23:25.753533', '2022-04-20 21:23:26.253255',\n               '2022-05-02 21:23:26.646692', '2022-05-14 21:23:27.666256',\n               '2022-05-26 21:23:28.225997', '2022-06-07 21:23:29.577109',\n               '2022-06-19 21:23:30.159718', '2022-07-01 21:23:30.862849',\n               '2022-07-13 21:23:31.428153', '2022-07-25 21:23:32.322929',\n               '2022-08-06 21:23:33.187268', '2022-08-18 21:23:33.835977',\n               '2022-08-30 21:23:34.218580', '2022-09-11 21:23:35.053460',\n               '2022-09-23 21:23:34.485698', '2022-10-05 21:23:35.018588',\n               '2022-10-17 21:23:35.413134', '2022-10-29 21:23:35.349759',\n               '2022-11-10 21:23:34.758052', '2022-11-22 21:23:35.125117',\n               '2022-12-04 21:23:34.351981', '2022-12-16 21:23:33.526234',\n               '2022-12-28 21:23:32.878238', '2023-01-09 21:23:32.138705',\n               '2023-01-21 21:23:31.894599', '2023-02-02 21:23:31.576389',\n               '2023-02-14 21:23:31.004941', '2023-02-26 21:23:31.171277',\n               '2023-03-10 21:23:30.948384', '2023-03-22 21:23:30.854808',\n               '2023-04-03 21:23:31.466830', '2023-04-15 21:23:31.961185',\n               '2023-04-27 21:23:32.309715', '2023-05-09 21:23:32.869660',\n               '2023-05-21 21:23:33.657412', '2023-06-02 21:23:34.135200',\n               '2023-06-14 21:23:34.746639', '2023-06-26 21:23:34.964707',\n               '2023-07-08 21:23:36.380830', '2023-07-20 21:23:36.899224',\n               '2023-08-01 21:23:37.410247', '2023-08-13 21:23:38.094672',\n               '2023-08-25 21:23:39.036028', '2023-09-06 21:23:39.571825',\n               '2023-09-18 21:23:40.116043', '2023-10-12 21:23:39.942891',\n               '2023-10-24 21:23:40.292227', '2023-11-17 21:23:39.825436',\n               '2023-11-29 21:23:38.857474', '2023-12-11 21:23:38.954516',\n               '2023-12-23 21:23:37.936220'],\n              dtype='datetime64[ns]', name='time', freq=None))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>When we run <code>tide_stats</code>, we can see a very different pattern: Sentinel-1 data is biased towards low tide observations, and never observes high tide at our location!</p> In\u00a0[6]: Copied! <pre>statistics_df = tide_stats(\n    data=ds_s1,\n    model=model,\n    directory=directory,\n)\n</pre> statistics_df = tide_stats(     data=ds_s1,     model=model,     directory=directory, ) <pre>Using tide modelling location: 122.21, -18.00\nModelling tides with EOT20\nUsing tide modelling location: 122.21, -18.00\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.53 m (-4.81 to 4.73 m).\n\ud83d\udef0\ufe0f Observed tide range: 6.40 m (-4.38 to 2.02 m).\n\n\ud83d\udd34 67% of the modelled astronomical tide range was observed at this location.\n\ud83d\udd34 The highest 28% (2.70 m) of the tide range was never observed.\n\ud83d\udfe2 The lowest 4% (0.42 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: -1.31 m.\n\u2b07\ufe0f The mean observed tide height was -1.31 m lower than the mean modelled astronomical tide height.\n</pre> In\u00a0[7]: Copied! <pre>import xarray as xr\n\n# Give each observation a \"satellite_name\" based on its satellite\nds_s1 = ds_s1.assign_coords(satellite_name=(\"time\", [\"Sentinel-1\"] * ds_s1.sizes[\"time\"]))\nds_s2 = ds_s2.assign_coords(satellite_name=(\"time\", [\"Sentinel-2\"] * ds_s2.sizes[\"time\"]))\n\n# Combine both Sentinel-1 and Sentinel-2 data into a single dataset\nds_all = xr.concat([ds_s1, ds_s2], dim=\"time\")\nds_all\n</pre> import xarray as xr  # Give each observation a \"satellite_name\" based on its satellite ds_s1 = ds_s1.assign_coords(satellite_name=(\"time\", [\"Sentinel-1\"] * ds_s1.sizes[\"time\"])) ds_s2 = ds_s2.assign_coords(satellite_name=(\"time\", [\"Sentinel-2\"] * ds_s2.sizes[\"time\"]))  # Combine both Sentinel-1 and Sentinel-2 data into a single dataset ds_all = xr.concat([ds_s1, ds_s2], dim=\"time\") ds_all Out[7]: <pre>&lt;xarray.Dataset&gt; Size: 20MB\nDimensions:         (time: 206, y: 112, x: 107)\nCoordinates:\n  * y               (y) float64 896B 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x               (x) float64 856B 4.11e+05 4.112e+05 ... 4.216e+05 4.216e+05\n    spatial_ref     int32 4B 32751\n  * time            (time) datetime64[ns] 2kB 2021-01-07T21:23:20.996123 ... ...\n    satellite_name  (time) &lt;U10 8kB 'Sentinel-1' 'Sentinel-1' ... 'Sentinel-2'\nData variables:\n    vv              (time, y, x) float32 10MB dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;\n    red             (time, y, x) float32 10MB dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>time: 206</li><li>y: 112</li><li>x: 107</li></ul></li><li>Coordinates: (5)<ul><li>y(y)float648.015e+06 8.015e+06 ... 8.004e+06units :metreresolution :-100.0crs :EPSG:32751<pre>array([8015150., 8015050., 8014950., 8014850., 8014750., 8014650., 8014550.,\n       8014450., 8014350., 8014250., 8014150., 8014050., 8013950., 8013850.,\n       8013750., 8013650., 8013550., 8013450., 8013350., 8013250., 8013150.,\n       8013050., 8012950., 8012850., 8012750., 8012650., 8012550., 8012450.,\n       8012350., 8012250., 8012150., 8012050., 8011950., 8011850., 8011750.,\n       8011650., 8011550., 8011450., 8011350., 8011250., 8011150., 8011050.,\n       8010950., 8010850., 8010750., 8010650., 8010550., 8010450., 8010350.,\n       8010250., 8010150., 8010050., 8009950., 8009850., 8009750., 8009650.,\n       8009550., 8009450., 8009350., 8009250., 8009150., 8009050., 8008950.,\n       8008850., 8008750., 8008650., 8008550., 8008450., 8008350., 8008250.,\n       8008150., 8008050., 8007950., 8007850., 8007750., 8007650., 8007550.,\n       8007450., 8007350., 8007250., 8007150., 8007050., 8006950., 8006850.,\n       8006750., 8006650., 8006550., 8006450., 8006350., 8006250., 8006150.,\n       8006050., 8005950., 8005850., 8005750., 8005650., 8005550., 8005450.,\n       8005350., 8005250., 8005150., 8005050., 8004950., 8004850., 8004750.,\n       8004650., 8004550., 8004450., 8004350., 8004250., 8004150., 8004050.])</pre></li><li>x(x)float644.11e+05 4.112e+05 ... 4.216e+05units :metreresolution :100.0crs :EPSG:32751<pre>array([411050., 411150., 411250., 411350., 411450., 411550., 411650., 411750.,\n       411850., 411950., 412050., 412150., 412250., 412350., 412450., 412550.,\n       412650., 412750., 412850., 412950., 413050., 413150., 413250., 413350.,\n       413450., 413550., 413650., 413750., 413850., 413950., 414050., 414150.,\n       414250., 414350., 414450., 414550., 414650., 414750., 414850., 414950.,\n       415050., 415150., 415250., 415350., 415450., 415550., 415650., 415750.,\n       415850., 415950., 416050., 416150., 416250., 416350., 416450., 416550.,\n       416650., 416750., 416850., 416950., 417050., 417150., 417250., 417350.,\n       417450., 417550., 417650., 417750., 417850., 417950., 418050., 418150.,\n       418250., 418350., 418450., 418550., 418650., 418750., 418850., 418950.,\n       419050., 419150., 419250., 419350., 419450., 419550., 419650., 419750.,\n       419850., 419950., 420050., 420150., 420250., 420350., 420450., 420550.,\n       420650., 420750., 420850., 420950., 421050., 421150., 421250., 421350.,\n       421450., 421550., 421650.])</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996GeoTransform :411000 100 0 8015200 0 -100<pre>array(32751, dtype=int32)</pre></li><li>time(time)datetime64[ns]2021-01-07T21:23:20.996123 ... 2...<pre>array(['2021-01-07T21:23:20.996123000', '2021-01-19T21:23:20.473169000',\n       '2021-01-31T21:23:20.196503000', ..., '2023-12-19T02:04:41.024000000',\n       '2023-12-24T02:04:49.024000000', '2023-12-29T02:04:41.024000000'],\n      dtype='datetime64[ns]')</pre></li><li>satellite_name(time)&lt;U10'Sentinel-1' ... 'Sentinel-2'<pre>array(['Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n       'Sentinel-1', 'Sentinel-1', 'Sentinel-1', 'Sentinel-1',\n...\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2', 'Sentinel-2', 'Sentinel-2',\n       'Sentinel-2', 'Sentinel-2'], dtype='&lt;U10')</pre></li></ul></li><li>Data variables: (2)<ul><li>vv(time, y, x)float32dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;nodata :-32768  Array   Chunk   Bytes   9.42 MiB   46.81 kiB   Shape   (206, 112, 107)   (1, 112, 107)   Dask graph   206 chunks in 14 graph layers   Data type   float32 numpy.ndarray  107 112 206 </li><li>red(time, y, x)float32dask.array&lt;chunksize=(1, 112, 107), meta=np.ndarray&gt;  Array   Chunk   Bytes   9.42 MiB   46.81 kiB   Shape   (206, 112, 107)   (1, 112, 107)   Dask graph   206 chunks in 14 graph layers   Data type   float32 numpy.ndarray  107 112 206 </li></ul></li><li>Indexes: (3)<ul><li>yPandasIndex<pre>PandasIndex(Index([8015150.0, 8015050.0, 8014950.0, 8014850.0, 8014750.0, 8014650.0,\n       8014550.0, 8014450.0, 8014350.0, 8014250.0,\n       ...\n       8004950.0, 8004850.0, 8004750.0, 8004650.0, 8004550.0, 8004450.0,\n       8004350.0, 8004250.0, 8004150.0, 8004050.0],\n      dtype='float64', name='y', length=112))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([411050.0, 411150.0, 411250.0, 411350.0, 411450.0, 411550.0, 411650.0,\n       411750.0, 411850.0, 411950.0,\n       ...\n       420750.0, 420850.0, 420950.0, 421050.0, 421150.0, 421250.0, 421350.0,\n       421450.0, 421550.0, 421650.0],\n      dtype='float64', name='x', length=107))</pre></li><li>timePandasIndex<pre>PandasIndex(DatetimeIndex(['2021-01-07 21:23:20.996123', '2021-01-19 21:23:20.473169',\n               '2021-01-31 21:23:20.196503', '2021-02-12 21:23:19.836775',\n               '2021-02-24 21:23:19.601017', '2021-03-08 21:23:19.602797',\n               '2021-03-20 21:23:19.674809', '2021-04-01 21:23:19.893731',\n               '2021-04-13 21:23:20.403862', '2021-04-25 21:23:20.921708',\n               ...\n               '2023-10-15 02:04:49.024000', '2023-10-20 02:04:41.024000',\n               '2023-10-25 02:04:49.024000', '2023-10-30 02:04:41.024000',\n               '2023-11-09 02:04:41.024000', '2023-11-14 02:04:49.024000',\n               '2023-11-29 02:04:41.024000', '2023-12-19 02:04:41.024000',\n               '2023-12-24 02:04:49.024000', '2023-12-29 02:04:41.024000'],\n              dtype='datetime64[ns]', name='time', length=206, freq=None))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>We can now run <code>tide_stats</code> again. This time, we pass our satellite name coordinate to the function using the <code>plot_var=\"satellite_name\"</code> parameter. This will plot data from each of our satellites using a different symbol and colour.</p> In\u00a0[8]: Copied! <pre>statistics_df = tide_stats(\n    data=ds_all,\n    plot_var=\"satellite_name\",\n    model=model,\n    directory=directory,\n)\n</pre> statistics_df = tide_stats(     data=ds_all,     plot_var=\"satellite_name\",     model=model,     directory=directory, ) <pre>Using tide modelling location: 122.21, -18.00\nModelling tides with EOT20\nUsing tide modelling location: 122.21, -18.00\nModelling tides with EOT20\n\n\n\ud83c\udf0a Modelled astronomical tide range: 9.36 m (-4.64 to 4.73 m).\n\ud83d\udef0\ufe0f Observed tide range: 8.33 m (-4.38 to 3.95 m).\n\n\ud83d\udfe1 89% of the modelled astronomical tide range was observed at this location.\n\ud83d\udfe2 The highest 8% (0.78 m) of the tide range was never observed.\n\ud83d\udfe2 The lowest 3% (0.26 m) of the tide range was never observed.\n\n\ud83c\udf0a Mean modelled astronomical tide height: -0.00 m.\n\ud83d\udef0\ufe0f Mean observed tide height: -0.02 m.\n\u2b07\ufe0f The mean observed tide height was -0.02 m lower than the mean modelled astronomical tide height.\n</pre> <p>We can see that at this location, combining Sentinel-2 and Sentinel-1 data greatly improves our biases: our satellite data now covers ~89% of the modelled astronomical tide range, and only fails to observe 8% of the highest tides and 2% of the lowest tides!</p> In\u00a0[9]: Copied! <pre>from eo_tides.stats import pixel_stats\n\nstats_ds = pixel_stats(\n    data=ds_s2,\n    directory=directory,\n)\nstats_ds\n</pre> from eo_tides.stats import pixel_stats  stats_ds = pixel_stats(     data=ds_s2,     directory=directory, ) stats_ds <pre>Creating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\nCreating reduced resolution 5000 x 5000 metre tide modelling array\nModelling tides with EOT20\nReturning low resolution tide array\n</pre> <pre>/env/lib/python3.10/site-packages/numpy/lib/nanfunctions.py:1563: RuntimeWarning: All-NaN slice encountered\n  return function_base._ureduce(a,\n</pre> <pre>Reprojecting statistics into original resolution\n</pre> <pre>/env/lib/python3.10/site-packages/rasterio/warp.py:387: NotGeoreferencedWarning: Dataset has no geotransform, gcps, or rpcs. The identity matrix will be returned.\n  dest = _reproject(\n</pre> Out[9]: <pre>&lt;xarray.Dataset&gt; Size: 529kB\nDimensions:      (y: 112, x: 107)\nCoordinates:\n    tide_model   &lt;U5 20B 'EOT20'\n  * y            (y) float64 896B 8.015e+06 8.015e+06 ... 8.004e+06 8.004e+06\n  * x            (x) float64 856B 4.11e+05 4.112e+05 ... 4.216e+05 4.216e+05\n    spatial_ref  int32 4B 32751\nData variables:\n    mot          (y, x) float32 48kB 0.9604 0.9604 0.9604 ... 0.9451 0.945 0.945\n    mat          (y, x) float32 48kB -0.0001393 -0.0001393 ... -0.0001331\n    hot          (y, x) float32 48kB 3.894 3.894 3.894 ... 3.967 3.968 3.968\n    hat          (y, x) float32 48kB 4.526 4.526 4.526 ... 4.803 4.804 4.805\n    lot          (y, x) float32 48kB -2.242 -2.242 -2.242 ... -2.407 -2.408\n    lat          (y, x) float32 48kB -4.457 -4.457 -4.457 ... -4.702 -4.702\n    otr          (y, x) float32 48kB 6.136 6.136 6.136 ... 6.374 6.375 6.375\n    tr           (y, x) float32 48kB 8.983 8.983 8.983 ... 9.504 9.506 9.508\n    spread       (y, x) float32 48kB 0.6831 0.6831 0.6831 ... 0.6706 0.6706\n    offset_low   (y, x) float32 48kB 0.2466 0.2466 0.2466 ... 0.2414 0.2414\n    offset_high  (y, x) float32 48kB 0.07026 0.07026 0.07026 ... 0.08802 0.08808</pre>xarray.Dataset<ul><li>Dimensions:<ul><li>y: 112</li><li>x: 107</li></ul></li><li>Coordinates: (4)<ul><li>tide_model()&lt;U5'EOT20'<pre>array('EOT20', dtype='&lt;U5')</pre></li><li>y(y)float648.015e+06 8.015e+06 ... 8.004e+06units :metreresolution :-100.0crs :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]<pre>array([8015150., 8015050., 8014950., 8014850., 8014750., 8014650., 8014550.,\n       8014450., 8014350., 8014250., 8014150., 8014050., 8013950., 8013850.,\n       8013750., 8013650., 8013550., 8013450., 8013350., 8013250., 8013150.,\n       8013050., 8012950., 8012850., 8012750., 8012650., 8012550., 8012450.,\n       8012350., 8012250., 8012150., 8012050., 8011950., 8011850., 8011750.,\n       8011650., 8011550., 8011450., 8011350., 8011250., 8011150., 8011050.,\n       8010950., 8010850., 8010750., 8010650., 8010550., 8010450., 8010350.,\n       8010250., 8010150., 8010050., 8009950., 8009850., 8009750., 8009650.,\n       8009550., 8009450., 8009350., 8009250., 8009150., 8009050., 8008950.,\n       8008850., 8008750., 8008650., 8008550., 8008450., 8008350., 8008250.,\n       8008150., 8008050., 8007950., 8007850., 8007750., 8007650., 8007550.,\n       8007450., 8007350., 8007250., 8007150., 8007050., 8006950., 8006850.,\n       8006750., 8006650., 8006550., 8006450., 8006350., 8006250., 8006150.,\n       8006050., 8005950., 8005850., 8005750., 8005650., 8005550., 8005450.,\n       8005350., 8005250., 8005150., 8005050., 8004950., 8004850., 8004750.,\n       8004650., 8004550., 8004450., 8004350., 8004250., 8004150., 8004050.])</pre></li><li>x(x)float644.11e+05 4.112e+05 ... 4.216e+05units :metreresolution :100.0crs :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]<pre>array([411050., 411150., 411250., 411350., 411450., 411550., 411650., 411750.,\n       411850., 411950., 412050., 412150., 412250., 412350., 412450., 412550.,\n       412650., 412750., 412850., 412950., 413050., 413150., 413250., 413350.,\n       413450., 413550., 413650., 413750., 413850., 413950., 414050., 414150.,\n       414250., 414350., 414450., 414550., 414650., 414750., 414850., 414950.,\n       415050., 415150., 415250., 415350., 415450., 415550., 415650., 415750.,\n       415850., 415950., 416050., 416150., 416250., 416350., 416450., 416550.,\n       416650., 416750., 416850., 416950., 417050., 417150., 417250., 417350.,\n       417450., 417550., 417650., 417750., 417850., 417950., 418050., 418150.,\n       418250., 418350., 418450., 418550., 418650., 418750., 418850., 418950.,\n       419050., 419150., 419250., 419350., 419450., 419550., 419650., 419750.,\n       419850., 419950., 420050., 420150., 420250., 420350., 420450., 420550.,\n       420650., 420750., 420850., 420950., 421050., 421150., 421250., 421350.,\n       421450., 421550., 421650.])</pre></li><li>spatial_ref()int3232751spatial_ref :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]crs_wkt :PROJCRS[\"WGS 84 / UTM zone 51S\",BASEGEOGCRS[\"WGS 84\",ENSEMBLE[\"World Geodetic System 1984 ensemble\",MEMBER[\"World Geodetic System 1984 (Transit)\"],MEMBER[\"World Geodetic System 1984 (G730)\"],MEMBER[\"World Geodetic System 1984 (G873)\"],MEMBER[\"World Geodetic System 1984 (G1150)\"],MEMBER[\"World Geodetic System 1984 (G1674)\"],MEMBER[\"World Geodetic System 1984 (G1762)\"],MEMBER[\"World Geodetic System 1984 (G2139)\"],MEMBER[\"World Geodetic System 1984 (G2296)\"],ELLIPSOID[\"WGS 84\",6378137,298.257223563,LENGTHUNIT[\"metre\",1]],ENSEMBLEACCURACY[2.0]],PRIMEM[\"Greenwich\",0,ANGLEUNIT[\"degree\",0.0174532925199433]],ID[\"EPSG\",4326]],CONVERSION[\"UTM zone 51S\",METHOD[\"Transverse Mercator\",ID[\"EPSG\",9807]],PARAMETER[\"Latitude of natural origin\",0,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8801]],PARAMETER[\"Longitude of natural origin\",123,ANGLEUNIT[\"degree\",0.0174532925199433],ID[\"EPSG\",8802]],PARAMETER[\"Scale factor at natural origin\",0.9996,SCALEUNIT[\"unity\",1],ID[\"EPSG\",8805]],PARAMETER[\"False easting\",500000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8806]],PARAMETER[\"False northing\",10000000,LENGTHUNIT[\"metre\",1],ID[\"EPSG\",8807]]],CS[Cartesian,2],AXIS[\"(E)\",east,ORDER[1],LENGTHUNIT[\"metre\",1]],AXIS[\"(N)\",north,ORDER[2],LENGTHUNIT[\"metre\",1]],USAGE[SCOPE[\"Navigation and medium accuracy spatial referencing.\"],AREA[\"Between 120\u00b0E and 126\u00b0E, southern hemisphere between 80\u00b0S and equator, onshore and offshore. Australia. East Timor. Indonesia.\"],BBOX[-80,120,0,126]],ID[\"EPSG\",32751]]semi_major_axis :6378137.0semi_minor_axis :6356752.314245179inverse_flattening :298.257223563reference_ellipsoid_name :WGS 84longitude_of_prime_meridian :0.0prime_meridian_name :Greenwichgeographic_crs_name :WGS 84horizontal_datum_name :World Geodetic System 1984 ensembleprojected_crs_name :WGS 84 / UTM zone 51Sgrid_mapping_name :transverse_mercatorlatitude_of_projection_origin :0.0longitude_of_central_meridian :123.0false_easting :500000.0false_northing :10000000.0scale_factor_at_central_meridian :0.9996GeoTransform :411000 100 0 8015200 0 -100<pre>array(32751, dtype=int32)</pre></li></ul></li><li>Data variables: (11)<ul><li>mot(y, x)float320.9604 0.9604 ... 0.945 0.945<pre>array([[0.9604192 , 0.9604192 , 0.9604192 , ..., 0.94841766, 0.94841766,\n        0.94841766],\n       [0.9602612 , 0.9602612 , 0.9602612 , ..., 0.94841766, 0.94841766,\n        0.94841766],\n       [0.9601032 , 0.9601032 , 0.9601032 , ..., 0.94841766, 0.94841766,\n        0.94841766],\n       ...,\n       [0.9507797 , 0.9507314 , 0.9506832 , ..., 0.94531006, 0.9452503 ,\n        0.9451905 ],\n       [0.9507185 , 0.9506704 , 0.9506224 , ..., 0.94520926, 0.9451481 ,\n        0.94508696],\n       [0.9506573 , 0.9506095 , 0.95056164, ..., 0.9451084 , 0.9450459 ,\n        0.9449834 ]], dtype=float32)</pre></li><li>mat(y, x)float32-0.0001393 ... -0.0001331<pre>array([[-0.00013928, -0.00013928, -0.00013928, ..., -0.00013212,\n        -0.00013212, -0.00013212],\n       [-0.00013935, -0.00013935, -0.00013935, ..., -0.00013212,\n        -0.00013212, -0.00013212],\n       [-0.00013941, -0.00013941, -0.00013941, ..., -0.00013212,\n        -0.00013212, -0.00013212],\n       ...,\n       [-0.00013798, -0.00013792, -0.00013787, ..., -0.00013313,\n        -0.0001331 , -0.00013307],\n       [-0.00013797, -0.00013791, -0.00013786, ..., -0.00013315,\n        -0.00013312, -0.00013309],\n       [-0.00013796, -0.0001379 , -0.00013785, ..., -0.00013316,\n        -0.00013313, -0.00013311]], dtype=float32)</pre></li><li>hot(y, x)float323.894 3.894 3.894 ... 3.968 3.968<pre>array([[3.893658 , 3.893658 , 3.893658 , ..., 3.9606166, 3.9606166,\n        3.9606166],\n       [3.8949463, 3.8949463, 3.8949463, ..., 3.9606166, 3.9606166,\n        3.9606166],\n       [3.896235 , 3.896235 , 3.896235 , ..., 3.9606166, 3.9606166,\n        3.9606166],\n       ...,\n       [3.9451735, 3.9453878, 3.9456022, ..., 3.9668965, 3.967097 ,\n        3.9672973],\n       [3.9453273, 3.945541 , 3.9457548, ..., 3.967124 , 3.9673274,\n        3.9675305],\n       [3.945481 , 3.9456942, 3.945907 , ..., 3.9673514, 3.9675577,\n        3.967764 ]], dtype=float32)</pre></li><li>hat(y, x)float324.526 4.526 4.526 ... 4.804 4.805<pre>array([[4.525696 , 4.525696 , 4.525696 , ..., 4.776062 , 4.776062 ,\n        4.776062 ],\n       [4.529426 , 4.529426 , 4.529426 , ..., 4.776062 , 4.776062 ,\n        4.776062 ],\n       [4.533156 , 4.533156 , 4.533156 , ..., 4.776062 , 4.776062 ,\n        4.776062 ],\n       ...,\n       [4.703561 , 4.7045383, 4.705516 , ..., 4.8015537, 4.80244  ,\n        4.8033266],\n       [4.7042484, 4.7052226, 4.7061973, ..., 4.8025007, 4.803399 ,\n        4.8042974],\n       [4.704936 , 4.7059073, 4.7068787, ..., 4.803448 , 4.804358 ,\n        4.805268 ]], dtype=float32)</pre></li><li>lot(y, x)float32-2.242 -2.242 ... -2.407 -2.408<pre>array([[-2.24229  , -2.24229  , -2.24229  , ..., -2.3871295, -2.3871295,\n        -2.3871295],\n       [-2.2447054, -2.2447054, -2.2447054, ..., -2.3871295, -2.3871295,\n        -2.3871295],\n       [-2.247121 , -2.247121 , -2.247121 , ..., -2.3871295, -2.3871295,\n        -2.3871295],\n       ...,\n       [-2.3523507, -2.3528633, -2.353376 , ..., -2.4054003, -2.4059076,\n        -2.4064147],\n       [-2.3527904, -2.353301 , -2.3538117, ..., -2.4060407, -2.4065561,\n        -2.4070716],\n       [-2.35323  , -2.3537388, -2.3542476, ..., -2.4066813, -2.4072049,\n        -2.4077284]], dtype=float32)</pre></li><li>lat(y, x)float32-4.457 -4.457 ... -4.702 -4.702<pre>array([[-4.4569407, -4.4569407, -4.4569407, ..., -4.682302 , -4.682302 ,\n        -4.682302 ],\n       [-4.4600477, -4.4600477, -4.4600477, ..., -4.682302 , -4.682302 ,\n        -4.682302 ],\n       [-4.4631553, -4.4631553, -4.4631553, ..., -4.682302 , -4.682302 ,\n        -4.682302 ],\n       ...,\n       [-4.6061306, -4.607048 , -4.607965 , ..., -4.6992726, -4.7001348,\n        -4.700997 ],\n       [-4.606638 , -4.607552 , -4.6084666, ..., -4.6999707, -4.700843 ,\n        -4.7017145],\n       [-4.6071453, -4.6080565, -4.608968 , ..., -4.700669 , -4.7015505,\n        -4.702432 ]], dtype=float32)</pre></li><li>otr(y, x)float326.136 6.136 6.136 ... 6.375 6.375<pre>array([[6.135948 , 6.135948 , 6.135948 , ..., 6.347746 , 6.347746 ,\n        6.347746 ],\n       [6.1396523, 6.1396523, 6.1396523, ..., 6.347746 , 6.347746 ,\n        6.347746 ],\n       [6.143356 , 6.143356 , 6.143356 , ..., 6.347746 , 6.347746 ,\n        6.347746 ],\n       ...,\n       [6.297524 , 6.298251 , 6.298978 , ..., 6.372297 , 6.3730044,\n        6.373712 ],\n       [6.2981176, 6.298842 , 6.2995663, ..., 6.3731647, 6.3738832,\n        6.3746023],\n       [6.298711 , 6.2994328, 6.3001547, ..., 6.3740325, 6.3747625,\n        6.375492 ]], dtype=float32)</pre></li><li>tr(y, x)float328.983 8.983 8.983 ... 9.506 9.508<pre>array([[8.982636 , 8.982636 , 8.982636 , ..., 9.4583645, 9.4583645,\n        9.4583645],\n       [8.989474 , 8.989474 , 8.989474 , ..., 9.4583645, 9.4583645,\n        9.4583645],\n       [8.996311 , 8.996311 , 8.996311 , ..., 9.4583645, 9.4583645,\n        9.4583645],\n       ...,\n       [9.309691 , 9.311586 , 9.313481 , ..., 9.500826 , 9.502575 ,\n        9.504323 ],\n       [9.310886 , 9.312776 , 9.314664 , ..., 9.502472 , 9.504242 ,\n        9.506012 ],\n       [9.312081 , 9.313964 , 9.315846 , ..., 9.504117 , 9.505908 ,\n        9.5077   ]], dtype=float32)</pre></li><li>spread(y, x)float320.6831 0.6831 ... 0.6706 0.6706<pre>array([[0.6831408 , 0.6831408 , 0.6831408 , ..., 0.6711251 , 0.6711251 ,\n        0.6711251 ],\n       [0.6830334 , 0.6830334 , 0.6830334 , ..., 0.6711251 , 0.6711251 ,\n        0.6711251 ],\n       [0.68292594, 0.68292594, 0.68292594, ..., 0.6711251 , 0.6711251 ,\n        0.6711251 ],\n       ...,\n       [0.6764562 , 0.6763963 , 0.6763364 , ..., 0.6707161 , 0.67066693,\n        0.6706178 ],\n       [0.676433  , 0.6763733 , 0.67631364, ..., 0.6706913 , 0.67064184,\n        0.6705923 ],\n       [0.67640984, 0.67635036, 0.6762908 , ..., 0.6706665 , 0.6706167 ,\n        0.6705668 ]], dtype=float32)</pre></li><li>offset_low(y, x)float320.2466 0.2466 ... 0.2414 0.2414<pre>array([[0.2466003 , 0.2466003 , 0.2466003 , ..., 0.24266061, 0.24266061,\n        0.24266061],\n       [0.24648985, 0.24648985, 0.24648985, ..., 0.24266061, 0.24266061,\n        0.24266061],\n       [0.2463794 , 0.2463794 , 0.2463794 , ..., 0.24266061, 0.24266061,\n        0.24266061],\n       ...,\n       [0.24209201, 0.24208617, 0.24208033, ..., 0.24144351, 0.24143647,\n        0.2414294 ],\n       [0.24206817, 0.24206237, 0.24205658, ..., 0.2414077 , 0.24140027,\n        0.24139284],\n       [0.24204431, 0.24203856, 0.24203281, ..., 0.24137188, 0.24136409,\n        0.24135628]], dtype=float32)</pre></li><li>offset_high(y, x)float320.07026 0.07026 ... 0.08802 0.08808<pre>array([[0.07025888, 0.07025888, 0.07025888, ..., 0.08621421, 0.08621421,\n        0.08621421],\n       [0.07047673, 0.07047673, 0.07047673, ..., 0.08621421, 0.08621421,\n        0.08621421],\n       [0.0706946 , 0.0706946 , 0.0706946 , ..., 0.08621421, 0.08621421,\n        0.08621421],\n       ...,\n       [0.08145174, 0.08151747, 0.0815832 , ..., 0.08784036, 0.08789657,\n        0.08795279],\n       [0.08149877, 0.08156426, 0.08162975, ..., 0.08790096, 0.0879579 ,\n        0.08801485],\n       [0.08154581, 0.08161106, 0.08167631, ..., 0.08796157, 0.08801924,\n        0.0880769 ]], dtype=float32)</pre></li></ul></li><li>Indexes: (2)<ul><li>yPandasIndex<pre>PandasIndex(Index([8015150.0, 8015050.0, 8014950.0, 8014850.0, 8014750.0, 8014650.0,\n       8014550.0, 8014450.0, 8014350.0, 8014250.0,\n       ...\n       8004950.0, 8004850.0, 8004750.0, 8004650.0, 8004550.0, 8004450.0,\n       8004350.0, 8004250.0, 8004150.0, 8004050.0],\n      dtype='float64', name='y', length=112))</pre></li><li>xPandasIndex<pre>PandasIndex(Index([411050.0, 411150.0, 411250.0, 411350.0, 411450.0, 411550.0, 411650.0,\n       411750.0, 411850.0, 411950.0,\n       ...\n       420750.0, 420850.0, 420950.0, 421050.0, 421150.0, 421250.0, 421350.0,\n       421450.0, 421550.0, 421650.0],\n      dtype='float64', name='x', length=107))</pre></li></ul></li><li>Attributes: (0)</li></ul> <p>We can plot these statistics to inspect any spatial tide bias patterns:</p> In\u00a0[10]: Copied! <pre>import matplotlib.pyplot as plt\n\nstats_ds.spread.plot.imshow()\nplt.gca().set_title(\"Spread (%)\");\n</pre> import matplotlib.pyplot as plt  stats_ds.spread.plot.imshow() plt.gca().set_title(\"Spread (%)\"); In\u00a0[11]: Copied! <pre>stats_ds.offset_low.plot.imshow()\nplt.gca().set_title(\"Low tide offset (%)\");\n</pre> stats_ds.offset_low.plot.imshow() plt.gca().set_title(\"Low tide offset (%)\"); In\u00a0[12]: Copied! <pre>stats_ds.offset_high.plot.imshow()\nplt.gca().set_title(\"High tide offset (%)\");\n</pre> stats_ds.offset_high.plot.imshow() plt.gca().set_title(\"High tide offset (%)\"); In\u00a0[13]: Copied! <pre>from eo_tides.stats import tide_aliasing\n\ntide_aliasing(satellites=[\"landsat\", \"sentinel-2\"], style=False)\n</pre> from eo_tides.stats import tide_aliasing  tide_aliasing(satellites=[\"landsat\", \"sentinel-2\"], style=False) <pre>Using 8 day revisit for landsat\nUsing 5 day revisit for sentinel-2\n</pre> Out[13]: name period aliasing_period landsat sentinel-2 constituents sa Solar annual 365.242 365.242 365.242 ssa Solar semiannual 182.621 182.621 182.621 mm Lunar monthly 27.555 27.555 27.555 msf Lunisolar synodic fortnightly 14.765 17.460 14.765 mf Lunar declinational fortnightly 13.661 19.306 13.661 mt Termensual 9.133 64.491 11.049 2q1 Smaller elliptical diurnal 1.167 55.409 17.559 sigma1 Lunar variational diurnal 1.160 75.811 16.179 q1 Larger lunar elliptical diurnal 1.120 54.812 10.725 rho1 Larger lunar evectional diurnal 1.113 43.288 10.194 o1 Lunar diurnal 1.076 18.337 14.192 tau1 1.070 16.663 15.387 m1 Smaller lunar elliptical diurnal 1.035 29.531 29.531 chi1 Smaller evectional diurnal 1.030 34.847 34.847 pi1 Solar elliptical diurnal 1.006 182.621 182.621 p1 Principal solar diurnal 1.003 365.242 365.242 s1 Raditional solar diurnal 1.000 inf inf k1 Principal declinational diurnal 0.997 365.242 365.242 psi1 Smaller solar elliptical diurnal 0.995 182.621 182.621 phi1 Second-order solar diurnal 0.992 121.747 121.747 theta1 Evectional diurnal 0.967 29.263 29.263 j1 Smaller lunar elliptical diurnal 0.962 25.622 25.622 oo1 Second-order lunar diurnal 0.929 20.383 13.168 eps2 0.547 21.393 35.391 2n2 Second-order lunar elliptical semidiurnal 0.538 65.318 16.753 mu2 Lunar variational 0.536 95.668 15.493 n2 Larger lunar elliptical semidiurnal 0.527 47.660 10.419 nu2 Larger lunar evectional semidiurnal 0.526 38.701 10.085 m2 Principal lunar semidiurnal 0.518 17.460 14.765 lambda2 Smaller lunar evectional 0.509 27.555 27.555 l2 Smaller lunar elliptical semidiurnal 0.508 31.812 31.812 t2 Larger solar elliptical semidiurnal 0.501 365.242 365.242 s2 Principal solar semidiurnal 0.500 inf inf r2 Smaller solar elliptical semidiurnal 0.499 365.242 365.242 k2 Lunisolar declinational semidiurnal 0.499 182.621 182.621 eta2 0.490 23.942 23.942 m3 Principal lunar terdiurnal 0.345 42.716 10.162 <p>In the examples above, we can see several interesting results:</p> <ul> <li>Constituents like <code>m2</code> and <code>o1</code> can be observed effectively by EO satellites, requiring only 14-18 days of data to capture the full tide cycle.</li> <li>Constituents like <code>sa</code>, <code>k1</code>, <code>p1</code> require a full year of data to be observed effectively, meaning shorter EO analysis will capture a biased portion of the tide cycle.</li> <li>Constituents like <code>s2</code> have an infinite aliasing period. This means that no matter how long a satellite observes the coast, it will never capture the entire tidal cycle for this constituent.</li> </ul> <p>The <code>tide_aliasing</code> function can be customised to return results in different time units (e.g. years), or specific tide constituents only:</p> In\u00a0[14]: Copied! <pre>tide_aliasing(\n    satellites=[\"landsat\", \"sentinel-2\"],\n    constituents=[\"m2\", \"s2\", \"k1\", \"o1\", \"p1\", \"sa\"],\n    units=\"years\",\n    style=False,\n)\n</pre> tide_aliasing(     satellites=[\"landsat\", \"sentinel-2\"],     constituents=[\"m2\", \"s2\", \"k1\", \"o1\", \"p1\", \"sa\"],     units=\"years\",     style=False, ) <pre>Using 8 day revisit for landsat\nUsing 5 day revisit for sentinel-2\n</pre> Out[14]: name period aliasing_period landsat sentinel-2 constituents m2 Principal lunar semidiurnal 0.0014 0.0478 0.0404 s2 Principal solar semidiurnal 0.0014 inf inf k1 Principal declinational diurnal 0.0027 1.0000 1.0000 o1 Lunar diurnal 0.0029 0.0502 0.0389 p1 Principal solar diurnal 0.0027 1.0000 1.0000 sa Solar annual 1.0000 1.0000 1.0000 <p>To run the function for satellites that are not supported by default, provide a dictionary to <code>satellites</code> with the overpass frequency in days:</p> In\u00a0[15]: Copied! <pre>tide_aliasing(\n    satellites={\"custom-sat\": 3},\n    constituents=[\"m2\", \"s2\", \"k1\", \"o1\", \"p1\", \"sa\"],\n    style=False,\n)\n</pre> tide_aliasing(     satellites={\"custom-sat\": 3},     constituents=[\"m2\", \"s2\", \"k1\", \"o1\", \"p1\", \"sa\"],     style=False, ) <pre>Using 3 day revisit for custom-sat\n</pre> Out[15]: name period aliasing_period custom-sat constituents m2 Principal lunar semidiurnal 0.518 14.765 s2 Principal solar semidiurnal 0.500 inf k1 Principal declinational diurnal 0.997 365.242 o1 Lunar diurnal 1.076 14.192 p1 Principal solar diurnal 1.003 365.242 sa Solar annual 365.242 365.242"},{"location":"notebooks/Tide_statistics/#calculating-tide-statistics-and-satellite-biases","title":"Calculating tide statistics and satellite biases\u00b6","text":"<p>This guide demonstrates how to use the <code>tide_stats</code>,  <code>pixel_stats</code> and <code>tide_aliasing</code> functions from <code>eo_tides.stats</code> to calculate local tide statistics and identify biases caused by interactions between tidal processes and satellite orbits.</p> <p>Complex tide aliasing interactions between temporal tide dynamics and the regular overpass timing of sun-synchronous satellite sensors mean that satellites often do not always observe the entire tidal cycle. Biases in satellite coverage of the tidal cycle can mean that tidal extremes (e.g. the lowest or highest tides at a location) or particular tidal processes may either never be captured by satellites, or be over-represented in the satellite record. Local tide dynamics can cause these biases to vary greatly both through time and space, making it challenging to compare coastal processes consistently - particularly for large-scale coastal EO analyses.</p> <p>To ensure that coastal EO analyses are not inadvertently affected by tide biases, it is important to compare how well the tides observed by satellites match the full range of tides at a location. The <code>tidal_stats</code> and <code>pixel_stats</code> functions compares the subset of tides observed by satellite data against the full range of tides modelled at a regular interval through time (every two hours by default) across the entire time period covered by the satellite dataset. This comparison is used to calculate several useful statistics and plots that summarise how well your satellite data capture real-world tidal conditions. The <code>tide_aliasing</code> function can be used to identify potential temporal tide biases, and ensure EO analyses include enough satellite data to adequately sample the entire tide cycle.</p> <p>Figure 1: Example of tide biases in Landsat satellite data across coastal Australia (Bishop-Taylor et al. 2018). \"Spread\" represents the proportion of the astronomical tide range observed by satellites; low and high tide \"offsets\" represent the proportion of highest and lowest tides never observed.</p> <p>Tip</p> <p>         For a more detailed discussion of the issue of tidal bias in sun-synchronous satellite observations of the coastline, refer to the 'Limitations and future work' section in Bishop-Taylor et al. 2018. </p>"},{"location":"notebooks/Tide_statistics/#getting-started","title":"Getting started\u00b6","text":"<p>As in the previous examples, our first step is to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here).</p> <p>We can also define the tide model we want to use the for analysis; for example, the default model \"EOT20\".</p>"},{"location":"notebooks/Tide_statistics/#load-sentinel-2-satellite-data-using-odc-stac","title":"Load Sentinel-2 satellite data using odc-stac\u00b6","text":"<p>We can now load a time-series of satellite data over our area of interest using the Open Data Cube's <code>odc-stac</code> package. In this example, we will load Sentinel-2 satellite data from 2021-2023 over the city of Broome, Western Australia. We will load this data from the Microsoft Planetary Computer STAC catalogue.</p> <p>Tip</p> <p>         For a more detailed guide to using STAC metadata and <code>odc-stac</code> to find and load satellite data, refer to the odc-stac Python package documentation. <code>eo-tides</code> is compatible with satellite data loaded from any STAC API, for example Digital Earth Australia.     </p>"},{"location":"notebooks/Tide_statistics/#using-tide_stats","title":"Using tide_stats\u00b6","text":"<p>Once we have loaded some satellite data, we can pass this to the <code>tide_stats</code> function to calculate local tide statistics and reveal any potential tidal biases. The <code>tide_stats</code> function will return a plain-text summary below, as well as a visual plot that compares the distribution of satellite-observed tides (black dots) against the full range of modelled astronomical tide conditions (blue) using three useful metrics:</p> <ol> <li>Spread: The proportion of the full modelled astronomical tidal range that was observed by satellites. A high value indicating good coverage of the tide range.</li> <li>High tide offset: The proportion of the highest tides not observed by satellites at any time, as a proportion of the full modelled astronomical tidal range. A high value indicates that the satellite data is biased towards never capturing high tides.</li> <li>Low tide offset: The proportion of the lowest tides not observed by satellites at any time, as a proportion of the full modelled astronomical tidal range. A high value indicates that the satellite data is biased towards never capturing low tides.</li> </ol> <p>Tip</p> <p>         For a more detailed description of these biases, see Bishop-Taylor et al. 2018. </p>"},{"location":"notebooks/Tide_statistics/#compare-against-sentinel-1-tide-biases","title":"Compare against Sentinel-1 tide biases\u00b6","text":"<p>In the previous example, we saw that Sentinel-2 data was biased towards never capturing low tide at our location. These biases are caused by the consistent 10:30 am local overpass time of the Sentinel-2 satellites, which due to a phenomenon called \"tide-aliasing\" means that certain tides never occur when the satellite overpasses.</p> <p>One possible way around these biases is to use different satellite data from satellites that overpass at different times. For example, Sentinel-1 radar satellites follow a different orbit to Sentinel-2, overpassing at a local time of 6:00 pm instead of 10:30 am. This difference in overpass time potentially means that Sentinel-1 satellite data may capture different tides to Sentinel-2.</p> <p>In the next example, we run the <code>tide_stats</code> function on data loaded from Sentinel-1 for the same location and time period to see if this data is affected by the same tide biases.</p>"},{"location":"notebooks/Tide_statistics/#calculate-biases-for-multiple-satellite-sensors","title":"Calculate biases for multiple satellite sensors\u00b6","text":"<p>At our location, Sentinel-2 optical satellites are biased towards high tide observations, while Sentinel-1 radar satellites are biased towards low tide observations. Could combining data from multiple EO sensors help us capture a more complete view of tides at this location?</p> <p>To test this theory, we can combine Sentinel-2 and Sentinel-1 data into a single <code>xarray.Dataset</code>, recording the name of each sensor using a new <code>satellite_name</code> coordinate in our data:</p>"},{"location":"notebooks/Tide_statistics/#using-pixel_stats","title":"Using pixel_stats\u00b6","text":""},{"location":"notebooks/Tide_statistics/#modelling-tide-statistics-and-biases-spatially","title":"Modelling tide statistics and biases spatially\u00b6","text":"<p>Because tide regimes and satellite biases can vary greatly along the coast, it can be useful to plot these biases spatially. To do this, we can use the <code>pixel_stats</code> function.</p> <p><code>pixel_stats</code> works similarly to <code>tide_stats</code>, except that statistics are calculated across the entire extent of your satellite dataset. The function will generate an <code>xarray.Dataset</code> output containing the statistics discussed above as two-dimensional arrays.</p> <p>Tip</p> <p>         The <code>pixel_stats</code> function uses <code>eo_tides.eo.pixel_tides</code> to model tides spatially. You can experiment passing in parameters like <code>resolution</code> and <code>buffer</code> to customise the modelling grid used for calculating tide biases. Be warned however that you can quickly run out of memory with large analyses, given the number of timesteps required to model astronomical low and high tide.     </p>"},{"location":"notebooks/Tide_statistics/#tide-aliasing-for-satellite-sensors","title":"Tide aliasing for satellite sensors\u00b6","text":"<p>The biases above are caused by interactions between satellite overpasses and the natural cycles of tidal constituents called tide aliasing. Tide aliasing occurs because EO satellites typically capture imagery of the coastline at a frequency that does not align with the frequencies of the many harmonic tidal constituents that produce tides.</p> <p>The aliasing period of a tidal constituent describes how long it would take for a satellite to sample the entire tidal cycle for each constituent, based on the satellite's observation frequency.</p> <p>We can use the <code>eo_tides.stats.tide_aliasing</code> function to estimate aliasing periods for tide constituents, based on the overpass frequency of common EO satellites:</p> <ul> <li>Short aliasing periods mean the satellite will observe the full range of tidal variation relatively quickly, reducing the risk of tide-related bias.</li> <li>Long aliasing periods indicate that it will take much longer to sample all tidal conditions, increasing the risk that satellite analyses may misrepresent tidal dynamics.</li> </ul> <p>Note</p> <p>         Revisit periods are approximate and based on nominal repeat cycles at the equator. Actual observation frequency may vary due to latitude, cloud cover, sensor availability, and acquisition planning.     </p>"},{"location":"notebooks/Tide_statistics/#next-steps","title":"Next steps\u00b6","text":"<p>We have explored calculating tide statistics and biases in EO data. Now we can learn how to validate modelled tides against measured tide gauge data to ensure the tides we are modelling are accurate.</p>"},{"location":"notebooks/Validating_tides/","title":"Validating modelled tide heights","text":"In\u00a0[1]: Copied! <pre>directory = \"../../tests/data/tide_models/\"\n</pre> directory = \"../../tests/data/tide_models/\" In\u00a0[2]: Copied! <pre>gesla_data_path = \"../../tests/data/GESLA4_ALL/\"\ngesla_metadata_path = \"../../tests/data/GESLA4_ALL.csv\"\n</pre> gesla_data_path = \"../../tests/data/GESLA4_ALL/\" gesla_metadata_path = \"../../tests/data/GESLA4_ALL.csv\" <p>To load GESLA data, we can pass in <code>x</code> and <code>y</code> coordinates (and optionally time period). In this example, the function will load one month (January 2014) of tide data for the nearest available GESLA tide gauge to the coastal town of Derby, Western Australia.</p> <p>Tip</p> <p>         Pass a set of bounding box tuples (e.g. <code>x=(120, 130), y=(-20, -30)</code> to return all tide gauges within a bounding box instead.     </p> In\u00a0[3]: Copied! <pre>from eo_tides.validation import load_gauge_gesla\n\nx, y = 123.606725, -17.291899\n\n# Load gauge data\ngauge_df = load_gauge_gesla(\n    x=x,\n    y=y,\n    time=(\"2014-01\", \"2014-01\"),\n    correct_mean=True,\n    data_path=gesla_data_path,\n    metadata_path=gesla_metadata_path,\n)\ngauge_df.head()\n</pre> from eo_tides.validation import load_gauge_gesla  x, y = 123.606725, -17.291899  # Load gauge data gauge_df = load_gauge_gesla(     x=x,     y=y,     time=(\"2014-01\", \"2014-01\"),     correct_mean=True,     data_path=gesla_data_path,     metadata_path=gesla_metadata_path, ) gauge_df.head() <pre>Loading GESLA gauges: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 44.60it/s]\n</pre> Out[3]: sea_level qc_flag use_flag file_name site_name country contributor_abbreviated contributor_full contributor_website contributor_contact ... start_date_time end_date_time number_of_years time_zone_hours datum_information instrument precision null_value gauge_type overall_record_quality site_code time DYDBY01 2014-01-01 02:00:00 -3.51346 1 1 ../../tests/data/GESLA4_ALL/derby-dydby01-aus-bom Derby AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 1982/04/25 03:00:00 2016/12/04 16:45:00 24 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal Possible datum issues 2014-01-01 03:00:00 -1.16346 1 1 ../../tests/data/GESLA4_ALL/derby-dydby01-aus-bom Derby AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 1982/04/25 03:00:00 2016/12/04 16:45:00 24 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal Possible datum issues 2014-01-01 04:00:00 0.83654 1 1 ../../tests/data/GESLA4_ALL/derby-dydby01-aus-bom Derby AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 1982/04/25 03:00:00 2016/12/04 16:45:00 24 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal Possible datum issues 2014-01-01 05:00:00 2.42654 1 1 ../../tests/data/GESLA4_ALL/derby-dydby01-aus-bom Derby AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 1982/04/25 03:00:00 2016/12/04 16:45:00 24 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal Possible datum issues 2014-01-01 06:00:00 3.04654 1 1 ../../tests/data/GESLA4_ALL/derby-dydby01-aus-bom Derby AUS BOM Bureau of Meteorology http://www.bom.gov.au/oceanography/projects/nt... tides@bom.gov.au ... 1982/04/25 03:00:00 2016/12/04 16:45:00 24 0 Chart Datum / Lowest Astronomical Tide Unspecified Unspecified -99.9999 Coastal Possible datum issues <p>5 rows \u00d7 26 columns</p> <p>We have successfully loaded data for the Derby tide gauge (GESLA site code DYDBY01)! We can now plot sea levels over time:</p> In\u00a0[4]: Copied! <pre>gauge_df.droplevel(\"site_code\").sea_level.plot()\n</pre> gauge_df.droplevel(\"site_code\").sea_level.plot() Out[4]: <pre>&lt;Axes: xlabel='time'&gt;</pre> In\u00a0[5]: Copied! <pre>import pandas as pd\n\nfrom eo_tides.model import model_tides\n\nmodelled_df = model_tides(\n    x=x,\n    y=y,\n    time=gauge_df.index.get_level_values(\"time\"),\n    directory=directory,\n)\n\n# Print outputs\nmodelled_df.head()\n</pre> import pandas as pd  from eo_tides.model import model_tides  modelled_df = model_tides(     x=x,     y=y,     time=gauge_df.index.get_level_values(\"time\"),     directory=directory, )  # Print outputs modelled_df.head() <pre>Modelling tides with EOT20\n</pre> Out[5]: tide_model tide_height time x y 2014-01-01 02:00:00 123.606725 -17.291899 EOT20 -1.407719 2014-01-01 03:00:00 123.606725 -17.291899 EOT20 0.602376 2014-01-01 04:00:00 123.606725 -17.291899 EOT20 2.393473 2014-01-01 05:00:00 123.606725 -17.291899 EOT20 3.396102 2014-01-01 06:00:00 123.606725 -17.291899 EOT20 3.387681 In\u00a0[6]: Copied! <pre>import matplotlib.pyplot as plt\n\n# Join our modelled data to the timesteps in our gauge data\njoined_df = gauge_df.join(modelled_df).dropna()\n\n# Plot as a scatterplot with 1:1 line\nax = joined_df.plot.scatter(x=\"sea_level\", y=\"tide_height\")\nplt.plot([-5, 5], [-5, 5], c=\"red\", linestyle=\"dashed\")\nax.set_aspect(1.0)\nax.set_ylabel(\"Modelled tide (m)\")\nax.set_xlabel(\"GESLA sea level (m)\");\n</pre> import matplotlib.pyplot as plt  # Join our modelled data to the timesteps in our gauge data joined_df = gauge_df.join(modelled_df).dropna()  # Plot as a scatterplot with 1:1 line ax = joined_df.plot.scatter(x=\"sea_level\", y=\"tide_height\") plt.plot([-5, 5], [-5, 5], c=\"red\", linestyle=\"dashed\") ax.set_aspect(1.0) ax.set_ylabel(\"Modelled tide (m)\") ax.set_xlabel(\"GESLA sea level (m)\"); <p>We can see that both datasets are correlated, although with some visible noise and inaccuracy. To quantify this, we can use the <code>eo_tides.validation.eval_metrics</code> function to compare them and calculate some useful accuracy statistics, including Root Mean Square Error (RMSE), Mean Absolute Error (MAE), R-squared and bias.</p> <p>Our results show that our modelled tides are highly correlated with observed sea levels at this location, but only accurate to approximately 1 metre RMSE:</p> In\u00a0[7]: Copied! <pre>from eo_tides.validation import eval_metrics\n\n# Calculate accuracy metrics\naccuracy_metrics = eval_metrics(x=joined_df.sea_level, y=joined_df.tide_height)\naccuracy_metrics\n</pre> from eo_tides.validation import eval_metrics  # Calculate accuracy metrics accuracy_metrics = eval_metrics(x=joined_df.sea_level, y=joined_df.tide_height) accuracy_metrics Out[7]: <pre>Correlation         0.961\nRMSE                0.968\nMAE                 0.816\nR-squared           0.923\nBias                0.764\nRegression slope    0.942\ndtype: float64</pre> In\u00a0[8]: Copied! <pre>models = [\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"]\n\nmodelled_df = model_tides(\n    x=x,\n    y=y,\n    time=gauge_df.index.get_level_values(\"time\"),\n    model=models,\n    output_format=\"wide\",\n    directory=directory,\n)\nmodelled_df.head()\n</pre> models = [\"EOT20\", \"GOT5.5\", \"HAMTIDE11\"]  modelled_df = model_tides(     x=x,     y=y,     time=gauge_df.index.get_level_values(\"time\"),     model=models,     output_format=\"wide\",     directory=directory, ) modelled_df.head() <pre>Modelling tides with EOT20, GOT5.5, HAMTIDE11 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 11.82it/s]\n</pre> <pre>Converting to a wide format dataframe\n</pre> Out[8]: tide_model EOT20 GOT5.5 HAMTIDE11 time x y 2014-01-01 02:00:00 123.606725 -17.291899 -1.407719 -1.588029 -0.889604 2014-01-01 03:00:00 123.606725 -17.291899 0.602376 0.137677 -1.101312 2014-01-01 04:00:00 123.606725 -17.291899 2.393473 1.861487 -1.032183 2014-01-01 05:00:00 123.606725 -17.291899 3.396102 3.014030 -0.704035 2014-01-01 06:00:00 123.606725 -17.291899 3.387681 3.211730 -0.204451 <p>We can now merge these modelled tides with our measured gauge data, and plot a comparison of each model against our tide gauge data:</p> In\u00a0[9]: Copied! <pre># Join our modelled data to the timesteps in our gauge data\njoined_df = gauge_df.join(modelled_df).dropna()\n\n# Plot measured sea levels and modelled data\nfig, axes = plt.subplots(1, 3, figsize=(12, 4))\n\nfor ax, col in zip(axes, models, strict=True):\n    joined_df.droplevel([\"site_code\", \"x\", \"y\"]).plot.scatter(x=\"sea_level\", y=col, ax=ax, s=10)\n    min_val = min(joined_df[\"sea_level\"].min(), joined_df[col].min())\n    max_val = max(joined_df[\"sea_level\"].max(), joined_df[col].max())\n    ax.plot([min_val, max_val], [min_val, max_val], c=\"red\", linestyle=\"dashed\")\n    ax.set_aspect(1.0)\n\nplt.tight_layout()\nplt.show()\n</pre> # Join our modelled data to the timesteps in our gauge data joined_df = gauge_df.join(modelled_df).dropna()  # Plot measured sea levels and modelled data fig, axes = plt.subplots(1, 3, figsize=(12, 4))  for ax, col in zip(axes, models, strict=True):     joined_df.droplevel([\"site_code\", \"x\", \"y\"]).plot.scatter(x=\"sea_level\", y=col, ax=ax, s=10)     min_val = min(joined_df[\"sea_level\"].min(), joined_df[col].min())     max_val = max(joined_df[\"sea_level\"].max(), joined_df[col].max())     ax.plot([min_val, max_val], [min_val, max_val], c=\"red\", linestyle=\"dashed\")     ax.set_aspect(1.0)  plt.tight_layout() plt.show() <p>Now, we can loop through each of our models and calculate accuracy metrics compared to our gauge data:</p> In\u00a0[10]: Copied! <pre># Calculate accuracy metrics for each model and combine into a DataFrame\ncombined_accuracy_df = pd.DataFrame({\n    model: eval_metrics(x=joined_df.sea_level, y=joined_df[model]) for model in models\n})\n\ncombined_accuracy_df\n</pre> # Calculate accuracy metrics for each model and combine into a DataFrame combined_accuracy_df = pd.DataFrame({     model: eval_metrics(x=joined_df.sea_level, y=joined_df[model]) for model in models })  combined_accuracy_df Out[10]: EOT20 GOT5.5 HAMTIDE11 Correlation 0.961 0.971 -0.141 RMSE 0.968 0.874 2.377 MAE 0.816 0.726 2.076 R-squared 0.923 0.942 0.020 Bias 0.764 0.697 0.048 Regression slope 0.942 0.888 -0.052 <p>As we can see above, at this location GOT5.5 has the best overall accuracy as measured by RMSE and MAE, while HAMTIDE11 was significantly less accurate and uncorrelated with our tide gauge data.</p> In\u00a0[11]: Copied! <pre>import logging\n\nimport dask.distributed\nimport odc.stac\n\nfrom eo_tides.validation import tide_correlation\n\n# Hide excessive logs from Dask\nlogging.getLogger(\"distributed\").setLevel(logging.ERROR)\n\n# Set up cloud access\nodc.stac.configure_s3_access(aws_unsigned=True)\n\n# Start client\nclient = dask.distributed.Client()\ndisplay(client)\n</pre> import logging  import dask.distributed import odc.stac  from eo_tides.validation import tide_correlation  # Hide excessive logs from Dask logging.getLogger(\"distributed\").setLevel(logging.ERROR)  # Set up cloud access odc.stac.configure_s3_access(aws_unsigned=True)  # Start client client = dask.distributed.Client() display(client) Client <p>Client-ad47e435-a33e-11f0-93fd-431e78c3e1eb</p> Connection method: Cluster object Cluster type: distributed.LocalCluster Dashboard:  http://127.0.0.1:8787/status Cluster Info LocalCluster <p>de69600c</p> Dashboard: http://127.0.0.1:8787/status Workers: 2                  Total threads: 2                  Total memory: 7.76 GiB                  Status: running Using processes: True Scheduler Info Scheduler <p>Scheduler-423cc21b-9e06-4456-b4fc-5dee4780cb15</p> Comm: tcp://127.0.0.1:38011                      Workers: 0                       Dashboard: http://127.0.0.1:8787/status Total threads: 0                      Started: Just now                      Total memory: 0 B                      Workers Worker: 0 Comm:  tcp://127.0.0.1:45739                          Total threads:  1                          Dashboard:  http://127.0.0.1:38329/status Memory:  3.88 GiB                          Nanny:  tcp://127.0.0.1:46447                          Local directory:  /tmp/dask-scratch-space/worker-u9krabe8                          Worker: 1 Comm:  tcp://127.0.0.1:42893                          Total threads:  1                          Dashboard:  http://127.0.0.1:33445/status Memory:  3.88 GiB                          Nanny:  tcp://127.0.0.1:41849                          Local directory:  /tmp/dask-scratch-space/worker-f58ia_r6                          <p>Now we have set things up, we can run the <code>tide_correlation</code> function. To improve load times, we only load satellite images with less than 5% cloud cover, and turn off loading Sentinel-2 data.</p> In\u00a0[12]: Copied! <pre># Run tide correlation analysis\ncorr_df, corr_da = tide_correlation(\n    x=x,\n    y=y,\n    directory=directory,\n    cloud_cover=5,\n    load_s2=False,\n)\n</pre> # Run tide correlation analysis corr_df, corr_da = tide_correlation(     x=x,     y=y,     directory=directory,     cloud_cover=5,     load_s2=False, ) <pre>Found 86 STAC items for landsat-c2-l2\nSetting tide modelling location from dataset centroid: 123.61, -17.29\nModelling tides with EOT20, GOT5.5, HAMTIDE11 in parallel (models: 3, splits: 1)\n</pre> <pre>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 3/3 [00:00&lt;00:00, 10.68it/s]\nIgnoring read failure while reading: https://landsateuwest.blob.core.windows.net/landsat-c2/level-2/standard/oli-tirs/2022/110/072/LC08_L2SP_110072_20221102_20221114_02_T1/LC08_L2SP_110072_20221102_20221114_02_T1_QA_PIXEL.TIF?st=2025-10-06T05%3A31%3A32Z&amp;se=2025-10-07T06%3A16%3A32Z&amp;sp=rl&amp;sv=2025-07-05&amp;sr=c&amp;skoid=9c8ff44a-6a2c-4dfb-b298-1c9212f64d9a&amp;sktid=72f988bf-86f1-41af-91ab-2d7cd011db47&amp;skt=2025-10-06T14%3A05%3A49Z&amp;ske=2025-10-13T14%3A05%3A49Z&amp;sks=b&amp;skv=2025-07-05&amp;sig=7Rv1Z9FpRlPL2vzjwCGXLcQ/u9CpPdCiJLqdMyjJWDs%3D:1\n/workspaces/eo-tides/.venv/lib/python3.12/site-packages/dask/array/numpy_compat.py:57: RuntimeWarning: invalid value encountered in divide\n  x = np.divide(x1, x2, out)\n/workspaces/eo-tides/.venv/lib/python3.12/site-packages/dask/array/numpy_compat.py:57: RuntimeWarning: invalid value encountered in divide\n  x = np.divide(x1, x2, out)\n/workspaces/eo-tides/.venv/lib/python3.12/site-packages/dask/_task_spec.py:759: RuntimeWarning: invalid value encountered in divide\n  return self.func(*new_argspec)\n</pre> <p>Our output includes the \"correlation\" and \"rank\" of each tide model with a satellite-derived water index (in this case, Normalised Difference Water Index or NDWI). High correlations indicate that a tide model correctly orders satellite observations by tide height, with high tides consistently wet and low tides consistently dry.</p> <p>In this location, we can see that our model rankings match the results we got previously for our tide gauge validation: both EOT20 and GOT5.5 are correlated with satellite-observed inundation patterns, however the last-ranked HAMTIDE11 was very poorly correlated:</p> In\u00a0[13]: Copied! <pre>corr_df\n</pre> corr_df Out[13]: correlation rank x y valid_perc tide_model EOT20 0.424624 2.0 123.606725 -17.291899 0.425489 GOT5.5 0.435037 1.0 123.606725 -17.291899 0.425489 HAMTIDE11 -0.058055 3.0 123.606725 -17.291899 0.425489 <p>The <code>tide_correlation</code> function also returns an <code>xarray.DataArray</code> showing tide correlations for every satellite pixel around the selected point. Plotting this output lets us inspect how correlations vary spatially: deep blue indicating pixels where inundation patterns were highly correlated with a tide model, while white and red indicates pixels where tide modelling performance was poor.</p> In\u00a0[14]: Copied! <pre>corr_da.plot.imshow(col=\"tide_model\", cmap=\"RdBu\", vmin=-1.0, vmax=1.0)\n</pre> corr_da.plot.imshow(col=\"tide_model\", cmap=\"RdBu\", vmin=-1.0, vmax=1.0) Out[14]: <pre>&lt;xarray.plot.facetgrid.FacetGrid at 0x73c85028bec0&gt;</pre>"},{"location":"notebooks/Validating_tides/#validating-modelled-tide-heights","title":"Validating modelled tide heights\u00b6","text":"<p>This guide demonstrates how to use the <code>load_gauge_gesla</code> and <code>tide_correlation</code> functions from <code>eo_tides.validation</code> to validate modelled tides from <code>eo-tides</code>.</p> <p>The tide models used by <code>eo-tides</code> can vary significantly in accuracy across the world's coastlines. Evaluating the accuracy of your modelled tides is critical for ensuring that resulting marine or coastal EO analyses are reliable and useful.</p> <p>The <code>load_gauge_gesla</code> function provides a convenient tool for loading high-quality sea-level measurements from the GESLA Global Extreme Sea Level Analysis archive \u2013 a global archive of almost 127,623 years of sea level data from 6,474 records across the world. This data can be used to compare against tides modelled using <code>eo-tides</code> to calculate the accuracy of your tide modelling and identify the optimal tide models to use for your study area.</p> <p>The <code>tide_correlation</code> provides a novel remote sensing approach to rank tide models by performance based on their correlation with satellite-observed patterns of inundation. This can be particularly useful for identifying optimal tidal models at locations far from the nearest tide gauge. This approach is used to inform more complex analysis tools like ensemble tide modelling in <code>model_tides</code>.</p>"},{"location":"notebooks/Validating_tides/#getting-started","title":"Getting started\u00b6","text":"<p>As in the previous examples, our first step is to tell <code>eo-tides</code> the location of our tide model directory (if you haven't set this up, refer to the setup instructions here):</p>"},{"location":"notebooks/Validating_tides/#tide-gauge-validation","title":"Tide gauge validation\u00b6","text":""},{"location":"notebooks/Validating_tides/#loading-gesla-tide-gauge-data","title":"Loading GESLA tide gauge data\u00b6","text":"<p>To evaluate the accuracy of our tide models, we first load a time series of measured sea-level data from a GESLA tide gauge using <code>eo_tides.validation.load_gauge_gesla</code>.</p> <p>To obtain GESLA data, you will need to download both \"GESLA-4 DATA\" (<code>GESLA4_ALL.zip</code>) and \"GESLA-4 CSV META-DATA FILE\" (<code>GESLA4_ALL.csv</code>) from the Downloads page of the GESLA website, and save and extract these to a convenient location.</p> <p>We have provided an example below; replace these paths to point to your downloaded data.</p>"},{"location":"notebooks/Validating_tides/#modelled-tides","title":"Modelled tides\u00b6","text":"<p>We can now model tides for the exact timesteps that we have tide gauge data for using the <code>eo_tides.model.model_tides</code> function:</p>"},{"location":"notebooks/Validating_tides/#validation-against-gesla-tide-gauges","title":"Validation against GESLA tide gauges\u00b6","text":"<p>Now we have modelled some tides and loaded some measured sea-level data, we can compare them. Note that because the timeseries above is missing some data in late January, we need to \"join\" our modelled <code>modelled_df</code> data to the timesteps present in <code>gauge_df</code>.</p> <p>Now let's generate a scatterplot with our measured data on the x-axis, and our modelled tides on the y-axis:</p>"},{"location":"notebooks/Validating_tides/#identifying-best-local-tide-models","title":"Identifying best local tide models\u00b6","text":"<p>Because different ocean tide models can perform better or worse in different locations, it can be valuable to compare the accuracy of different models against measured gauge data. This can help us make an informed decision about the best model to use for a given application or study area.</p> <p>In the example below, we will use <code>model_tides</code> to model tides using three different models: EOT20, GOT5.5, and HAMTIDE11:</p>"},{"location":"notebooks/Validating_tides/#tide-correlation-model-rankings","title":"Tide correlation model rankings\u00b6","text":"<p>Direct comparison with observed tide gauge data will always be the gold standard for tide model validation. However, in large-scale coastal remote sensing, analyses are often applied to areas far from any available gauge records. This makes it challenging to select the most suitable tide model for a given location.</p> <p>The <code>eo_tides.validation.tide_correlation</code> function offers a novel remote sensing\u2013based approach that ranks tide models by how well modelled tides explain patterns of inundation (e.g. wet vs. dry) observed in satellite imagery. A key advantage of this method is that it can be applied anywhere globally, as long as there is enough intertidal zone for satellites to detect differences in inundation between low and high tide.</p> <p>In the example below, we run a tide correlation analysis for the same Derby, Western Australia location as above. By default, this analysis loads a large volume of Landsat satellite data from Microsoft Planetary Computer. To improve performance, we first run several preparatory steps to optimise data loading.</p> <p>Tip</p> <p>         The <code>dask.distributed.Client()</code> uses a package called Dask to load data in parallel. This can greatly improve data loading time, particularly on computers with multiple analysis cores.     </p>"},{"location":"notebooks/Validating_tides/#advanced-usage","title":"Advanced usage\u00b6","text":"<p>For more advanced use, the tide_correlation function can be run on pre-loaded satellite water index data via the <code>data</code> parameter, rather than automatically fetching data from Microsoft Planetary Computer. This allows tide correlation analyses to be applied to any satellite dataset, for example, Digital Earth Australia or Planet Labs. When pre-loaded data is supplied, all data loading parameters (<code>x</code>, <code>y</code>, <code>time</code>, <code>crs</code>, <code>buffer</code> <code>cloud_cover</code>, <code>load_ls</code>, <code>load_s2</code>) are ignored.</p> <pre># Run tide correlation analysis on pre-loaded satellite data\ncorr_df, corr_da = tide_correlation(data=pre_loaded_da, ...)\n</pre>"}]}